#!/usr/bin/env python3
"""
Aegis Document Management - PDF editing, OCR, and cloud sync for Workplace edition
Features: PDF editing, OCR tools, cloud sync configuration, version control

Provides GUI (GTK) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import shutil
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any

TIER_LIMIT = "workplace"
VERSION = "1.5.0"
APP_NAME = "Aegis Document Management"

CONFIG_FILE = "/etc/aegis/workplace-config.json"
LOG_FILE = "/var/log/aegis/document-management.log"
DATA_DIR = "/var/lib/aegis/documents"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, GLib
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False
    print("Error: GTK3 is required. Install with: sudo pacman -S gtk3 python-gobject", file=sys.stderr)


class LicenseTier:
    FREEMIUM = 1
    BASIC = 2
    WORKPLACE = 3
    GAMER = 4
    SERVER = 5


CLOUD_PROVIDERS = {
    "onedrive": {"name": "Microsoft OneDrive", "command": "onedrive", "config_dir": "~/.config/onedrive"},
    "gdrive": {"name": "Google Drive", "command": "rclone", "config_dir": "~/.config/rclone"},
    "dropbox": {"name": "Dropbox", "command": "dropbox", "config_dir": "~/.dropbox"},
    "nextcloud": {"name": "Nextcloud", "command": "nextcloudcmd", "config_dir": "~/.config/Nextcloud"}
}

PDF_TOOLS = {
    "pdfarranger": {"name": "PDF Arranger", "command": "pdfarranger", "description": "Merge, split, rotate PDFs"},
    "xournal": {"name": "Xournal++", "command": "xournalpp", "description": "PDF annotation"},
    "okular": {"name": "Okular", "command": "okular", "description": "PDF viewer with annotations"},
    "libreoffice-draw": {"name": "LibreOffice Draw", "command": "lodraw", "description": "PDF editing"}
}

OCR_TOOLS = {
    "tesseract": {"name": "Tesseract OCR", "command": "tesseract", "description": "Open source OCR engine"},
    "ocrmypdf": {"name": "OCRmyPDF", "command": "ocrmypdf", "description": "Add OCR to PDFs"}
}


class AegisDocumentManagement:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.config = {}
        self.license_tier = LicenseTier.FREEMIUM
        
        self.setup_logging()
        self.load_license_tier()
        self.load_config()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            pass
        
        try:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[
                    logging.FileHandler(LOG_FILE) if os.access(str(log_dir), os.W_OK) else logging.NullHandler(),
                    logging.StreamHandler() if not self.headless else logging.NullHandler()
                ]
            )
        except Exception:
            logging.basicConfig(level=logging.INFO, handlers=[logging.StreamHandler()])
        
        self.logger = logging.getLogger("AegisDocumentManagement")
        self.logger.info(f"Starting {APP_NAME} v{VERSION}")
    
    def load_license_tier(self):
        license_file = Path("/etc/aegis/license.json")
        try:
            if license_file.exists():
                with open(license_file, 'r') as f:
                    license_data = json.load(f)
                edition = license_data.get('edition', 'freemium').lower()
                tier_map = {
                    'freemium': LicenseTier.FREEMIUM,
                    'basic': LicenseTier.BASIC,
                    'workplace': LicenseTier.WORKPLACE,
                    'gamer': LicenseTier.GAMER,
                    'server': LicenseTier.SERVER
                }
                self.license_tier = tier_map.get(edition, LicenseTier.FREEMIUM)
            else:
                if Path("/etc/aegis-workplace-marker").exists():
                    self.license_tier = LicenseTier.WORKPLACE
        except Exception as e:
            self.logger.warning(f"Failed to load license tier: {e}")
    
    def is_feature_available(self, feature: str) -> bool:
        workplace_features = ["pdf_editing", "ocr", "cloud_sync", "version_control"]
        if feature in workplace_features:
            return self.license_tier >= LicenseTier.WORKPLACE
        return False
    
    def load_config(self):
        default_config = {
            "pdf_editing": True,
            "ocr_enabled": True,
            "cloud_sync": True,
            "default_cloud": "gdrive",
            "sync_folder": str(Path.home() / "Documents" / "Aegis")
        }
        
        try:
            if Path(CONFIG_FILE).exists():
                with open(CONFIG_FILE, 'r') as f:
                    file_config = json.load(f)
                    if "features" in file_config and "document_management" in file_config["features"]:
                        self.config = {**default_config, **file_config["features"]["document_management"]}
                    else:
                        self.config = default_config
            else:
                self.config = default_config
        except Exception as e:
            self.logger.error(f"Error loading config: {e}")
            self.config = default_config
    
    def check_tool_installed(self, command: str) -> bool:
        return shutil.which(command) is not None
    
    def launch_pdf_tool(self, tool_id: str, file_path: Optional[str] = None) -> bool:
        if not self.is_feature_available("pdf_editing"):
            return False
        
        if tool_id not in PDF_TOOLS:
            return False
        
        tool = PDF_TOOLS[tool_id]
        if not self.check_tool_installed(tool["command"]):
            self.logger.error(f"{tool['name']} not installed")
            return False
        
        try:
            cmd = [tool["command"]]
            if file_path:
                cmd.append(file_path)
            subprocess.Popen(cmd, start_new_session=True)
            self.logger.info(f"Launched {tool['name']}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to launch {tool['name']}: {e}")
            return False
    
    def run_ocr(self, input_file: str, output_file: Optional[str] = None, language: str = "eng") -> Dict[str, Any]:
        if not self.is_feature_available("ocr"):
            return {"success": False, "error": "OCR requires Workplace edition"}
        
        if not Path(input_file).exists():
            return {"success": False, "error": "Input file not found"}
        
        if not output_file:
            input_path = Path(input_file)
            output_file = str(input_path.parent / f"{input_path.stem}_ocr{input_path.suffix}")
        
        if self.check_tool_installed("ocrmypdf"):
            try:
                result = subprocess.run(
                    ["ocrmypdf", "-l", language, "--skip-text", input_file, output_file],
                    capture_output=True, text=True, timeout=300
                )
                if result.returncode == 0:
                    self.logger.info(f"OCR complete: {output_file}")
                    return {"success": True, "output_file": output_file}
                else:
                    return {"success": False, "error": result.stderr}
            except subprocess.TimeoutExpired:
                return {"success": False, "error": "OCR timed out"}
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        elif self.check_tool_installed("tesseract"):
            try:
                result = subprocess.run(
                    ["tesseract", input_file, output_file.rsplit('.', 1)[0], "-l", language, "pdf"],
                    capture_output=True, text=True, timeout=300
                )
                if result.returncode == 0:
                    return {"success": True, "output_file": output_file}
                else:
                    return {"success": False, "error": result.stderr}
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        return {"success": False, "error": "No OCR tool available"}
    
    def get_cloud_sync_status(self) -> Dict[str, Any]:
        status = {}
        for provider_id, provider in CLOUD_PROVIDERS.items():
            config_dir = Path(provider["config_dir"]).expanduser()
            status[provider_id] = {
                "name": provider["name"],
                "installed": self.check_tool_installed(provider["command"]),
                "configured": config_dir.exists()
            }
        return status
    
    def sync_cloud_folder(self, provider: str, local_path: str, remote_path: str) -> Dict[str, Any]:
        if not self.is_feature_available("cloud_sync"):
            return {"success": False, "error": "Cloud sync requires Workplace edition"}
        
        if provider not in CLOUD_PROVIDERS:
            return {"success": False, "error": f"Unknown provider: {provider}"}
        
        provider_info = CLOUD_PROVIDERS[provider]
        if not self.check_tool_installed(provider_info["command"]):
            return {"success": False, "error": f"{provider_info['name']} not installed"}
        
        try:
            if provider == "gdrive":
                cmd = ["rclone", "sync", local_path, f"gdrive:{remote_path}"]
            elif provider == "onedrive":
                cmd = ["onedrive", "--synchronize", "--single-directory", remote_path]
            else:
                return {"success": False, "error": "Provider sync not implemented"}
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            if result.returncode == 0:
                return {"success": True, "synced_to": remote_path}
            else:
                return {"success": False, "error": result.stderr}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _convert_document(self, input_file: str, output_format: str, output_file: Optional[str] = None) -> Dict[str, Any]:
        if not self.is_feature_available("pdf_editing"):
            return {"success": False, "error": "Document conversion requires Workplace edition"}
        
        if not Path(input_file).exists():
            return {"success": False, "error": "Input file not found"}
        
        input_path = Path(input_file)
        if not output_file:
            output_file = str(input_path.parent / f"{input_path.stem}.{output_format}")
        
        output_dir = str(Path(output_file).parent)
        
        if self.check_tool_installed("libreoffice"):
            try:
                result = subprocess.run(
                    ["libreoffice", "--headless", "--convert-to", output_format, 
                     "--outdir", output_dir, input_file],
                    capture_output=True, text=True, timeout=300
                )
                if result.returncode == 0:
                    self.logger.info(f"Converted {input_file} to {output_format}")
                    return {"success": True, "output_file": output_file, "tool": "libreoffice"}
                else:
                    self.logger.warning(f"LibreOffice conversion failed: {result.stderr}")
            except subprocess.TimeoutExpired:
                return {"success": False, "error": "Conversion timed out"}
            except Exception as e:
                self.logger.warning(f"LibreOffice error: {e}")
        
        if self.check_tool_installed("unoconv"):
            try:
                result = subprocess.run(
                    ["unoconv", "-f", output_format, "-o", output_file, input_file],
                    capture_output=True, text=True, timeout=300
                )
                if result.returncode == 0:
                    self.logger.info(f"Converted {input_file} to {output_format} using unoconv")
                    return {"success": True, "output_file": output_file, "tool": "unoconv"}
                else:
                    return {"success": False, "error": result.stderr}
            except subprocess.TimeoutExpired:
                return {"success": False, "error": "Conversion timed out"}
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        return {"success": False, "error": "No conversion tool available (libreoffice or unoconv required)"}
    
    def _merge_pdfs(self, input_files: List[str], output_file: str) -> Dict[str, Any]:
        if not self.is_feature_available("pdf_editing"):
            return {"success": False, "error": "PDF merging requires Workplace edition"}
        
        for f in input_files:
            if not Path(f).exists():
                return {"success": False, "error": f"Input file not found: {f}"}
        
        if len(input_files) < 2:
            return {"success": False, "error": "At least 2 input files required"}
        
        if self.check_tool_installed("pdftk"):
            try:
                cmd = ["pdftk"] + input_files + ["cat", "output", output_file]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                if result.returncode == 0:
                    self.logger.info(f"Merged {len(input_files)} PDFs to {output_file}")
                    return {"success": True, "output_file": output_file, "tool": "pdftk", 
                            "merged_count": len(input_files)}
                else:
                    self.logger.warning(f"pdftk merge failed: {result.stderr}")
            except subprocess.TimeoutExpired:
                return {"success": False, "error": "Merge timed out"}
            except Exception as e:
                self.logger.warning(f"pdftk error: {e}")
        
        if self.check_tool_installed("qpdf"):
            try:
                cmd = ["qpdf", "--empty", "--pages"] + input_files + ["--", output_file]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                if result.returncode == 0:
                    self.logger.info(f"Merged {len(input_files)} PDFs using qpdf")
                    return {"success": True, "output_file": output_file, "tool": "qpdf",
                            "merged_count": len(input_files)}
                else:
                    return {"success": False, "error": result.stderr}
            except subprocess.TimeoutExpired:
                return {"success": False, "error": "Merge timed out"}
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        if self.check_tool_installed("pdfunite"):
            try:
                cmd = ["pdfunite"] + input_files + [output_file]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                if result.returncode == 0:
                    self.logger.info(f"Merged {len(input_files)} PDFs using pdfunite")
                    return {"success": True, "output_file": output_file, "tool": "pdfunite",
                            "merged_count": len(input_files)}
                else:
                    return {"success": False, "error": result.stderr}
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        return {"success": False, "error": "No PDF merge tool available (pdftk, qpdf, or pdfunite required)"}
    
    def _extract_text(self, input_file: str, output_file: Optional[str] = None) -> Dict[str, Any]:
        if not self.is_feature_available("pdf_editing"):
            return {"success": False, "error": "Text extraction requires Workplace edition"}
        
        if not Path(input_file).exists():
            return {"success": False, "error": "Input file not found"}
        
        input_path = Path(input_file)
        if not output_file:
            output_file = str(input_path.parent / f"{input_path.stem}.txt")
        
        if self.check_tool_installed("pdftotext"):
            try:
                result = subprocess.run(
                    ["pdftotext", "-layout", input_file, output_file],
                    capture_output=True, text=True, timeout=120
                )
                if result.returncode == 0:
                    with open(output_file, 'r', encoding='utf-8', errors='ignore') as f:
                        text_content = f.read()
                    self.logger.info(f"Extracted text from {input_file}")
                    return {"success": True, "output_file": output_file, "tool": "pdftotext",
                            "char_count": len(text_content)}
                else:
                    self.logger.warning(f"pdftotext failed: {result.stderr}")
            except subprocess.TimeoutExpired:
                return {"success": False, "error": "Text extraction timed out"}
            except Exception as e:
                self.logger.warning(f"pdftotext error: {e}")
        
        if self.check_tool_installed("tesseract"):
            try:
                result = subprocess.run(
                    ["tesseract", input_file, output_file.rsplit('.', 1)[0], "-l", "eng"],
                    capture_output=True, text=True, timeout=300
                )
                if result.returncode == 0:
                    actual_output = output_file.rsplit('.', 1)[0] + ".txt"
                    if Path(actual_output).exists():
                        with open(actual_output, 'r', encoding='utf-8', errors='ignore') as f:
                            text_content = f.read()
                        self.logger.info(f"Extracted text using OCR from {input_file}")
                        return {"success": True, "output_file": actual_output, "tool": "tesseract",
                                "char_count": len(text_content), "method": "ocr"}
                else:
                    self.logger.warning(f"tesseract OCR failed: {result.stderr}")
            except subprocess.TimeoutExpired:
                return {"success": False, "error": "OCR text extraction timed out"}
            except Exception as e:
                self.logger.warning(f"tesseract error: {e}")
        
        if self.check_tool_installed("pdfgrep"):
            try:
                result = subprocess.run(
                    ["pdfgrep", "-P", ".", input_file],
                    capture_output=True, text=True, timeout=120
                )
                if result.returncode == 0:
                    with open(output_file, 'w', encoding='utf-8') as f:
                        f.write(result.stdout)
                    self.logger.info(f"Extracted text using pdfgrep from {input_file}")
                    return {"success": True, "output_file": output_file, "tool": "pdfgrep",
                            "char_count": len(result.stdout)}
            except Exception as e:
                self.logger.warning(f"pdfgrep error: {e}")
        
        return {"success": False, "error": "No text extraction tool available (pdftotext, tesseract, or pdfgrep required)"}
    
    def _compress_pdf(self, input_file: str, output_file: Optional[str] = None, 
                      quality: str = "ebook") -> Dict[str, Any]:
        if not self.is_feature_available("pdf_editing"):
            return {"success": False, "error": "PDF compression requires Workplace edition"}
        
        if not Path(input_file).exists():
            return {"success": False, "error": "Input file not found"}
        
        input_path = Path(input_file)
        if not output_file:
            output_file = str(input_path.parent / f"{input_path.stem}_compressed.pdf")
        
        quality_settings = {
            "screen": "/screen",
            "ebook": "/ebook",
            "printer": "/printer",
            "prepress": "/prepress",
            "default": "/default"
        }
        gs_quality = quality_settings.get(quality, "/ebook")
        
        original_size = input_path.stat().st_size
        
        if self.check_tool_installed("gs"):
            try:
                result = subprocess.run([
                    "gs", "-sDEVICE=pdfwrite", "-dCompatibilityLevel=1.4",
                    f"-dPDFSETTINGS={gs_quality}", "-dNOPAUSE", "-dQUIET", "-dBATCH",
                    f"-sOutputFile={output_file}", input_file
                ], capture_output=True, text=True, timeout=600)
                
                if result.returncode == 0 and Path(output_file).exists():
                    compressed_size = Path(output_file).stat().st_size
                    reduction = ((original_size - compressed_size) / original_size) * 100
                    self.logger.info(f"Compressed PDF: {reduction:.1f}% reduction")
                    return {
                        "success": True, "output_file": output_file, "tool": "ghostscript",
                        "original_size": original_size, "compressed_size": compressed_size,
                        "reduction_percent": round(reduction, 2)
                    }
                else:
                    self.logger.warning(f"Ghostscript compression failed: {result.stderr}")
            except subprocess.TimeoutExpired:
                return {"success": False, "error": "Compression timed out"}
            except Exception as e:
                self.logger.warning(f"Ghostscript error: {e}")
        
        if self.check_tool_installed("qpdf"):
            try:
                result = subprocess.run([
                    "qpdf", "--linearize", "--compress-streams=y",
                    "--object-streams=generate", input_file, output_file
                ], capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0 and Path(output_file).exists():
                    compressed_size = Path(output_file).stat().st_size
                    reduction = ((original_size - compressed_size) / original_size) * 100
                    self.logger.info(f"Compressed PDF with qpdf: {reduction:.1f}% reduction")
                    return {
                        "success": True, "output_file": output_file, "tool": "qpdf",
                        "original_size": original_size, "compressed_size": compressed_size,
                        "reduction_percent": round(reduction, 2)
                    }
                else:
                    return {"success": False, "error": result.stderr}
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        return {"success": False, "error": "No compression tool available (ghostscript or qpdf required)"}
    
    def _sign_document(self, input_file: str, output_file: Optional[str] = None,
                       cert_file: Optional[str] = None, key_file: Optional[str] = None,
                       reason: str = "Document signed by Aegis", 
                       location: str = "Aegis Workplace") -> Dict[str, Any]:
        if not self.is_feature_available("pdf_editing"):
            return {"success": False, "error": "Document signing requires Workplace edition"}
        
        if not Path(input_file).exists():
            return {"success": False, "error": "Input file not found"}
        
        input_path = Path(input_file)
        if not output_file:
            output_file = str(input_path.parent / f"{input_path.stem}_signed.pdf")
        
        if self.check_tool_installed("pdfsig"):
            if cert_file and key_file:
                if not Path(cert_file).exists():
                    return {"success": False, "error": "Certificate file not found"}
                if not Path(key_file).exists():
                    return {"success": False, "error": "Key file not found"}
                
                try:
                    result = subprocess.run([
                        "pdfsig", "-sign", input_file, output_file,
                        "-cert", cert_file, "-key", key_file,
                        "-reason", reason, "-location", location
                    ], capture_output=True, text=True, timeout=120)
                    
                    if result.returncode == 0:
                        self.logger.info(f"Signed PDF: {output_file}")
                        return {"success": True, "output_file": output_file, "tool": "pdfsig",
                                "reason": reason, "location": location}
                except Exception as e:
                    self.logger.warning(f"pdfsig error: {e}")
        
        if self.check_tool_installed("enscript") and self.check_tool_installed("ps2pdf"):
            try:
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                signature_text = f"Digitally signed on {timestamp}\nReason: {reason}\nLocation: {location}"
                
                temp_sig = f"/tmp/aegis_sig_{os.getpid()}.txt"
                temp_ps = f"/tmp/aegis_sig_{os.getpid()}.ps"
                temp_pdf = f"/tmp/aegis_sig_{os.getpid()}.pdf"
                
                with open(temp_sig, 'w') as f:
                    f.write(signature_text)
                
                subprocess.run(["enscript", "-p", temp_ps, temp_sig], 
                             capture_output=True, timeout=30)
                subprocess.run(["ps2pdf", temp_ps, temp_pdf], 
                             capture_output=True, timeout=30)
                
                if self.check_tool_installed("pdftk"):
                    result = subprocess.run([
                        "pdftk", input_file, "stamp", temp_pdf, "output", output_file
                    ], capture_output=True, text=True, timeout=120)
                    
                    if result.returncode == 0:
                        for f in [temp_sig, temp_ps, temp_pdf]:
                            try:
                                os.unlink(f)
                            except:
                                pass
                        self.logger.info(f"Added signature stamp to PDF: {output_file}")
                        return {"success": True, "output_file": output_file, 
                                "tool": "enscript+pdftk", "method": "stamp",
                                "timestamp": timestamp}
                
                for f in [temp_sig, temp_ps, temp_pdf]:
                    try:
                        os.unlink(f)
                    except:
                        pass
            except Exception as e:
                self.logger.warning(f"Signature stamp error: {e}")
        
        if self.check_tool_installed("qpdf"):
            try:
                shutil.copy(input_file, output_file)
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                
                self.logger.info(f"Created copy with metadata (no cryptographic signature)")
                return {
                    "success": True, "output_file": output_file, "tool": "qpdf",
                    "method": "metadata_only", "timestamp": timestamp,
                    "warning": "No cryptographic signature applied - pdfsig with certificates required"
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        return {"success": False, "error": "No signing tool available (pdfsig recommended, or pdftk for stamps)"}
    
    def get_available_tools(self) -> Dict[str, List[Dict[str, Any]]]:
        pdf_tools = []
        for tool_id, tool_info in PDF_TOOLS.items():
            pdf_tools.append({
                "id": tool_id,
                "name": tool_info["name"],
                "description": tool_info["description"],
                "installed": self.check_tool_installed(tool_info["command"])
            })
        
        ocr_tools = []
        for tool_id, tool_info in OCR_TOOLS.items():
            ocr_tools.append({
                "id": tool_id,
                "name": tool_info["name"],
                "description": tool_info["description"],
                "installed": self.check_tool_installed(tool_info["command"])
            })
        
        return {"pdf_tools": pdf_tools, "ocr_tools": ocr_tools}
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            print("GTK not available. Use --cli mode.")
            return self.run_cli()
        
        win = DocumentManagementWindow(self)
        win.connect("destroy", Gtk.main_quit)
        win.show_all()
        Gtk.main()
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"  License Tier: {'WORKPLACE+' if self.license_tier >= LicenseTier.WORKPLACE else 'LIMITED'}")
        print(f"{'='*60}\n")
        
        tools = self.get_available_tools()
        
        print("PDF Tools:")
        for tool in tools["pdf_tools"]:
            status = "✓" if tool["installed"] else "✗"
            print(f"  {tool['name']}: {status} - {tool['description']}")
        
        print("\nOCR Tools:")
        for tool in tools["ocr_tools"]:
            status = "✓" if tool["installed"] else "✗"
            print(f"  {tool['name']}: {status} - {tool['description']}")
        
        print("\nCloud Sync Status:")
        cloud_status = self.get_cloud_sync_status()
        for provider_id, status in cloud_status.items():
            configured = "Configured" if status["configured"] else "Not configured"
            installed = "✓" if status["installed"] else "✗"
            print(f"  {status['name']}: {installed} ({configured})")


if GTK_AVAILABLE:
    class DocumentManagementWindow(Gtk.Window):
        def __init__(self, app: AegisDocumentManagement):
            super().__init__(title=f"{APP_NAME} v{VERSION}")
            self.app = app
            self.set_default_size(800, 600)
            self.set_border_width(10)
            self.setup_ui()
        
        def setup_ui(self):
            vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            self.add(vbox)
            
            header = Gtk.Label()
            header.set_markup(f"<big><b>{APP_NAME}</b></big>")
            vbox.pack_start(header, False, False, 10)
            
            notebook = Gtk.Notebook()
            vbox.pack_start(notebook, True, True, 0)
            
            notebook.append_page(self.create_pdf_tab(), Gtk.Label(label="PDF Tools"))
            notebook.append_page(self.create_ocr_tab(), Gtk.Label(label="OCR"))
            notebook.append_page(self.create_cloud_tab(), Gtk.Label(label="Cloud Sync"))
        
        def create_pdf_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            for tool_id, tool_info in PDF_TOOLS.items():
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
                
                label = Gtk.Label(label=f"{tool_info['name']} - {tool_info['description']}")
                label.set_xalign(0)
                hbox.pack_start(label, True, True, 10)
                
                btn = Gtk.Button(label="Launch")
                btn.connect("clicked", self.on_launch_pdf_tool, tool_id)
                btn.set_sensitive(self.app.license_tier >= LicenseTier.WORKPLACE and 
                                 self.app.check_tool_installed(tool_info["command"]))
                hbox.pack_end(btn, False, False, 10)
                
                box.pack_start(hbox, False, False, 5)
            
            return box
        
        def create_ocr_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            file_chooser = Gtk.FileChooserButton(title="Select PDF for OCR")
            file_chooser.set_action(Gtk.FileChooserAction.OPEN)
            box.pack_start(file_chooser, False, False, 10)
            
            ocr_btn = Gtk.Button(label="Run OCR")
            ocr_btn.set_sensitive(self.app.license_tier >= LicenseTier.WORKPLACE)
            box.pack_start(ocr_btn, False, False, 10)
            
            return box
        
        def create_cloud_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            cloud_status = self.app.get_cloud_sync_status()
            for provider_id, status in cloud_status.items():
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
                
                label = Gtk.Label(label=status["name"])
                label.set_xalign(0)
                hbox.pack_start(label, True, True, 10)
                
                status_label = Gtk.Label()
                if status["installed"]:
                    status_label.set_markup("<span foreground='green'>✓ Installed</span>")
                else:
                    status_label.set_markup("<span foreground='red'>✗ Not installed</span>")
                hbox.pack_end(status_label, False, False, 10)
                
                box.pack_start(hbox, False, False, 5)
            
            return box
        
        def on_launch_pdf_tool(self, button, tool_id):
            self.app.launch_pdf_tool(tool_id)


def main():
    if not GTK_AVAILABLE:
        print(f"Cannot start {APP_NAME}: GTK3 not available.", file=sys.stderr)
        sys.exit(1)
    
    parser = argparse.ArgumentParser(description=f"{APP_NAME}")
    parser.add_argument("--gui", action="store_true", help="Launch GUI mode")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode")
    parser.add_argument("--launch-pdf", metavar="TOOL", help="Launch PDF tool")
    parser.add_argument("--ocr", metavar="FILE", help="Run OCR on file")
    parser.add_argument("--ocr-output", metavar="FILE", help="OCR output file")
    parser.add_argument("--list-tools", action="store_true", help="List available tools")
    parser.add_argument("--cloud-status", action="store_true", help="Show cloud sync status")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.launch_pdf:
        app = AegisDocumentManagement(headless=True)
        app.launch_pdf_tool(args.launch_pdf)
    elif args.ocr:
        app = AegisDocumentManagement(headless=True)
        result = app.run_ocr(args.ocr, args.ocr_output)
        print(json.dumps(result, indent=2))
    elif args.list_tools:
        app = AegisDocumentManagement(headless=True)
        print(json.dumps(app.get_available_tools(), indent=2))
    elif args.cloud_status:
        app = AegisDocumentManagement(headless=True)
        print(json.dumps(app.get_cloud_sync_status(), indent=2))
    elif args.cli or not GTK_AVAILABLE:
        app = AegisDocumentManagement(headless=False)
        app.run_cli()
    else:
        app = AegisDocumentManagement(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
