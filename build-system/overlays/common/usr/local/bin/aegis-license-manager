#!/usr/bin/env python3
"""
Aegis OS License Manager
GUI and CLI tool for license management and validation
"""

import argparse
import base64
import hashlib
import hmac
import json
import os
import socket
import ssl
import subprocess
import sys
import urllib.request
import urllib.error
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, Optional, Tuple

try:
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.backends import default_backend
    HAS_CRYPTO = True
except ImportError:
    HAS_CRYPTO = False

CONFIG_DIR = Path("/etc/aegis")
LICENSE_FILE = CONFIG_DIR / "license.json"
TIER_FILE = CONFIG_DIR / "tier.json"
TIER_FEATURES_FILE = CONFIG_DIR / "tier-features.json"
PUBLIC_KEY_FILE = CONFIG_DIR / "public-key.pem"
LOG_FILE = Path("/var/log/aegis-license.log")

AEGIS_LICENSE_SERVER = "https://api.aegis-os.com/license"
AEGIS_VALIDATE_ENDPOINT = f"{AEGIS_LICENSE_SERVER}/validate"

TIER_CODES = {
    'BAS': 'basic',
    'GAM': 'gamer',
    'WOR': 'workplace',
    'AID': 'ai-dev',
    'SER': 'server',
    'GAI': 'gamer-ai',
    'FRE': 'freemium'
}

TIER_NAMES = {
    'freemium': 'Freemium',
    'basic': 'Basic',
    'gamer': 'Gamer',
    'workplace': 'Workplace',
    'ai-dev': 'AI Developer',
    'server': 'Server',
    'gamer-ai': 'Gamer + AI'
}


def log_event(event_type: str, message: str, data: dict = None):
    """Log license events"""
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        entry = {
            'timestamp': datetime.now().isoformat(),
            'event': event_type,
            'message': message,
            'data': data or {}
        }
        with open(LOG_FILE, 'a') as f:
            f.write(json.dumps(entry) + '\n')
    except Exception:
        pass


def get_hardware_id() -> str:
    """Generate a unique hardware identifier"""
    components = []
    
    try:
        with open('/sys/class/dmi/id/product_uuid', 'r') as f:
            components.append(f.read().strip())
    except Exception:
        pass
    
    try:
        for iface in os.listdir('/sys/class/net'):
            if iface != 'lo':
                try:
                    with open(f'/sys/class/net/{iface}/address', 'r') as f:
                        mac = f.read().strip()
                        if mac and mac != '00:00:00:00:00:00':
                            components.append(mac)
                            break
                except Exception:
                    pass
    except Exception:
        pass
    
    try:
        hostname = socket.gethostname()
        components.append(hostname)
    except Exception:
        pass
    
    if not components:
        components.append('default-hardware-id')
    
    combined = '|'.join(components)
    return hashlib.sha256(combined.encode()).hexdigest()[:32]


def parse_license_key(license_key: str) -> Tuple[bool, dict]:
    """Parse and validate license key format"""
    try:
        parts = license_key.strip().upper().split('-')
        
        if len(parts) != 5:
            return False, {'error': 'Invalid license format: expected 5 parts'}
        
        if parts[0] != 'AEGIS':
            return False, {'error': 'Invalid license prefix'}
        
        tier_code = parts[1]
        if tier_code not in TIER_CODES:
            return False, {'error': f'Invalid tier code: {tier_code}'}
        
        for i, part in enumerate(parts[2:5]):
            if len(part) != 5 or not part.isalnum():
                return False, {'error': f'Invalid key segment {i+1}'}
        
        return True, {
            'tier_code': tier_code,
            'tier': TIER_CODES[tier_code],
            'segments': parts[2:5]
        }
    
    except Exception as e:
        return False, {'error': str(e)}


def load_public_key():
    """Load RSA public key for offline validation"""
    if not HAS_CRYPTO:
        return None
    
    try:
        with open(PUBLIC_KEY_FILE, 'rb') as f:
            return serialization.load_pem_public_key(
                f.read(),
                backend=default_backend()
            )
    except Exception:
        return None


def verify_signature(data: bytes, signature: bytes) -> bool:
    """Verify RSA signature using public key"""
    public_key = load_public_key()
    if not public_key:
        return False
    
    try:
        public_key.verify(
            signature,
            data,
            padding.PKCS1v15(),
            hashes.SHA256()
        )
        return True
    except Exception:
        return False


def validate_online(license_key: str, hardware_id: str) -> Tuple[bool, dict]:
    """Validate license against Aegis server"""
    try:
        payload = json.dumps({
            'license_key': license_key,
            'hardware_id': hardware_id,
            'timestamp': datetime.now().isoformat()
        }).encode()
        
        req = urllib.request.Request(
            AEGIS_VALIDATE_ENDPOINT,
            data=payload,
            headers={
                'Content-Type': 'application/json',
                'User-Agent': 'AegisLicenseManager/1.0'
            },
            method='POST'
        )
        
        context = ssl.create_default_context()
        
        with urllib.request.urlopen(req, timeout=10, context=context) as response:
            data = json.loads(response.read().decode())
            
            if data.get('valid'):
                return True, {
                    'tier': data.get('tier', 'freemium'),
                    'expires_at': data.get('expires_at'),
                    'license_type': data.get('license_type', 'unknown'),
                    'signature': data.get('signature'),
                    'validated_at': datetime.now().isoformat(),
                    'validation_method': 'online'
                }
            else:
                return False, {
                    'error': data.get('error', 'License validation failed'),
                    'reason': data.get('reason', 'unknown')
                }
    
    except urllib.error.URLError as e:
        return False, {'error': 'Network error', 'reason': str(e), 'offline': True}
    except Exception as e:
        return False, {'error': 'Validation error', 'reason': str(e)}


def validate_offline(license_key: str, stored_data: dict = None) -> Tuple[bool, dict]:
    """Validate license offline using stored data and signature"""
    valid, parsed = parse_license_key(license_key)
    if not valid:
        return False, parsed
    
    if stored_data:
        if stored_data.get('license_key') != license_key:
            return False, {'error': 'License key mismatch'}
        
        expires_at = stored_data.get('expires_at')
        if expires_at:
            try:
                expiry = datetime.fromisoformat(expires_at.replace('Z', '+00:00'))
                if datetime.now() > expiry.replace(tzinfo=None):
                    return False, {'error': 'License expired', 'expired_at': expires_at}
            except Exception:
                pass
        
        signature = stored_data.get('signature')
        if signature and HAS_CRYPTO:
            verify_data = json.dumps({
                'license_key': license_key,
                'tier': stored_data.get('tier'),
                'expires_at': expires_at
            }, sort_keys=True).encode()
            
            try:
                sig_bytes = base64.b64decode(signature)
                if not verify_signature(verify_data, sig_bytes):
                    log_event('validation', 'Signature verification failed', {'key': license_key[:15]})
            except Exception:
                pass
        
        return True, {
            'tier': stored_data.get('tier', parsed['tier']),
            'expires_at': expires_at,
            'license_type': stored_data.get('license_type', 'unknown'),
            'validated_at': datetime.now().isoformat(),
            'validation_method': 'offline'
        }
    
    return True, {
        'tier': parsed['tier'],
        'validated_at': datetime.now().isoformat(),
        'validation_method': 'offline_basic'
    }


def load_license() -> dict:
    """Load stored license data"""
    try:
        if LICENSE_FILE.exists():
            with open(LICENSE_FILE, 'r') as f:
                return json.load(f)
    except Exception:
        pass
    return {}


def save_license(data: dict):
    """Save license data"""
    try:
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        with open(LICENSE_FILE, 'w') as f:
            json.dump(data, f, indent=2)
        os.chmod(LICENSE_FILE, 0o600)
    except Exception as e:
        log_event('error', f'Failed to save license: {e}')
        raise


def update_tier(tier: str, license_data: dict = None):
    """Update current tier configuration"""
    try:
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        
        tier_data = {
            'current_tier': tier,
            'updated_at': datetime.now().isoformat(),
            'license_valid': tier != 'freemium'
        }
        
        if license_data:
            tier_data['expires_at'] = license_data.get('expires_at')
            tier_data['license_type'] = license_data.get('license_type')
        
        with open(TIER_FILE, 'w') as f:
            json.dump(tier_data, f, indent=2)
        
        log_event('tier_update', f'Tier updated to {tier}', tier_data)
        
    except Exception as e:
        log_event('error', f'Failed to update tier: {e}')


def get_current_tier() -> str:
    """Get current tier from tier.json"""
    try:
        if TIER_FILE.exists():
            with open(TIER_FILE, 'r') as f:
                data = json.load(f)
                return data.get('current_tier', 'freemium')
    except Exception:
        pass
    return 'freemium'


def manage_tier_services(tier: str, action: str = 'apply'):
    """Start/stop services based on tier"""
    try:
        if not TIER_FEATURES_FILE.exists():
            return
        
        with open(TIER_FEATURES_FILE, 'r') as f:
            features_data = json.load(f)
        
        tier_config = features_data['tiers'].get(tier, features_data['tiers']['freemium'])
        enabled_services = set(tier_config.get('services', []))
        
        all_services = set()
        for t_config in features_data['tiers'].values():
            all_services.update(t_config.get('services', []))
        
        for service in all_services:
            if service in enabled_services:
                subprocess.run(['systemctl', 'enable', '--now', service], 
                             capture_output=True, check=False)
            else:
                subprocess.run(['systemctl', 'disable', '--now', service],
                             capture_output=True, check=False)
        
        log_event('services', f'Applied services for tier {tier}', 
                  {'enabled': list(enabled_services)})
        
    except Exception as e:
        log_event('error', f'Failed to manage services: {e}')


def validate_license(license_key: str, force_online: bool = False) -> Tuple[bool, dict]:
    """Validate a license key"""
    valid, parsed = parse_license_key(license_key)
    if not valid:
        return False, parsed
    
    hardware_id = get_hardware_id()
    stored_data = load_license()
    
    if force_online or not stored_data.get('validated_at'):
        online_valid, online_result = validate_online(license_key, hardware_id)
        
        if online_valid:
            license_data = {
                'license_key': license_key,
                'hardware_id': hardware_id,
                **online_result
            }
            save_license(license_data)
            update_tier(online_result['tier'], online_result)
            log_event('validation', 'Online validation successful', 
                      {'tier': online_result['tier']})
            return True, online_result
        
        if not online_result.get('offline'):
            return False, online_result
    
    offline_valid, offline_result = validate_offline(license_key, stored_data)
    
    if offline_valid:
        if stored_data.get('license_key') != license_key:
            license_data = {
                'license_key': license_key,
                'hardware_id': hardware_id,
                **offline_result
            }
            save_license(license_data)
        
        update_tier(offline_result['tier'], offline_result)
        log_event('validation', 'Offline validation successful',
                  {'tier': offline_result['tier']})
        return True, offline_result
    
    return False, offline_result


def activate_license(license_key: str) -> Tuple[bool, str]:
    """Activate a new license key"""
    valid, result = validate_license(license_key, force_online=True)
    
    if valid:
        tier_name = TIER_NAMES.get(result['tier'], result['tier'])
        message = f"License activated successfully!\nTier: {tier_name}"
        if result.get('expires_at'):
            message += f"\nExpires: {result['expires_at']}"
        else:
            message += "\nType: Lifetime"
        return True, message
    else:
        return False, f"License activation failed: {result.get('error', 'Unknown error')}"


def get_license_status() -> dict:
    """Get current license status"""
    stored = load_license()
    current_tier = get_current_tier()
    
    status = {
        'tier': current_tier,
        'tier_name': TIER_NAMES.get(current_tier, current_tier),
        'licensed': current_tier != 'freemium',
        'license_key': None,
        'expires_at': None,
        'license_type': None,
        'features': {}
    }
    
    if stored:
        key = stored.get('license_key', '')
        if key:
            status['license_key'] = key[:10] + '...' + key[-5:] if len(key) > 15 else key
        status['expires_at'] = stored.get('expires_at')
        status['license_type'] = stored.get('license_type')
        status['validated_at'] = stored.get('validated_at')
    
    try:
        if TIER_FEATURES_FILE.exists():
            with open(TIER_FEATURES_FILE, 'r') as f:
                features_data = json.load(f)
            tier_config = features_data['tiers'].get(current_tier, {})
            status['features'] = tier_config.get('features', {})
            status['disabled_features'] = tier_config.get('disabled_features', [])
    except Exception:
        pass
    
    return status


def run_cli():
    """Command line interface"""
    parser = argparse.ArgumentParser(
        description='Aegis OS License Manager',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  aegis-license-manager --activate AEGIS-GAM-ABCDE-FGHIJ-KLMNO
  aegis-license-manager --status
  aegis-license-manager --validate
  aegis-license-manager --gui
        """
    )
    
    parser.add_argument('--activate', '-a', metavar='KEY',
                       help='Activate a license key')
    parser.add_argument('--status', '-s', action='store_true',
                       help='Show current license status')
    parser.add_argument('--validate', '-v', action='store_true',
                       help='Validate current license')
    parser.add_argument('--validate-boot', action='store_true',
                       help='Boot-time validation (internal use)')
    parser.add_argument('--apply-tier', action='store_true',
                       help='Apply tier services (internal use)')
    parser.add_argument('--gui', '-g', action='store_true',
                       help='Launch GUI mode')
    parser.add_argument('--deactivate', action='store_true',
                       help='Deactivate current license')
    parser.add_argument('--json', '-j', action='store_true',
                       help='Output in JSON format')
    
    args = parser.parse_args()
    
    if args.gui:
        return run_gui()
    
    if args.activate:
        success, message = activate_license(args.activate)
        if args.json:
            print(json.dumps({'success': success, 'message': message}))
        else:
            print(message)
        sys.exit(0 if success else 1)
    
    if args.status:
        status = get_license_status()
        if args.json:
            print(json.dumps(status, indent=2))
        else:
            print(f"Tier: {status['tier_name']} ({status['tier']})")
            print(f"Licensed: {'Yes' if status['licensed'] else 'No'}")
            if status['license_key']:
                print(f"License Key: {status['license_key']}")
            if status['expires_at']:
                print(f"Expires: {status['expires_at']}")
            elif status['license_type'] == 'lifetime':
                print("License Type: Lifetime")
        sys.exit(0)
    
    if args.validate or args.validate_boot:
        stored = load_license()
        if stored.get('license_key'):
            valid, result = validate_license(stored['license_key'])
            if args.json:
                print(json.dumps({'valid': valid, **result}))
            else:
                if valid:
                    print(f"License valid: {TIER_NAMES.get(result['tier'], result['tier'])}")
                else:
                    print(f"License invalid: {result.get('error', 'Unknown error')}")
            
            if not valid:
                update_tier('freemium')
            
            sys.exit(0 if valid else 1)
        else:
            if args.json:
                print(json.dumps({'valid': False, 'tier': 'freemium', 'message': 'No license installed'}))
            else:
                print("No license installed. Running in Freemium mode.")
            update_tier('freemium')
            sys.exit(0)
    
    if args.apply_tier:
        current_tier = get_current_tier()
        manage_tier_services(current_tier)
        print(f"Applied tier services for: {current_tier}")
        sys.exit(0)
    
    if args.deactivate:
        if LICENSE_FILE.exists():
            LICENSE_FILE.unlink()
        update_tier('freemium')
        print("License deactivated. Reverted to Freemium tier.")
        sys.exit(0)
    
    parser.print_help()
    sys.exit(0)


def run_gui():
    """GTK3 GUI mode"""
    try:
        import gi
        gi.require_version('Gtk', '3.0')
        from gi.repository import Gtk, GLib, Pango
    except ImportError:
        print("Error: GTK3 required. Install with: sudo pacman -S gtk3 python-gobject", file=sys.stderr)
        print("Falling back to CLI mode. Use --status or --activate options.", file=sys.stderr)
        sys.exit(1)
    
    class LicenseManagerWindow(Gtk.Window):
        def __init__(self):
            super().__init__(title="Aegis License Manager")
            self.set_default_size(500, 400)
            self.set_border_width(20)
            self.set_position(Gtk.WindowPosition.CENTER)
            
            main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
            self.add(main_box)
            
            header = Gtk.Label()
            header.set_markup("<span size='x-large' weight='bold'>Aegis OS License Manager</span>")
            main_box.pack_start(header, False, False, 10)
            
            status_frame = Gtk.Frame(label="Current Status")
            status_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
            status_box.set_margin_start(10)
            status_box.set_margin_end(10)
            status_box.set_margin_top(10)
            status_box.set_margin_bottom(10)
            status_frame.add(status_box)
            main_box.pack_start(status_frame, False, False, 0)
            
            self.tier_label = Gtk.Label()
            self.tier_label.set_halign(Gtk.Align.START)
            status_box.pack_start(self.tier_label, False, False, 0)
            
            self.license_label = Gtk.Label()
            self.license_label.set_halign(Gtk.Align.START)
            status_box.pack_start(self.license_label, False, False, 0)
            
            self.expiry_label = Gtk.Label()
            self.expiry_label.set_halign(Gtk.Align.START)
            status_box.pack_start(self.expiry_label, False, False, 0)
            
            activate_frame = Gtk.Frame(label="Activate License")
            activate_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            activate_box.set_margin_start(10)
            activate_box.set_margin_end(10)
            activate_box.set_margin_top(10)
            activate_box.set_margin_bottom(10)
            activate_frame.add(activate_box)
            main_box.pack_start(activate_frame, False, False, 0)
            
            key_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            activate_box.pack_start(key_box, False, False, 0)
            
            key_label = Gtk.Label(label="License Key:")
            key_box.pack_start(key_label, False, False, 0)
            
            self.key_entry = Gtk.Entry()
            self.key_entry.set_placeholder_text("AEGIS-XXX-XXXXX-XXXXX-XXXXX")
            self.key_entry.set_hexpand(True)
            key_box.pack_start(self.key_entry, True, True, 0)
            
            button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            activate_box.pack_start(button_box, False, False, 0)
            
            activate_btn = Gtk.Button(label="Activate")
            activate_btn.connect("clicked", self.on_activate)
            activate_btn.get_style_context().add_class("suggested-action")
            button_box.pack_start(activate_btn, True, True, 0)
            
            validate_btn = Gtk.Button(label="Validate")
            validate_btn.connect("clicked", self.on_validate)
            button_box.pack_start(validate_btn, True, True, 0)
            
            deactivate_btn = Gtk.Button(label="Deactivate")
            deactivate_btn.connect("clicked", self.on_deactivate)
            deactivate_btn.get_style_context().add_class("destructive-action")
            button_box.pack_start(deactivate_btn, True, True, 0)
            
            self.message_label = Gtk.Label()
            self.message_label.set_line_wrap(True)
            main_box.pack_start(self.message_label, False, False, 0)
            
            features_frame = Gtk.Frame(label="Features")
            self.features_text = Gtk.TextView()
            self.features_text.set_editable(False)
            self.features_text.set_wrap_mode(Gtk.WrapMode.WORD)
            scroll = Gtk.ScrolledWindow()
            scroll.set_min_content_height(100)
            scroll.add(self.features_text)
            features_frame.add(scroll)
            main_box.pack_start(features_frame, True, True, 0)
            
            self.refresh_status()
        
        def refresh_status(self):
            status = get_license_status()
            
            self.tier_label.set_markup(f"<b>Tier:</b> {status['tier_name']}")
            
            if status['license_key']:
                self.license_label.set_markup(f"<b>License:</b> {status['license_key']}")
            else:
                self.license_label.set_markup("<b>License:</b> Not activated")
            
            if status['expires_at']:
                self.expiry_label.set_markup(f"<b>Expires:</b> {status['expires_at']}")
            elif status['license_type'] == 'lifetime':
                self.expiry_label.set_markup("<b>Type:</b> Lifetime")
            else:
                self.expiry_label.set_markup("")
            
            features_buffer = self.features_text.get_buffer()
            features_text = "Enabled Features:\n"
            for feature, enabled in sorted(status.get('features', {}).items()):
                if enabled:
                    features_text += f"  ✓ {feature}\n"
            
            if status.get('disabled_features'):
                features_text += "\nDisabled Features:\n"
                for feature in sorted(status['disabled_features']):
                    features_text += f"  ✗ {feature}\n"
            
            features_buffer.set_text(features_text)
        
        def on_activate(self, button):
            key = self.key_entry.get_text().strip()
            if not key:
                self.show_message("Please enter a license key", error=True)
                return
            
            success, message = activate_license(key)
            self.show_message(message, error=not success)
            if success:
                self.key_entry.set_text("")
            self.refresh_status()
        
        def on_validate(self, button):
            stored = load_license()
            if stored.get('license_key'):
                valid, result = validate_license(stored['license_key'])
                if valid:
                    self.show_message(f"License valid: {TIER_NAMES.get(result['tier'], result['tier'])}")
                else:
                    self.show_message(f"Validation failed: {result.get('error', 'Unknown')}", error=True)
            else:
                self.show_message("No license to validate", error=True)
            self.refresh_status()
        
        def on_deactivate(self, button):
            dialog = Gtk.MessageDialog(
                transient_for=self,
                flags=0,
                message_type=Gtk.MessageType.WARNING,
                buttons=Gtk.ButtonsType.YES_NO,
                text="Deactivate License?"
            )
            dialog.format_secondary_text(
                "This will remove your license and revert to Freemium tier."
            )
            response = dialog.run()
            dialog.destroy()
            
            if response == Gtk.ResponseType.YES:
                if LICENSE_FILE.exists():
                    LICENSE_FILE.unlink()
                update_tier('freemium')
                self.show_message("License deactivated")
                self.refresh_status()
        
        def show_message(self, message, error=False):
            if error:
                self.message_label.set_markup(f"<span color='red'>{message}</span>")
            else:
                self.message_label.set_markup(f"<span color='green'>{message}</span>")
    
    win = LicenseManagerWindow()
    win.connect("destroy", Gtk.main_quit)
    win.show_all()
    Gtk.main()


if __name__ == '__main__':
    if os.geteuid() != 0 and not any(arg in sys.argv for arg in ['--status', '-s', '--gui', '-g', '--help', '-h']):
        if '--validate-boot' in sys.argv or '--apply-tier' in sys.argv or '--activate' in sys.argv:
            print("This operation requires root privileges. Please run with sudo.")
            sys.exit(1)
    
    run_cli()
