#!/usr/bin/env python3
"""
Aegis Desktop Link v2.0.0
Advanced Multi-device KVM Control - Share mouse/keyboard across computers
A Barrier/DeskFlow/Synergy alternative with enhanced features

Features:
  - Auto-discovery via Avahi/mDNS with latency monitoring
  - Seamless mouse transition between screens
  - Keyboard shortcuts for cursor lock/switch
  - Full clipboard sync (text, images, files)
  - Drag-and-drop file transfer between PCs
  - Screen edge configuration for multi-PC setups
  - Multi-monitor support with virtual positioning
  - TLS encrypted connections with PIN pairing
  - Trusted device management
  - Gaming mode with ultra-low latency (<1ms)
  - Auto-reconnect on network issues
  - System tray status indicator
  - Aegis Home NAS and Mobile Link integration

Copyright (c) 2024 Aegis OS Team
License: GPL-3.0
"""

import os
import sys
import json
import subprocess
import argparse
import socket
import threading
import time
import hashlib
import ssl
import struct
import random
import base64
import shutil
import signal
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any, Callable
from dataclasses import dataclass, field, asdict
from enum import Enum
from contextlib import contextmanager

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, simpledialog, filedialog
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

VERSION = "2.0.0"
APP_NAME = "Aegis Desktop Link"
CONFIG_DIR = Path.home() / ".config" / "aegis" / "desktop-link"
CONFIG_FILE = CONFIG_DIR / "config.json"
PEERS_FILE = CONFIG_DIR / "peers.json"
TRUSTED_FILE = CONFIG_DIR / "trusted.json"
CERTS_DIR = CONFIG_DIR / "certs"
TRANSFER_DIR = Path.home() / "Desktop Link Transfers"
LOG_FILE = Path("/var/log/aegis/desktop-link.log")
TIER_FILE = Path("/etc/aegis/tier")

DEFAULT_PORT = 24800
DISCOVERY_PORT = 24801
MDNS_PORT = 5353
FILE_TRANSFER_PORT = 24802
CLIPBOARD_PORT = 24803

AVAHI_SERVICE_TYPE = "_aegis-desklink._tcp"
HEARTBEAT_INTERVAL = 5
RECONNECT_DELAY = 3
MAX_RECONNECT_ATTEMPTS = 10

BARRIER_CONFIG_DIR = Path.home() / ".local" / "share" / "barrier"
BARRIER_CONFIG_FILE = BARRIER_CONFIG_DIR / "barrier.conf"
BARRIER_SSL_DIR = BARRIER_CONFIG_DIR / "SSL"
INPUT_LEAP_CONFIG_DIR = Path.home() / ".local" / "share" / "input-leap"
INPUT_LEAP_CONFIG_FILE = INPUT_LEAP_CONFIG_DIR / "InputLeap.conf"


class DeviceRole(Enum):
    SERVER = "server"
    CLIENT = "client"


class EdgePosition(Enum):
    LEFT = "left"
    RIGHT = "right"
    TOP = "top"
    BOTTOM = "bottom"
    NONE = "none"


class ConnectionStatus(Enum):
    CONNECTED = "connected"
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    ERROR = "error"
    PAIRED = "paired"
    UNTRUSTED = "untrusted"


class GamingMode(Enum):
    OFF = "off"
    LOW_LATENCY = "low_latency"
    ULTRA_LOW = "ultra_low"
    DISABLED = "disabled"


@dataclass
class MonitorInfo:
    """Monitor configuration"""
    id: str
    name: str
    width: int = 1920
    height: int = 1080
    x_offset: int = 0
    y_offset: int = 0
    primary: bool = False
    shared: bool = True


@dataclass
class EdgeConfig:
    """Screen edge connection configuration"""
    left_device: str = ""
    right_device: str = ""
    top_device: str = ""
    bottom_device: str = ""
    switch_delay_ms: int = 100
    corner_size: int = 0


@dataclass
class PeerDevice:
    """Represents a connected peer device"""
    id: str
    name: str
    hostname: str
    ip_address: str
    port: int = DEFAULT_PORT
    edge_position: str = "right"
    enabled: bool = True
    trusted: bool = False
    last_seen: str = ""
    os_type: str = "linux"
    screens: List[Dict] = field(default_factory=list)
    status: str = "disconnected"
    latency_ms: float = -1
    pairing_pin: str = ""
    public_key: str = ""
    aegis_version: str = ""
    capabilities: List[str] = field(default_factory=list)


@dataclass
class ClipboardData:
    """Clipboard content"""
    content_type: str = "text"
    data: str = ""
    timestamp: str = ""
    source_device: str = ""
    size_bytes: int = 0


@dataclass
class FileTransfer:
    """File transfer state"""
    id: str
    filename: str
    source_device: str
    target_device: str
    size_bytes: int
    transferred_bytes: int = 0
    status: str = "pending"
    started: str = ""
    completed: str = ""
    error: str = ""


@dataclass
class DesktopLinkConfig:
    """Main configuration"""
    device_name: str = ""
    device_id: str = ""
    role: str = "server"
    listen_port: int = DEFAULT_PORT
    encryption_enabled: bool = True
    tls_cert_file: str = ""
    tls_key_file: str = ""
    clipboard_sharing: bool = True
    clipboard_text: bool = True
    clipboard_images: bool = True
    clipboard_files: bool = True
    file_sharing: bool = True
    auto_discovery: bool = True
    avahi_enabled: bool = True
    lock_sync: bool = True
    auto_lock_on_disconnect: bool = False
    hotkey_switch: str = "Ctrl+Alt+Arrow"
    hotkey_lock_cursor: str = "Ctrl+Alt+L"
    hotkey_gaming_toggle: str = "Ctrl+Alt+G"
    cursor_wrap: bool = False
    switch_delay_ms: int = 100
    corner_switch: bool = True
    corner_size: int = 5
    gaming_mode: str = "off"
    gaming_low_latency_ms: int = 1
    raw_input_passthrough: bool = False
    auto_reconnect: bool = True
    reconnect_attempts: int = MAX_RECONNECT_ATTEMPTS
    show_tray_icon: bool = True
    nas_integration: bool = True
    mobile_integration: bool = True
    edge_config: Dict = field(default_factory=dict)
    monitors: List[Dict] = field(default_factory=list)


class CertificateManager:
    """Manages TLS certificates for secure connections"""
    
    def __init__(self):
        CERTS_DIR.mkdir(parents=True, exist_ok=True)
        self.cert_file = CERTS_DIR / "desktop-link.crt"
        self.key_file = CERTS_DIR / "desktop-link.key"
    
    def generate_self_signed_cert(self) -> Tuple[str, str]:
        """Generate a self-signed certificate"""
        if self.cert_file.exists() and self.key_file.exists():
            return str(self.cert_file), str(self.key_file)
        
        try:
            subprocess.run([
                'openssl', 'req', '-x509', '-newkey', 'rsa:4096',
                '-keyout', str(self.key_file),
                '-out', str(self.cert_file),
                '-days', '365', '-nodes',
                '-subj', f'/CN={socket.gethostname()}/O=AegisDesktopLink'
            ], capture_output=True, check=True)
            
            os.chmod(self.key_file, 0o600)
            return str(self.cert_file), str(self.key_file)
        except Exception:
            return "", ""
    
    def get_ssl_context(self, server: bool = False) -> Optional[ssl.SSLContext]:
        """Get SSL context for secure connections"""
        try:
            if server:
                context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
                cert, key = self.generate_self_signed_cert()
                if cert and key:
                    context.load_cert_chain(cert, key)
            else:
                context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
            return context
        except Exception:
            return None
    
    def get_fingerprint(self) -> str:
        """Get certificate fingerprint for verification"""
        if not self.cert_file.exists():
            return ""
        try:
            result = subprocess.run([
                'openssl', 'x509', '-fingerprint', '-sha256',
                '-in', str(self.cert_file), '-noout'
            ], capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.split('=')[1].strip()
        except Exception:
            pass
        return ""


class AvahiDiscovery:
    """Avahi/mDNS-based device discovery"""
    
    def __init__(self, device_id: str, device_name: str, port: int):
        self.device_id = device_id
        self.device_name = device_name
        self.port = port
        self.running = False
        self.discovered_devices: Dict[str, Dict] = {}
        self.discovery_thread = None
        self.announce_thread = None
    
    def start(self):
        """Start discovery services"""
        self.running = True
        self.discovery_thread = threading.Thread(target=self._discovery_loop, daemon=True)
        self.discovery_thread.start()
        self.announce_thread = threading.Thread(target=self._announce_loop, daemon=True)
        self.announce_thread.start()
        self._register_avahi_service()
    
    def stop(self):
        """Stop discovery services"""
        self.running = False
        self._unregister_avahi_service()
    
    def _register_avahi_service(self):
        """Register service with Avahi"""
        try:
            service_file = Path("/etc/avahi/services/aegis-desklink.service")
            service_content = f"""<?xml version="1.0" standalone='no'?>
<!DOCTYPE service-group SYSTEM "avahi-service.dtd">
<service-group>
  <name>{self.device_name}</name>
  <service>
    <type>_aegis-desklink._tcp</type>
    <port>{self.port}</port>
    <txt-record>id={self.device_id}</txt-record>
    <txt-record>version={VERSION}</txt-record>
  </service>
</service-group>
"""
            try:
                with open(service_file, 'w') as f:
                    f.write(service_content)
            except PermissionError:
                pass
        except Exception:
            pass
    
    def _unregister_avahi_service(self):
        """Remove Avahi service registration"""
        try:
            service_file = Path("/etc/avahi/services/aegis-desklink.service")
            if service_file.exists():
                service_file.unlink()
        except Exception:
            pass
    
    def _discovery_loop(self):
        """Main discovery loop using avahi-browse"""
        while self.running:
            try:
                result = subprocess.run([
                    'avahi-browse', '-ptr', '_aegis-desklink._tcp'
                ], capture_output=True, text=True, timeout=5)
                
                if result.returncode == 0:
                    self._parse_avahi_output(result.stdout)
            except Exception:
                pass
            
            time.sleep(HEARTBEAT_INTERVAL)
    
    def _announce_loop(self):
        """Broadcast presence on UDP"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        sock.settimeout(1.0)
        
        while self.running:
            try:
                message = json.dumps({
                    "type": "announce",
                    "device_id": self.device_id,
                    "device_name": self.device_name,
                    "port": self.port,
                    "version": VERSION,
                    "timestamp": time.time()
                }).encode()
                
                sock.sendto(message, ('<broadcast>', DISCOVERY_PORT))
            except Exception:
                pass
            
            time.sleep(HEARTBEAT_INTERVAL)
        
        sock.close()
    
    def _parse_avahi_output(self, output: str):
        """Parse avahi-browse output"""
        for line in output.strip().split('\n'):
            if not line or line.startswith('+'):
                continue
            
            parts = line.split(';')
            if len(parts) >= 8:
                try:
                    device_info = {
                        "interface": parts[0],
                        "protocol": parts[1],
                        "name": parts[3],
                        "type": parts[4],
                        "domain": parts[5],
                        "hostname": parts[6],
                        "ip_address": parts[7],
                        "port": int(parts[8]) if len(parts) > 8 else DEFAULT_PORT,
                        "last_seen": datetime.now().isoformat()
                    }
                    
                    if device_info.get("ip_address"):
                        self.discovered_devices[device_info["ip_address"]] = device_info
                except Exception:
                    pass
    
    def get_discovered_devices(self) -> List[Dict]:
        """Get list of discovered devices"""
        return list(self.discovered_devices.values())
    
    def measure_latency(self, ip_address: str) -> float:
        """Measure latency to a device"""
        try:
            start = time.time()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2.0)
            result = sock.connect_ex((ip_address, DEFAULT_PORT))
            sock.close()
            if result == 0:
                return (time.time() - start) * 1000
        except Exception:
            pass
        return -1


class ClipboardManager:
    """Cross-device clipboard synchronization with X11 and Wayland support"""
    
    def __init__(self, enabled: bool = True):
        self.enabled = enabled
        self.last_content: Optional[ClipboardData] = None
        self.callbacks: List[Callable] = []
        self.running = False
        self.monitor_thread = None
        self.display_server = self._detect_display_server()
        self.clipboard_tools = self._detect_clipboard_tools()
    
    def _detect_display_server(self) -> str:
        """Detect whether running on X11 or Wayland"""
        wayland_display = os.environ.get('WAYLAND_DISPLAY', '')
        xdg_session = os.environ.get('XDG_SESSION_TYPE', '')
        
        if wayland_display or xdg_session == 'wayland':
            return 'wayland'
        return 'x11'
    
    def _detect_clipboard_tools(self) -> Dict[str, str]:
        """Detect available clipboard tools"""
        tools = {'read': None, 'write': None}
        
        if self.display_server == 'wayland':
            if shutil.which('wl-paste'):
                tools['read'] = 'wl-paste'
            if shutil.which('wl-copy'):
                tools['write'] = 'wl-copy'
        
        if not tools['read']:
            if shutil.which('xclip'):
                tools['read'] = 'xclip'
                tools['write'] = 'xclip'
            elif shutil.which('xsel'):
                tools['read'] = 'xsel'
                tools['write'] = 'xsel'
        
        return tools
    
    def start(self):
        """Start clipboard monitoring"""
        if not self.enabled:
            return
        
        if not self.clipboard_tools['read']:
            return
        
        self.running = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
    
    def stop(self):
        """Stop clipboard monitoring"""
        self.running = False
    
    def _monitor_loop(self):
        """Monitor clipboard for changes"""
        while self.running:
            try:
                current = self._get_clipboard_content()
                if current and (not self.last_content or 
                               current.data != self.last_content.data):
                    self.last_content = current
                    for callback in self.callbacks:
                        try:
                            callback(current)
                        except Exception:
                            pass
            except Exception:
                pass
            
            time.sleep(0.5)
    
    def _get_clipboard_content(self) -> Optional[ClipboardData]:
        """Get current clipboard content with X11/Wayland support"""
        try:
            tool = self.clipboard_tools.get('read')
            if not tool:
                return None
            
            if tool == 'wl-paste':
                cmd = ['wl-paste', '--no-newline']
            elif tool == 'xclip':
                cmd = ['xclip', '-selection', 'clipboard', '-o']
            elif tool == 'xsel':
                cmd = ['xsel', '--clipboard', '--output']
            else:
                return None
            
            result = subprocess.run(cmd, capture_output=True, timeout=2)
            if result.returncode == 0:
                content = result.stdout
                try:
                    content.decode('utf-8')
                    content_type = "text"
                except UnicodeDecodeError:
                    content_type = "binary"
                
                return ClipboardData(
                    content_type=content_type,
                    data=base64.b64encode(content).decode(),
                    timestamp=datetime.now().isoformat(),
                    size_bytes=len(content)
                )
        except subprocess.TimeoutExpired:
            pass
        except Exception:
            pass
        return None
    
    def set_clipboard(self, data: ClipboardData) -> bool:
        """Set clipboard content with X11/Wayland support"""
        try:
            tool = self.clipboard_tools.get('write')
            if not tool:
                return False
            
            content = base64.b64decode(data.data)
            
            if tool == 'wl-copy':
                cmd = ['wl-copy']
            elif tool == 'xclip':
                cmd = ['xclip', '-selection', 'clipboard']
            elif tool == 'xsel':
                cmd = ['xsel', '--clipboard', '--input']
            else:
                return False
            
            process = subprocess.Popen(cmd, stdin=subprocess.PIPE)
            process.communicate(input=content, timeout=2)
            self.last_content = data
            return process.returncode == 0
        except subprocess.TimeoutExpired:
            return False
        except Exception:
            return False
    
    def get_clipboard_image(self) -> Optional[bytes]:
        """Get image from clipboard (PNG format)"""
        try:
            if self.display_server == 'wayland' and shutil.which('wl-paste'):
                result = subprocess.run(
                    ['wl-paste', '--type', 'image/png'],
                    capture_output=True, timeout=2
                )
            elif shutil.which('xclip'):
                result = subprocess.run(
                    ['xclip', '-selection', 'clipboard', '-t', 'image/png', '-o'],
                    capture_output=True, timeout=2
                )
            else:
                return None
            
            if result.returncode == 0 and result.stdout:
                return result.stdout
        except Exception:
            pass
        return None
    
    def set_clipboard_image(self, image_data: bytes) -> bool:
        """Set image to clipboard"""
        try:
            if self.display_server == 'wayland' and shutil.which('wl-copy'):
                process = subprocess.Popen(
                    ['wl-copy', '--type', 'image/png'],
                    stdin=subprocess.PIPE
                )
            elif shutil.which('xclip'):
                process = subprocess.Popen(
                    ['xclip', '-selection', 'clipboard', '-t', 'image/png'],
                    stdin=subprocess.PIPE
                )
            else:
                return False
            
            process.communicate(input=image_data, timeout=2)
            return process.returncode == 0
        except Exception:
            return False
    
    def on_change(self, callback: Callable):
        """Register clipboard change callback"""
        self.callbacks.append(callback)
    
    def get_available_tools(self) -> Dict[str, Any]:
        """Get info about available clipboard tools"""
        return {
            "display_server": self.display_server,
            "read_tool": self.clipboard_tools.get('read'),
            "write_tool": self.clipboard_tools.get('write'),
            "available": bool(self.clipboard_tools.get('read'))
        }


class FileTransferManager:
    """Drag-and-drop file transfer between devices"""
    
    def __init__(self):
        TRANSFER_DIR.mkdir(parents=True, exist_ok=True)
        self.active_transfers: Dict[str, FileTransfer] = {}
        self.server_socket = None
        self.running = False
    
    def start_server(self, port: int = FILE_TRANSFER_PORT):
        """Start file transfer server"""
        self.running = True
        thread = threading.Thread(target=self._server_loop, args=(port,), daemon=True)
        thread.start()
    
    def stop(self):
        """Stop file transfer server"""
        self.running = False
        if self.server_socket:
            self.server_socket.close()
    
    def _server_loop(self, port: int):
        """File transfer server loop"""
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind(('0.0.0.0', port))
            self.server_socket.listen(5)
            self.server_socket.settimeout(1.0)
            
            while self.running:
                try:
                    client, addr = self.server_socket.accept()
                    thread = threading.Thread(
                        target=self._handle_transfer, 
                        args=(client, addr), 
                        daemon=True
                    )
                    thread.start()
                except socket.timeout:
                    continue
        except Exception:
            pass
    
    def _handle_transfer(self, client: socket.socket, addr: Tuple):
        """Handle incoming file transfer"""
        try:
            header = client.recv(4096).decode()
            meta = json.loads(header)
            
            transfer_id = meta.get("id", hashlib.sha256(str(time.time()).encode()).hexdigest()[:16])
            filename = meta.get("filename", "unknown")
            size = meta.get("size", 0)
            
            safe_filename = "".join(c for c in filename if c.isalnum() or c in "._-")
            target_path = TRANSFER_DIR / safe_filename
            
            transfer = FileTransfer(
                id=transfer_id,
                filename=filename,
                source_device=addr[0],
                target_device=socket.gethostname(),
                size_bytes=size,
                started=datetime.now().isoformat(),
                status="receiving"
            )
            self.active_transfers[transfer_id] = transfer
            
            client.send(b"READY")
            
            with open(target_path, 'wb') as f:
                received = 0
                while received < size:
                    chunk = client.recv(8192)
                    if not chunk:
                        break
                    f.write(chunk)
                    received += len(chunk)
                    transfer.transferred_bytes = received
            
            transfer.status = "completed"
            transfer.completed = datetime.now().isoformat()
            
            client.send(b"DONE")
        except Exception as e:
            if transfer_id in self.active_transfers:
                self.active_transfers[transfer_id].status = "error"
                self.active_transfers[transfer_id].error = str(e)
        finally:
            client.close()
    
    def send_file(self, filepath: str, target_ip: str, port: int = FILE_TRANSFER_PORT) -> bool:
        """Send file to another device"""
        try:
            path = Path(filepath)
            if not path.exists():
                return False
            
            transfer_id = hashlib.sha256(f"{filepath}{time.time()}".encode()).hexdigest()[:16]
            size = path.stat().st_size
            
            transfer = FileTransfer(
                id=transfer_id,
                filename=path.name,
                source_device=socket.gethostname(),
                target_device=target_ip,
                size_bytes=size,
                started=datetime.now().isoformat(),
                status="sending"
            )
            self.active_transfers[transfer_id] = transfer
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((target_ip, port))
            
            meta = json.dumps({
                "id": transfer_id,
                "filename": path.name,
                "size": size
            })
            sock.send(meta.encode())
            
            response = sock.recv(16)
            if response != b"READY":
                return False
            
            with open(path, 'rb') as f:
                sent = 0
                while sent < size:
                    chunk = f.read(8192)
                    if not chunk:
                        break
                    sock.send(chunk)
                    sent += len(chunk)
                    transfer.transferred_bytes = sent
            
            response = sock.recv(16)
            sock.close()
            
            transfer.status = "completed"
            transfer.completed = datetime.now().isoformat()
            return response == b"DONE"
        except Exception as e:
            if transfer_id in self.active_transfers:
                self.active_transfers[transfer_id].status = "error"
                self.active_transfers[transfer_id].error = str(e)
            return False


class GamingModeManager:
    """Gaming mode with ultra-low latency"""
    
    def __init__(self):
        self.mode = GamingMode.OFF
        self.original_settings = {}
    
    def enable(self, mode: GamingMode = GamingMode.LOW_LATENCY) -> bool:
        """Enable gaming mode"""
        if self.mode != GamingMode.OFF:
            return True
        
        self._save_original_settings()
        self.mode = mode
        
        try:
            if mode == GamingMode.ULTRA_LOW:
                subprocess.run(['renice', '-n', '-15', '-p', str(os.getpid())], 
                             capture_output=True)
                
                subprocess.run(['ionice', '-c', '1', '-n', '0', '-p', str(os.getpid())], 
                             capture_output=True)
            
            elif mode == GamingMode.LOW_LATENCY:
                subprocess.run(['renice', '-n', '-10', '-p', str(os.getpid())], 
                             capture_output=True)
            
            return True
        except Exception:
            return False
    
    def disable(self) -> bool:
        """Disable gaming mode"""
        if self.mode == GamingMode.OFF:
            return True
        
        try:
            subprocess.run(['renice', '-n', '0', '-p', str(os.getpid())], 
                         capture_output=True)
            
            self._restore_original_settings()
            self.mode = GamingMode.OFF
            return True
        except Exception:
            return False
    
    def toggle(self) -> GamingMode:
        """Toggle gaming mode"""
        if self.mode == GamingMode.OFF:
            self.enable(GamingMode.LOW_LATENCY)
        else:
            self.disable()
        return self.mode
    
    def _save_original_settings(self):
        """Save original system settings"""
        try:
            result = subprocess.run(['ps', '-o', 'nice', '-p', str(os.getpid())],
                                   capture_output=True, text=True)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                if len(lines) > 1:
                    self.original_settings['nice'] = int(lines[1].strip())
        except Exception:
            pass
    
    def _restore_original_settings(self):
        """Restore original system settings"""
        if 'nice' in self.original_settings:
            try:
                subprocess.run([
                    'renice', '-n', str(self.original_settings['nice']),
                    '-p', str(os.getpid())
                ], capture_output=True)
            except Exception:
                pass


class DesktopLinkService:
    """Core Desktop Link service"""
    
    def __init__(self):
        self.config = self._load_config()
        self.peers: Dict[str, PeerDevice] = {}
        self.trusted_devices: Dict[str, Dict] = {}
        self.running = False
        self.server_socket = None
        self.tier = self._get_tier()
        
        self.cert_manager = CertificateManager()
        self.discovery = None
        self.clipboard = None
        self.file_transfer = None
        self.gaming_mode = GamingModeManager()
        
        self._load_peers()
        self._load_trusted()
        
        self.connection_threads: Dict[str, threading.Thread] = {}
        self.reconnect_counts: Dict[str, int] = {}
        
        self.barrier_server_process: Optional[subprocess.Popen] = None
        self.barrier_client_process: Optional[subprocess.Popen] = None
        self.barrier_backend: str = "none"
    
    def _get_tier(self) -> str:
        """Get current license tier"""
        if TIER_FILE.exists():
            try:
                return TIER_FILE.read_text().strip()
            except Exception:
                pass
        return "pro"
    
    def _load_config(self) -> DesktopLinkConfig:
        """Load configuration"""
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE, 'r') as f:
                    data = json.load(f)
                    config = DesktopLinkConfig()
                    for k, v in data.items():
                        if hasattr(config, k):
                            setattr(config, k, v)
                    return config
            except Exception:
                pass
        
        config = DesktopLinkConfig()
        config.device_name = socket.gethostname()
        config.device_id = hashlib.sha256(
            f"{config.device_name}-{time.time()}".encode()
        ).hexdigest()[:16]
        config.monitors = self._detect_monitors()
        self._save_config(config)
        return config
    
    def _save_config(self, config: Optional[DesktopLinkConfig] = None):
        """Save configuration"""
        if config is None:
            config = self.config
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        with open(CONFIG_FILE, 'w') as f:
            json.dump(asdict(config), f, indent=2)
    
    def _load_peers(self):
        """Load saved peers"""
        if PEERS_FILE.exists():
            try:
                with open(PEERS_FILE, 'r') as f:
                    data = json.load(f)
                    for peer_id, peer_data in data.items():
                        self.peers[peer_id] = PeerDevice(**peer_data)
            except Exception:
                pass
    
    def _save_peers(self):
        """Save peers"""
        with open(PEERS_FILE, 'w') as f:
            json.dump({k: asdict(v) for k, v in self.peers.items()}, f, indent=2)
    
    def _load_trusted(self):
        """Load trusted devices"""
        if TRUSTED_FILE.exists():
            try:
                with open(TRUSTED_FILE, 'r') as f:
                    self.trusted_devices = json.load(f)
            except Exception:
                pass
    
    def _save_trusted(self):
        """Save trusted devices"""
        with open(TRUSTED_FILE, 'w') as f:
            json.dump(self.trusted_devices, f, indent=2)
    
    def _detect_monitors(self) -> List[Dict]:
        """Detect connected monitors"""
        monitors = []
        try:
            result = subprocess.run(
                ['xrandr', '--query'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if ' connected' in line:
                        parts = line.split()
                        name = parts[0]
                        primary = 'primary' in line
                        
                        for part in parts:
                            if 'x' in part and '+' in part:
                                res_pos = part.split('+')
                                res = res_pos[0].split('x')
                                if len(res) == 2 and len(res_pos) >= 3:
                                    monitors.append({
                                        "id": name,
                                        "name": name,
                                        "width": int(res[0]),
                                        "height": int(res[1]),
                                        "x_offset": int(res_pos[1]),
                                        "y_offset": int(res_pos[2]),
                                        "primary": primary,
                                        "shared": True
                                    })
                                break
        except Exception:
            pass
        
        if not monitors:
            monitors.append({
                "id": "default",
                "name": "Primary Display",
                "width": 1920,
                "height": 1080,
                "x_offset": 0,
                "y_offset": 0,
                "primary": True,
                "shared": True
            })
        
        return monitors
    
    def generate_pairing_pin(self) -> str:
        """Generate a 6-digit pairing PIN"""
        return f"{random.randint(100000, 999999)}"
    
    def verify_pairing_pin(self, peer_id: str, pin: str) -> bool:
        """Verify pairing PIN"""
        if peer_id in self.peers:
            return self.peers[peer_id].pairing_pin == pin
        return False
    
    def trust_device(self, peer_id: str) -> bool:
        """Add device to trusted list"""
        if peer_id in self.peers:
            peer = self.peers[peer_id]
            peer.trusted = True
            self.trusted_devices[peer_id] = {
                "name": peer.name,
                "hostname": peer.hostname,
                "ip_address": peer.ip_address,
                "fingerprint": self.cert_manager.get_fingerprint(),
                "trusted_at": datetime.now().isoformat()
            }
            self._save_peers()
            self._save_trusted()
            return True
        return False
    
    def untrust_device(self, peer_id: str) -> bool:
        """Remove device from trusted list"""
        if peer_id in self.trusted_devices:
            del self.trusted_devices[peer_id]
            if peer_id in self.peers:
                self.peers[peer_id].trusted = False
            self._save_peers()
            self._save_trusted()
            return True
        return False
    
    def add_peer(self, hostname: str, ip_address: str, edge: str = "right", 
                 trust: bool = False) -> PeerDevice:
        """Add a new peer device"""
        peer_id = hashlib.sha256(f"{hostname}-{ip_address}".encode()).hexdigest()[:16]
        
        existing = self.peers.get(peer_id)
        peer = PeerDevice(
            id=peer_id,
            name=hostname,
            hostname=hostname,
            ip_address=ip_address,
            edge_position=edge,
            trusted=trust or (existing.trusted if existing else False),
            last_seen=datetime.now().isoformat(),
            capabilities=["clipboard", "file_transfer", "screen_share"]
        )
        
        latency = self._measure_latency(ip_address)
        peer.latency_ms = latency
        peer.status = "connected" if latency > 0 else "disconnected"
        
        self.peers[peer_id] = peer
        self._save_peers()
        
        if trust:
            self.trust_device(peer_id)
        
        return peer
    
    def remove_peer(self, peer_id: str) -> bool:
        """Remove a peer"""
        if peer_id in self.peers:
            del self.peers[peer_id]
            self._save_peers()
            if peer_id in self.trusted_devices:
                del self.trusted_devices[peer_id]
                self._save_trusted()
            return True
        return False
    
    def update_peer_edge(self, peer_id: str, edge: str) -> bool:
        """Update peer edge position"""
        if peer_id in self.peers:
            self.peers[peer_id].edge_position = edge
            self._save_peers()
            return True
        return False
    
    def _measure_latency(self, ip_address: str) -> float:
        """Measure latency to peer"""
        try:
            start = time.time()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2.0)
            result = sock.connect_ex((ip_address, DEFAULT_PORT))
            sock.close()
            if result == 0:
                return round((time.time() - start) * 1000, 2)
        except Exception:
            pass
        return -1
    
    def discover_peers(self) -> List[Dict]:
        """Discover peers on local network"""
        discovered = []
        
        if self.discovery:
            discovered.extend(self.discovery.get_discovered_devices())
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
            sock.settimeout(3.0)
            
            message = json.dumps({
                "type": "discover",
                "device_id": self.config.device_id,
                "device_name": self.config.device_name,
                "port": self.config.listen_port,
                "version": VERSION
            }).encode()
            
            sock.sendto(message, ('<broadcast>', DISCOVERY_PORT))
            
            start = time.time()
            while time.time() - start < 3.0:
                try:
                    data, addr = sock.recvfrom(4096)
                    response = json.loads(data.decode())
                    if (response.get("type") in ["announce", "discover_response"] and 
                        response.get("device_id") != self.config.device_id):
                        
                        device_info = {
                            "device_id": response.get("device_id"),
                            "device_name": response.get("device_name"),
                            "ip_address": addr[0],
                            "port": response.get("port", DEFAULT_PORT),
                            "version": response.get("version", "unknown"),
                            "latency_ms": self._measure_latency(addr[0])
                        }
                        
                        if not any(d.get("ip_address") == addr[0] for d in discovered):
                            discovered.append(device_info)
                except socket.timeout:
                    break
                except Exception:
                    continue
        except Exception:
            pass
        finally:
            try:
                sock.close()
            except:
                pass
        
        return discovered
    
    def refresh_peer_status(self):
        """Refresh status of all peers"""
        for peer_id, peer in self.peers.items():
            latency = self._measure_latency(peer.ip_address)
            peer.latency_ms = latency
            peer.status = "connected" if latency > 0 else "disconnected"
            peer.last_seen = datetime.now().isoformat() if latency > 0 else peer.last_seen
        self._save_peers()
    
    def get_status(self) -> Dict:
        """Get current status"""
        connected_count = sum(1 for p in self.peers.values() if p.status == "connected")
        trusted_count = len(self.trusted_devices)
        
        barrier_server_running = (self.barrier_server_process is not None and 
                                  self.barrier_server_process.poll() is None)
        barrier_client_running = (self.barrier_client_process is not None and 
                                  self.barrier_client_process.poll() is None)
        
        server_bin, client_bin, backend = self._detect_barrier_binary()
        
        return {
            "version": VERSION,
            "tier": self.tier,
            "running": self.running,
            "role": self.config.role,
            "device_name": self.config.device_name,
            "device_id": self.config.device_id,
            "listen_port": self.config.listen_port,
            "encryption": self.config.encryption_enabled,
            "clipboard_sharing": self.config.clipboard_sharing,
            "file_sharing": self.config.file_sharing,
            "auto_discovery": self.config.auto_discovery,
            "gaming_mode": self.gaming_mode.mode.value,
            "peers_count": len(self.peers),
            "connected_count": connected_count,
            "trusted_count": trusted_count,
            "monitors": self.config.monitors,
            "peers": [asdict(p) for p in self.peers.values()],
            "trusted_devices": list(self.trusted_devices.keys()),
            "barrier": {
                "backend": backend,
                "available": backend != 'none',
                "server_binary": server_bin,
                "client_binary": client_bin,
                "server_running": barrier_server_running,
                "client_running": barrier_client_running,
            },
            "features": {
                "avahi_discovery": self.config.avahi_enabled,
                "tls_encryption": self.config.encryption_enabled,
                "clipboard_sync": self.config.clipboard_sharing,
                "file_transfer": self.config.file_sharing,
                "gaming_mode": True,
                "multi_monitor": True,
                "auto_reconnect": self.config.auto_reconnect,
                "nas_integration": self.config.nas_integration,
                "mobile_integration": self.config.mobile_integration,
                "barrier_integration": backend != 'none'
            }
        }
    
    def start_service(self) -> bool:
        """Start the Desktop Link service"""
        if self.running:
            return True
        
        try:
            if self.config.avahi_enabled:
                self.discovery = AvahiDiscovery(
                    self.config.device_id,
                    self.config.device_name,
                    self.config.listen_port
                )
                self.discovery.start()
            
            if self.config.clipboard_sharing:
                self.clipboard = ClipboardManager(enabled=True)
                self.clipboard.on_change(self._on_clipboard_change)
                self.clipboard.start()
            
            if self.config.file_sharing:
                self.file_transfer = FileTransferManager()
                self.file_transfer.start_server()
            
            server_thread = threading.Thread(target=self._server_loop, daemon=True)
            server_thread.start()
            
            discovery_thread = threading.Thread(target=self._discovery_listener, daemon=True)
            discovery_thread.start()
            
            if self.config.auto_reconnect:
                reconnect_thread = threading.Thread(target=self._reconnect_loop, daemon=True)
                reconnect_thread.start()
            
            self.running = True
            return True
        except Exception:
            return False
    
    def stop_service(self) -> bool:
        """Stop the Desktop Link service"""
        try:
            self.running = False
            
            if self.discovery:
                self.discovery.stop()
            
            if self.clipboard:
                self.clipboard.stop()
            
            if self.file_transfer:
                self.file_transfer.stop()
            
            if self.server_socket:
                self.server_socket.close()
            
            self.stop_barrier_server()
            self.stop_barrier_client()
            
            if self.config.auto_lock_on_disconnect:
                self._lock_screen()
            
            return True
        except Exception:
            return False
    
    def start_barrier_server(self, port: int = 24800, enable_crypto: bool = True) -> Tuple[bool, str]:
        """Start Barrier/Input Leap server mode.
        Returns (success, message)
        """
        if self.barrier_server_process and self.barrier_server_process.poll() is None:
            return (True, "Barrier server already running")
        
        self.stop_barrier_client()
        
        success, process, message = self._start_barrier_server(
            port=port,
            enable_crypto=enable_crypto
        )
        
        if success and process:
            self.barrier_server_process = process
            _, _, self.barrier_backend = self._detect_barrier_binary()
        
        return (success, message)
    
    def stop_barrier_server(self) -> bool:
        """Stop Barrier/Input Leap server."""
        if self.barrier_server_process:
            result = self._stop_barrier_process(self.barrier_server_process)
            self.barrier_server_process = None
            return result
        return True
    
    def start_barrier_client(self, server_address: str, server_port: int = 24800, 
                            enable_crypto: bool = True) -> Tuple[bool, str]:
        """Start Barrier/Input Leap client mode.
        Returns (success, message)
        """
        if self.barrier_client_process and self.barrier_client_process.poll() is None:
            return (True, "Barrier client already running")
        
        self.stop_barrier_server()
        
        success, process, message = self._start_barrier_client(
            server_address=server_address,
            server_port=server_port,
            enable_crypto=enable_crypto
        )
        
        if success and process:
            self.barrier_client_process = process
            _, _, self.barrier_backend = self._detect_barrier_binary()
        
        return (success, message)
    
    def stop_barrier_client(self) -> bool:
        """Stop Barrier/Input Leap client."""
        if self.barrier_client_process:
            result = self._stop_barrier_process(self.barrier_client_process)
            self.barrier_client_process = None
            return result
        return True
    
    def discover_all_peers(self) -> List[Dict]:
        """Discover all peers including Barrier/Input Leap devices."""
        aegis_peers = self.discover_peers()
        barrier_peers = self._discover_barrier_peers()
        
        all_peers = aegis_peers.copy()
        for bp in barrier_peers:
            if not any(p.get("ip_address") == bp.get("ip_address") for p in all_peers):
                all_peers.append(bp)
        
        return all_peers
    
    def _server_loop(self):
        """Main server loop"""
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind(('0.0.0.0', self.config.listen_port))
            self.server_socket.listen(10)
            self.server_socket.settimeout(1.0)
            
            if self.config.encryption_enabled:
                ssl_context = self.cert_manager.get_ssl_context(server=True)
            else:
                ssl_context = None
            
            while self.running:
                try:
                    client, addr = self.server_socket.accept()
                    
                    if ssl_context:
                        try:
                            client = ssl_context.wrap_socket(client, server_side=True)
                        except Exception:
                            client.close()
                            continue
                    
                    thread = threading.Thread(
                        target=self._handle_client,
                        args=(client, addr),
                        daemon=True
                    )
                    thread.start()
                except socket.timeout:
                    continue
                except Exception:
                    if self.running:
                        time.sleep(0.1)
        except Exception:
            pass
    
    def _handle_client(self, client: socket.socket, addr: Tuple):
        """Handle client connection"""
        try:
            client.settimeout(30.0)
            
            while self.running:
                try:
                    data = client.recv(4096)
                    if not data:
                        break
                    
                    message = json.loads(data.decode())
                    response = self._process_message(message, addr[0])
                    client.send(json.dumps(response).encode())
                except socket.timeout:
                    continue
                except Exception:
                    break
        finally:
            client.close()
    
    def _process_message(self, message: Dict, source_ip: str) -> Dict:
        """Process incoming message"""
        msg_type = message.get("type", "")
        
        if msg_type == "handshake":
            return self._handle_handshake(message, source_ip)
        elif msg_type == "pair_request":
            return self._handle_pair_request(message, source_ip)
        elif msg_type == "pair_verify":
            return self._handle_pair_verify(message, source_ip)
        elif msg_type == "clipboard":
            return self._handle_clipboard(message, source_ip)
        elif msg_type == "mouse_move":
            return self._handle_mouse_move(message)
        elif msg_type == "key_event":
            return self._handle_key_event(message)
        elif msg_type == "heartbeat":
            return {"type": "heartbeat_ack", "timestamp": time.time()}
        elif msg_type == "status":
            return {"type": "status_response", "status": self.get_status()}
        else:
            return {"type": "error", "message": "Unknown message type"}
    
    def _handle_handshake(self, message: Dict, source_ip: str) -> Dict:
        """Handle handshake from peer"""
        device_id = message.get("device_id", "")
        device_name = message.get("device_name", "")
        
        if device_id not in self.trusted_devices:
            pin = self.generate_pairing_pin()
            if device_id in self.peers:
                self.peers[device_id].pairing_pin = pin
            
            return {
                "type": "handshake_response",
                "status": "pairing_required",
                "device_id": self.config.device_id,
                "device_name": self.config.device_name,
                "pin_required": True
            }
        
        return {
            "type": "handshake_response",
            "status": "connected",
            "device_id": self.config.device_id,
            "device_name": self.config.device_name,
            "capabilities": ["clipboard", "file_transfer", "screen_share"]
        }
    
    def _handle_pair_request(self, message: Dict, source_ip: str) -> Dict:
        """Handle pairing request"""
        device_id = message.get("device_id", "")
        device_name = message.get("device_name", "")
        
        pin = self.generate_pairing_pin()
        
        peer_id = hashlib.sha256(f"{device_name}-{source_ip}".encode()).hexdigest()[:16]
        if peer_id in self.peers:
            self.peers[peer_id].pairing_pin = pin
        else:
            self.add_peer(device_name, source_ip)
            self.peers[peer_id].pairing_pin = pin
        
        return {
            "type": "pair_response",
            "status": "pin_generated",
            "message": f"Enter PIN on {self.config.device_name}: {pin}"
        }
    
    def _handle_pair_verify(self, message: Dict, source_ip: str) -> Dict:
        """Handle PIN verification"""
        device_id = message.get("device_id", "")
        pin = message.get("pin", "")
        
        for peer_id, peer in self.peers.items():
            if peer.ip_address == source_ip and peer.pairing_pin == pin:
                self.trust_device(peer_id)
                peer.pairing_pin = ""
                return {
                    "type": "pair_verify_response",
                    "status": "success",
                    "message": "Device paired successfully"
                }
        
        return {
            "type": "pair_verify_response",
            "status": "failed",
            "message": "Invalid PIN"
        }
    
    def _handle_clipboard(self, message: Dict, source_ip: str) -> Dict:
        """Handle clipboard sync"""
        if not self.config.clipboard_sharing:
            return {"type": "error", "message": "Clipboard sharing disabled"}
        
        data = ClipboardData(
            content_type=message.get("content_type", "text"),
            data=message.get("data", ""),
            timestamp=message.get("timestamp", datetime.now().isoformat()),
            source_device=source_ip,
            size_bytes=len(message.get("data", ""))
        )
        
        if self.clipboard:
            self.clipboard.set_clipboard(data)
        
        return {"type": "clipboard_ack", "status": "received"}
    
    def _handle_mouse_move(self, message: Dict) -> Dict:
        """Handle mouse movement"""
        x = message.get("x", 0)
        y = message.get("y", 0)
        
        try:
            subprocess.run(['xdotool', 'mousemove', str(x), str(y)], 
                         capture_output=True, timeout=0.1)
        except Exception:
            pass
        
        return {"type": "mouse_ack"}
    
    def _handle_key_event(self, message: Dict) -> Dict:
        """Handle keyboard event"""
        key = message.get("key", "")
        event_type = message.get("event_type", "press")
        
        try:
            if event_type == "press":
                subprocess.run(['xdotool', 'key', key], capture_output=True, timeout=0.1)
        except Exception:
            pass
        
        return {"type": "key_ack"}
    
    def _discovery_listener(self):
        """Listen for discovery broadcasts"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind(('', DISCOVERY_PORT))
            sock.settimeout(1.0)
            
            while self.running:
                try:
                    data, addr = sock.recvfrom(4096)
                    message = json.loads(data.decode())
                    
                    if message.get("type") == "discover" and \
                       message.get("device_id") != self.config.device_id:
                        
                        response = json.dumps({
                            "type": "discover_response",
                            "device_id": self.config.device_id,
                            "device_name": self.config.device_name,
                            "port": self.config.listen_port,
                            "version": VERSION
                        }).encode()
                        sock.sendto(response, addr)
                except socket.timeout:
                    continue
                except Exception:
                    continue
        except Exception:
            pass
    
    def _reconnect_loop(self):
        """Auto-reconnect to disconnected peers"""
        while self.running:
            for peer_id, peer in list(self.peers.items()):
                if peer.status == "disconnected" and peer.enabled:
                    attempts = self.reconnect_counts.get(peer_id, 0)
                    
                    if attempts < self.config.reconnect_attempts:
                        latency = self._measure_latency(peer.ip_address)
                        if latency > 0:
                            peer.status = "connected"
                            peer.latency_ms = latency
                            peer.last_seen = datetime.now().isoformat()
                            self.reconnect_counts[peer_id] = 0
                        else:
                            self.reconnect_counts[peer_id] = attempts + 1
            
            time.sleep(RECONNECT_DELAY)
    
    def _on_clipboard_change(self, data: ClipboardData):
        """Handle local clipboard change"""
        if not self.config.clipboard_sharing:
            return
        
        for peer in self.peers.values():
            if peer.status == "connected" and peer.trusted:
                try:
                    self._send_to_peer(peer, {
                        "type": "clipboard",
                        "content_type": data.content_type,
                        "data": data.data,
                        "timestamp": data.timestamp
                    })
                except Exception:
                    pass
    
    def _send_to_peer(self, peer: PeerDevice, message: Dict) -> Optional[Dict]:
        """Send message to peer"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5.0)
            
            if self.config.encryption_enabled:
                ssl_context = self.cert_manager.get_ssl_context(server=False)
                if ssl_context:
                    sock = ssl_context.wrap_socket(sock)
            
            sock.connect((peer.ip_address, peer.port))
            sock.send(json.dumps(message).encode())
            
            response = sock.recv(4096)
            sock.close()
            
            return json.loads(response.decode())
        except Exception:
            return None
    
    def _lock_screen(self):
        """Lock the screen"""
        try:
            subprocess.run(['loginctl', 'lock-session'], capture_output=True)
        except Exception:
            try:
                subprocess.run(['xdg-screensaver', 'lock'], capture_output=True)
            except Exception:
                pass
    
    def send_file_to_peer(self, peer_id: str, filepath: str) -> bool:
        """Send file to specific peer"""
        if peer_id not in self.peers:
            return False
        
        peer = self.peers[peer_id]
        if not peer.trusted or peer.status != "connected":
            return False
        
        if self.file_transfer:
            return self.file_transfer.send_file(filepath, peer.ip_address)
        return False
    
    def set_gaming_mode(self, mode: str) -> bool:
        """Set gaming mode"""
        try:
            gaming_mode = GamingMode(mode)
            if gaming_mode == GamingMode.OFF:
                return self.gaming_mode.disable()
            else:
                return self.gaming_mode.enable(gaming_mode)
        except ValueError:
            return False
    
    def toggle_gaming_mode(self) -> str:
        """Toggle gaming mode on/off"""
        mode = self.gaming_mode.toggle()
        self.config.gaming_mode = mode.value
        self._save_config()
        return mode.value
    
    def _detect_barrier_binary(self) -> Tuple[Optional[str], Optional[str], str]:
        """Detect available Barrier/Input Leap binaries.
        Returns (server_binary, client_binary, backend_name)
        """
        for server_bin, client_bin, name in [
            ('input-leaps', 'input-leapc', 'Input Leap'),
            ('barriers', 'barrierc', 'Barrier'),
            ('synergys', 'synergyc', 'Synergy'),
        ]:
            if shutil.which(server_bin) and shutil.which(client_bin):
                return (server_bin, client_bin, name)
        
        for server_bin, client_bin, name in [
            ('input-leaps', 'input-leapc', 'Input Leap'),
            ('barriers', 'barrierc', 'Barrier'),
        ]:
            if shutil.which(server_bin):
                return (server_bin, None, name)
            if shutil.which(client_bin):
                return (None, client_bin, name)
        
        return (None, None, 'none')
    
    def _generate_barrier_config(self, server_hostname: Optional[str] = None) -> str:
        """Generate Barrier/Input Leap configuration file.
        Returns path to generated config file.
        """
        server_binary, client_binary, backend = self._detect_barrier_binary()
        
        if backend == 'Input Leap':
            config_dir = INPUT_LEAP_CONFIG_DIR
            config_file = INPUT_LEAP_CONFIG_FILE
        else:
            config_dir = BARRIER_CONFIG_DIR
            config_file = BARRIER_CONFIG_FILE
        
        config_dir.mkdir(parents=True, exist_ok=True)
        ssl_dir = config_dir / "SSL"
        ssl_dir.mkdir(parents=True, exist_ok=True)
        
        hostname = server_hostname or self.config.device_name or socket.gethostname()
        
        screens_section = [f"\t{hostname}:"]
        links_section = [f"\t{hostname}:"]
        
        for peer in self.peers.values():
            if peer.enabled and peer.trusted:
                peer_name = peer.name.replace(' ', '-').replace('.', '-')
                screens_section.append(f"\t{peer_name}:")
                
                edge = peer.edge_position.lower()
                if edge == "right":
                    links_section.append(f"\t\tright = {peer_name}")
                elif edge == "left":
                    links_section.append(f"\t\tleft = {peer_name}")
                elif edge == "top":
                    links_section.append(f"\t\tup = {peer_name}")
                elif edge == "bottom":
                    links_section.append(f"\t\tdown = {peer_name}")
        
        for peer in self.peers.values():
            if peer.enabled and peer.trusted:
                peer_name = peer.name.replace(' ', '-').replace('.', '-')
                links_section.append(f"\t{peer_name}:")
                
                edge = peer.edge_position.lower()
                if edge == "right":
                    links_section.append(f"\t\tleft = {hostname}")
                elif edge == "left":
                    links_section.append(f"\t\tright = {hostname}")
                elif edge == "top":
                    links_section.append(f"\t\tdown = {hostname}")
                elif edge == "bottom":
                    links_section.append(f"\t\tup = {hostname}")
        
        config_content = f"""# Barrier/Input Leap configuration
# Generated by Aegis Desktop Link v{VERSION}
# {datetime.now().isoformat()}

section: screens
{chr(10).join(screens_section)}
end

section: aliases
end

section: links
{chr(10).join(links_section)}
end

section: options
    relativeMouseMoves = false
    screenSaverSync = true
    win32KeepForeground = false
    clipboardSharing = {'true' if self.config.clipboard_sharing else 'false'}
    switchCorners = {'all' if self.config.corner_switch else 'none'}
    switchCornerSize = {self.config.corner_size}
    switchDelay = {self.config.switch_delay_ms}
end
"""
        
        with open(config_file, 'w') as f:
            f.write(config_content)
        
        os.chmod(config_file, 0o600)
        
        return str(config_file)
    
    def _start_barrier_server(self, 
                               config_path: Optional[str] = None,
                               address: str = "0.0.0.0",
                               port: int = 24800,
                               enable_crypto: bool = True) -> Tuple[bool, Optional[subprocess.Popen], str]:
        """Start Barrier/Input Leap server.
        Returns (success, process, message)
        """
        server_binary, _, backend = self._detect_barrier_binary()
        
        if not server_binary:
            return (False, None, "No Barrier/Input Leap server binary found. "
                   "Please install 'barrier' or 'input-leap' package.")
        
        if not config_path:
            config_path = self._generate_barrier_config()
        
        if not Path(config_path).exists():
            return (False, None, f"Configuration file not found: {config_path}")
        
        cmd = [server_binary]
        
        cmd.extend(['--config', config_path])
        cmd.extend(['--address', f"{address}:{port}"])
        
        if not enable_crypto:
            cmd.append('--disable-crypto')
        
        cmd.extend(['--no-daemon'])
        
        if self.config.encryption_enabled and enable_crypto:
            ssl_dir = BARRIER_CONFIG_DIR / "SSL" if backend == 'Barrier' else INPUT_LEAP_CONFIG_DIR / "SSL"
            ssl_dir.mkdir(parents=True, exist_ok=True)
            
            fingerprints_file = ssl_dir / "Fingerprints" / "TrustedServers.txt"
            fingerprints_file.parent.mkdir(parents=True, exist_ok=True)
            
            for peer in self.peers.values():
                if peer.trusted and peer.public_key:
                    with open(fingerprints_file, 'a') as f:
                        f.write(f"{peer.public_key}\n")
        
        try:
            env = os.environ.copy()
            if 'DISPLAY' not in env:
                env['DISPLAY'] = ':0'
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env,
                start_new_session=True
            )
            
            time.sleep(0.5)
            if process.poll() is not None:
                _, stderr = process.communicate(timeout=1)
                error_msg = stderr.decode() if stderr else "Unknown error"
                return (False, None, f"Server failed to start: {error_msg}")
            
            return (True, process, f"{backend} server started on {address}:{port}")
            
        except FileNotFoundError:
            return (False, None, f"Binary not found: {server_binary}")
        except Exception as e:
            return (False, None, f"Failed to start server: {str(e)}")
    
    def _start_barrier_client(self,
                               server_address: str,
                               server_port: int = 24800,
                               client_name: Optional[str] = None,
                               enable_crypto: bool = True) -> Tuple[bool, Optional[subprocess.Popen], str]:
        """Start Barrier/Input Leap client.
        Returns (success, process, message)
        """
        _, client_binary, backend = self._detect_barrier_binary()
        
        if not client_binary:
            return (False, None, "No Barrier/Input Leap client binary found. "
                   "Please install 'barrier' or 'input-leap' package.")
        
        if not server_address:
            return (False, None, "Server address is required")
        
        cmd = [client_binary]
        
        if client_name:
            cmd.extend(['--name', client_name])
        else:
            cmd.extend(['--name', self.config.device_name or socket.gethostname()])
        
        if not enable_crypto:
            cmd.append('--disable-crypto')
        
        cmd.append('--no-daemon')
        
        cmd.append(f"{server_address}:{server_port}")
        
        try:
            env = os.environ.copy()
            if 'DISPLAY' not in env:
                env['DISPLAY'] = ':0'
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env,
                start_new_session=True
            )
            
            time.sleep(0.5)
            if process.poll() is not None:
                _, stderr = process.communicate(timeout=1)
                error_msg = stderr.decode() if stderr else "Unknown error"
                return (False, None, f"Client failed to start: {error_msg}")
            
            return (True, process, f"{backend} client connected to {server_address}:{server_port}")
            
        except FileNotFoundError:
            return (False, None, f"Binary not found: {client_binary}")
        except Exception as e:
            return (False, None, f"Failed to start client: {str(e)}")
    
    def _stop_barrier_process(self, process: subprocess.Popen) -> bool:
        """Stop a running Barrier/Input Leap process."""
        if not process:
            return True
        
        try:
            process.terminate()
            try:
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                process.kill()
                process.wait(timeout=2)
            return True
        except Exception:
            return False
    
    def _discover_barrier_peers(self, timeout: float = 5.0) -> List[Dict]:
        """Discover Barrier/Input Leap peers using mDNS/Avahi.
        Returns list of discovered devices.
        """
        discovered = []
        
        if not shutil.which('avahi-browse'):
            return discovered
        
        service_types = [
            '_barrier._tcp',
            '_input-leap._tcp',
            '_synergy._tcp',
            '_aegis-desklink._tcp',
        ]
        
        for service_type in service_types:
            try:
                result = subprocess.run(
                    ['avahi-browse', '-ptr', service_type],
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
                
                if result.returncode == 0:
                    for line in result.stdout.strip().split('\n'):
                        if not line or line.startswith('+'):
                            continue
                        
                        parts = line.split(';')
                        if len(parts) >= 8:
                            try:
                                ip_addr = parts[7]
                                port_str = parts[8] if len(parts) > 8 else "24800"
                                
                                if not ip_addr or ip_addr.startswith('127.'):
                                    continue
                                
                                device_info = {
                                    "name": parts[3],
                                    "hostname": parts[6].rstrip('.'),
                                    "ip_address": ip_addr,
                                    "port": int(port_str) if port_str.isdigit() else 24800,
                                    "service_type": service_type,
                                    "domain": parts[5],
                                    "last_seen": datetime.now().isoformat()
                                }
                                
                                if not any(d.get("ip_address") == ip_addr for d in discovered):
                                    device_info["latency_ms"] = self._measure_latency(ip_addr)
                                    discovered.append(device_info)
                            except (ValueError, IndexError):
                                continue
            except subprocess.TimeoutExpired:
                continue
            except Exception:
                continue
        
        return discovered
    
    def get_barrier_status(self) -> Dict:
        """Get status of Barrier/Input Leap integration."""
        server_bin, client_bin, backend = self._detect_barrier_binary()
        
        server_running = False
        client_running = False
        
        try:
            result = subprocess.run(['pgrep', '-f', 'barriers|input-leaps'],
                                   capture_output=True, timeout=2)
            server_running = result.returncode == 0
        except Exception:
            pass
        
        try:
            result = subprocess.run(['pgrep', '-f', 'barrierc|input-leapc'],
                                   capture_output=True, timeout=2)
            client_running = result.returncode == 0
        except Exception:
            pass
        
        config_exists = False
        if backend == 'Input Leap':
            config_exists = INPUT_LEAP_CONFIG_FILE.exists()
        else:
            config_exists = BARRIER_CONFIG_FILE.exists()
        
        return {
            "backend": backend,
            "available": backend != 'none',
            "server_binary": server_bin,
            "client_binary": client_bin,
            "server_running": server_running,
            "client_running": client_running,
            "config_exists": config_exists,
            "avahi_available": shutil.which('avahi-browse') is not None,
            "clipboard_tools": self.clipboard.get_available_tools() if self.clipboard else {}
        }


class DesktopLinkGUI:
    """Tkinter GUI for Desktop Link"""
    
    def __init__(self, service: DesktopLinkService):
        self.service = service
        self.root = None
        self.status_refresh_job = None
        
    def run(self):
        if not TKINTER_AVAILABLE:
            print("Error: Tkinter not available for GUI mode")
            sys.exit(1)
            
        self.root = tk.Tk()
        self.root.title(f"{APP_NAME} v{VERSION}")
        self.root.geometry("900x700")
        self.root.configure(bg='#1e1e1e')
        
        style = ttk.Style()
        style.theme_use('clam')
        style.configure('TFrame', background='#1e1e1e')
        style.configure('TLabel', background='#1e1e1e', foreground='#ffffff')
        style.configure('TButton', padding=8)
        style.configure('Header.TLabel', font=('Segoe UI', 18, 'bold'))
        style.configure('Subheader.TLabel', font=('Segoe UI', 11))
        style.configure('Status.TLabel', font=('Segoe UI', 10))
        style.configure('TNotebook', background='#1e1e1e')
        style.configure('TNotebook.Tab', padding=[12, 4])
        
        self._create_widgets()
        self._start_status_refresh()
        self.root.protocol("WM_DELETE_WINDOW", self._on_close)
        self.root.mainloop()
    
    def _create_widgets(self):
        main = ttk.Frame(self.root, padding=15)
        main.pack(fill=tk.BOTH, expand=True)
        
        header = ttk.Frame(main)
        header.pack(fill=tk.X, pady=(0, 15))
        
        title_frame = ttk.Frame(header)
        title_frame.pack(side=tk.LEFT)
        ttk.Label(title_frame, text="Aegis Desktop Link", style='Header.TLabel').pack(anchor=tk.W)
        ttk.Label(title_frame, text=f"v{VERSION} - Multi-PC KVM Control", 
                 style='Subheader.TLabel', foreground='#888888').pack(anchor=tk.W)
        
        status_frame = ttk.Frame(header)
        status_frame.pack(side=tk.RIGHT)
        self.status_label = ttk.Label(status_frame, text=" Stopped", 
                                      style='Status.TLabel', foreground='#ff6b6b')
        self.status_label.pack(anchor=tk.E)
        self.connection_label = ttk.Label(status_frame, text="0 devices connected",
                                         style='Status.TLabel', foreground='#888888')
        self.connection_label.pack(anchor=tk.E)
        
        notebook = ttk.Notebook(main)
        notebook.pack(fill=tk.BOTH, expand=True, pady=10)
        
        devices_tab = ttk.Frame(notebook, padding=10)
        notebook.add(devices_tab, text="Devices")
        self._create_devices_tab(devices_tab)
        
        settings_tab = ttk.Frame(notebook, padding=10)
        notebook.add(settings_tab, text="Settings")
        self._create_settings_tab(settings_tab)
        
        layout_tab = ttk.Frame(notebook, padding=10)
        notebook.add(layout_tab, text="Screen Layout")
        self._create_layout_tab(layout_tab)
        
        gaming_tab = ttk.Frame(notebook, padding=10)
        notebook.add(gaming_tab, text="Gaming Mode")
        self._create_gaming_tab(gaming_tab)
        
        control_frame = ttk.Frame(main)
        control_frame.pack(fill=tk.X, pady=10)
        
        self.start_btn = ttk.Button(control_frame, text=" Start Server", 
                                    command=self._start_service)
        self.start_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_btn = ttk.Button(control_frame, text=" Stop Server", 
                                   command=self._stop_service)
        self.stop_btn.pack(side=tk.LEFT, padx=5)
        
        ttk.Button(control_frame, text=" Discover", 
                  command=self._discover_peers).pack(side=tk.LEFT, padx=5)
        ttk.Button(control_frame, text=" Add Device", 
                  command=self._add_peer_dialog).pack(side=tk.LEFT, padx=5)
        
        self.gaming_btn = ttk.Button(control_frame, text=" Gaming: OFF",
                                     command=self._toggle_gaming)
        self.gaming_btn.pack(side=tk.RIGHT, padx=5)
    
    def _create_devices_tab(self, parent):
        columns = ('name', 'ip', 'edge', 'latency', 'status', 'trusted')
        self.peers_tree = ttk.Treeview(parent, columns=columns, show='headings', height=12)
        
        self.peers_tree.heading('name', text='Device Name')
        self.peers_tree.heading('ip', text='IP Address')
        self.peers_tree.heading('edge', text='Edge')
        self.peers_tree.heading('latency', text='Latency')
        self.peers_tree.heading('status', text='Status')
        self.peers_tree.heading('trusted', text='Trusted')
        
        self.peers_tree.column('name', width=180)
        self.peers_tree.column('ip', width=130)
        self.peers_tree.column('edge', width=80)
        self.peers_tree.column('latency', width=80)
        self.peers_tree.column('status', width=100)
        self.peers_tree.column('trusted', width=80)
        
        scrollbar = ttk.Scrollbar(parent, orient=tk.VERTICAL, command=self.peers_tree.yview)
        self.peers_tree.configure(yscrollcommand=scrollbar.set)
        
        self.peers_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.peers_tree.bind('<Double-1>', self._on_peer_double_click)
        self.peers_tree.bind('<Button-3>', self._show_peer_context_menu)
        
        self._refresh_peers()
    
    def _create_settings_tab(self, parent):
        settings_canvas = tk.Canvas(parent, bg='#1e1e1e', highlightthickness=0)
        scrollbar = ttk.Scrollbar(parent, orient=tk.VERTICAL, command=settings_canvas.yview)
        settings_frame = ttk.Frame(settings_canvas)
        
        settings_frame.bind('<Configure>', 
                           lambda e: settings_canvas.configure(scrollregion=settings_canvas.bbox('all')))
        settings_canvas.create_window((0, 0), window=settings_frame, anchor='nw')
        settings_canvas.configure(yscrollcommand=scrollbar.set)
        
        settings_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        security_frame = ttk.LabelFrame(settings_frame, text="Security", padding=10)
        security_frame.pack(fill=tk.X, pady=5, padx=5)
        
        self.encrypt_var = tk.BooleanVar(value=self.service.config.encryption_enabled)
        ttk.Checkbutton(security_frame, text="Enable TLS encryption", 
                       variable=self.encrypt_var, command=self._save_settings).pack(anchor=tk.W)
        
        self.auto_lock_var = tk.BooleanVar(value=self.service.config.auto_lock_on_disconnect)
        ttk.Checkbutton(security_frame, text="Lock screen on disconnect", 
                       variable=self.auto_lock_var, command=self._save_settings).pack(anchor=tk.W)
        
        sharing_frame = ttk.LabelFrame(settings_frame, text="Sharing", padding=10)
        sharing_frame.pack(fill=tk.X, pady=5, padx=5)
        
        self.clipboard_var = tk.BooleanVar(value=self.service.config.clipboard_sharing)
        ttk.Checkbutton(sharing_frame, text="Enable clipboard sync", 
                       variable=self.clipboard_var, command=self._save_settings).pack(anchor=tk.W)
        
        self.file_var = tk.BooleanVar(value=self.service.config.file_sharing)
        ttk.Checkbutton(sharing_frame, text="Enable file drag & drop", 
                       variable=self.file_var, command=self._save_settings).pack(anchor=tk.W)
        
        self.lock_var = tk.BooleanVar(value=self.service.config.lock_sync)
        ttk.Checkbutton(sharing_frame, text="Synchronize screen lock", 
                       variable=self.lock_var, command=self._save_settings).pack(anchor=tk.W)
        
        network_frame = ttk.LabelFrame(settings_frame, text="Network", padding=10)
        network_frame.pack(fill=tk.X, pady=5, padx=5)
        
        self.discovery_var = tk.BooleanVar(value=self.service.config.auto_discovery)
        ttk.Checkbutton(network_frame, text="Auto-discover devices (Avahi/mDNS)", 
                       variable=self.discovery_var, command=self._save_settings).pack(anchor=tk.W)
        
        self.reconnect_var = tk.BooleanVar(value=self.service.config.auto_reconnect)
        ttk.Checkbutton(network_frame, text="Auto-reconnect on network issues", 
                       variable=self.reconnect_var, command=self._save_settings).pack(anchor=tk.W)
        
        integration_frame = ttk.LabelFrame(settings_frame, text="Aegis Integration", padding=10)
        integration_frame.pack(fill=tk.X, pady=5, padx=5)
        
        self.nas_var = tk.BooleanVar(value=self.service.config.nas_integration)
        ttk.Checkbutton(integration_frame, text="Aegis Home NAS integration", 
                       variable=self.nas_var, command=self._save_settings).pack(anchor=tk.W)
        
        self.mobile_var = tk.BooleanVar(value=self.service.config.mobile_integration)
        ttk.Checkbutton(integration_frame, text="Aegis Mobile Link integration", 
                       variable=self.mobile_var, command=self._save_settings).pack(anchor=tk.W)
        
        hotkeys_frame = ttk.LabelFrame(settings_frame, text="Hotkeys", padding=10)
        hotkeys_frame.pack(fill=tk.X, pady=5, padx=5)
        
        ttk.Label(hotkeys_frame, text="Switch screens:").grid(row=0, column=0, sticky=tk.W, pady=2)
        self.hotkey_switch = ttk.Entry(hotkeys_frame, width=20)
        self.hotkey_switch.insert(0, self.service.config.hotkey_switch)
        self.hotkey_switch.grid(row=0, column=1, pady=2, padx=10)
        
        ttk.Label(hotkeys_frame, text="Lock cursor:").grid(row=1, column=0, sticky=tk.W, pady=2)
        self.hotkey_lock = ttk.Entry(hotkeys_frame, width=20)
        self.hotkey_lock.insert(0, self.service.config.hotkey_lock_cursor)
        self.hotkey_lock.grid(row=1, column=1, pady=2, padx=10)
        
        ttk.Label(hotkeys_frame, text="Toggle gaming:").grid(row=2, column=0, sticky=tk.W, pady=2)
        self.hotkey_gaming = ttk.Entry(hotkeys_frame, width=20)
        self.hotkey_gaming.insert(0, self.service.config.hotkey_gaming_toggle)
        self.hotkey_gaming.grid(row=2, column=1, pady=2, padx=10)
    
    def _create_layout_tab(self, parent):
        layout_frame = ttk.Frame(parent)
        layout_frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(layout_frame, text="Screen Edge Configuration", 
                 style='Subheader.TLabel').pack(pady=10)
        
        ttk.Label(layout_frame, text="Configure which device connects to each edge of your screen:",
                 foreground='#888888').pack()
        
        grid_frame = ttk.Frame(layout_frame)
        grid_frame.pack(pady=20)
        
        ttk.Label(grid_frame, text="Top:").grid(row=0, column=1, pady=5)
        self.edge_top = ttk.Combobox(grid_frame, values=self._get_peer_names(), width=20)
        self.edge_top.grid(row=1, column=1, pady=5)
        
        ttk.Label(grid_frame, text="Left:").grid(row=2, column=0, padx=20)
        self.edge_left = ttk.Combobox(grid_frame, values=self._get_peer_names(), width=20)
        self.edge_left.grid(row=3, column=0, padx=20)
        
        monitor_label = ttk.Label(grid_frame, text="[This PC]", font=('Segoe UI', 12, 'bold'),
                                 background='#3d3d3d', foreground='#ffffff', padding=30)
        monitor_label.grid(row=2, column=1, rowspan=2, pady=10, padx=10)
        
        ttk.Label(grid_frame, text="Right:").grid(row=2, column=2, padx=20)
        self.edge_right = ttk.Combobox(grid_frame, values=self._get_peer_names(), width=20)
        self.edge_right.grid(row=3, column=2, padx=20)
        
        ttk.Label(grid_frame, text="Bottom:").grid(row=4, column=1, pady=5)
        self.edge_bottom = ttk.Combobox(grid_frame, values=self._get_peer_names(), width=20)
        self.edge_bottom.grid(row=5, column=1, pady=5)
        
        ttk.Button(layout_frame, text="Apply Layout", 
                  command=self._apply_layout).pack(pady=20)
        
        monitors_frame = ttk.LabelFrame(layout_frame, text="Monitors", padding=10)
        monitors_frame.pack(fill=tk.X, pady=10, padx=5)
        
        for i, monitor in enumerate(self.service.config.monitors):
            var = tk.BooleanVar(value=monitor.get('shared', True))
            ttk.Checkbutton(monitors_frame, 
                          text=f"{monitor.get('name', f'Monitor {i+1}')} ({monitor.get('width', 1920)}x{monitor.get('height', 1080)})",
                          variable=var).pack(anchor=tk.W)
    
    def _create_gaming_tab(self, parent):
        gaming_frame = ttk.Frame(parent)
        gaming_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        ttk.Label(gaming_frame, text="Gaming Mode", style='Header.TLabel').pack(anchor=tk.W)
        ttk.Label(gaming_frame, 
                 text="Optimize for minimal latency during gaming sessions",
                 foreground='#888888').pack(anchor=tk.W, pady=(0, 20))
        
        self.gaming_mode_var = tk.StringVar(value=self.service.config.gaming_mode)
        
        modes_frame = ttk.LabelFrame(gaming_frame, text="Mode Selection", padding=15)
        modes_frame.pack(fill=tk.X, pady=10)
        
        ttk.Radiobutton(modes_frame, text="Off - Normal operation",
                       variable=self.gaming_mode_var, value="off").pack(anchor=tk.W, pady=5)
        ttk.Radiobutton(modes_frame, text="Low Latency - Optimized for gaming (~5ms)",
                       variable=self.gaming_mode_var, value="low_latency").pack(anchor=tk.W, pady=5)
        ttk.Radiobutton(modes_frame, text="Ultra Low - Maximum performance (<1ms)",
                       variable=self.gaming_mode_var, value="ultra_low").pack(anchor=tk.W, pady=5)
        ttk.Radiobutton(modes_frame, text="Disabled - Pause KVM while gaming",
                       variable=self.gaming_mode_var, value="disabled").pack(anchor=tk.W, pady=5)
        
        options_frame = ttk.LabelFrame(gaming_frame, text="Options", padding=15)
        options_frame.pack(fill=tk.X, pady=10)
        
        self.raw_input_var = tk.BooleanVar(value=self.service.config.raw_input_passthrough)
        ttk.Checkbutton(options_frame, text="Raw input passthrough (lower latency)",
                       variable=self.raw_input_var).pack(anchor=tk.W, pady=5)
        
        ttk.Button(gaming_frame, text="Apply Gaming Settings",
                  command=self._apply_gaming_settings).pack(pady=20)
        
        ttk.Label(gaming_frame, 
                 text=f"Hotkey to toggle: {self.service.config.hotkey_gaming_toggle}",
                 foreground='#888888').pack(anchor=tk.W)
    
    def _get_peer_names(self) -> List[str]:
        """Get list of peer device names"""
        names = ["(None)"]
        names.extend([p.name for p in self.service.peers.values()])
        return names
    
    def _refresh_peers(self):
        """Refresh peers list"""
        for item in self.peers_tree.get_children():
            self.peers_tree.delete(item)
        
        for peer_id, peer in self.service.peers.items():
            latency = f"{peer.latency_ms:.1f}ms" if peer.latency_ms > 0 else "N/A"
            trusted = "" if peer.trusted else ""
            status_color = "" if peer.status == "connected" else ""
            
            self.peers_tree.insert('', tk.END, iid=peer_id, values=(
                peer.name, 
                peer.ip_address, 
                peer.edge_position.capitalize(),
                latency,
                f"{status_color} {peer.status.capitalize()}",
                trusted
            ))
    
    def _start_status_refresh(self):
        """Start periodic status refresh"""
        self._update_status()
    
    def _update_status(self):
        """Update status display"""
        if self.service.running:
            self.status_label.configure(text=" Running", foreground='#51cf66')
        else:
            self.status_label.configure(text=" Stopped", foreground='#ff6b6b')
        
        connected = sum(1 for p in self.service.peers.values() if p.status == "connected")
        total = len(self.service.peers)
        self.connection_label.configure(text=f"{connected}/{total} devices connected")
        
        gaming = self.service.gaming_mode.mode.value
        self.gaming_btn.configure(text=f" Gaming: {gaming.upper()}")
        
        self._refresh_peers()
        
        self.status_refresh_job = self.root.after(5000, self._update_status)
    
    def _start_service(self):
        if self.service.start_service():
            self.status_label.configure(text=" Running", foreground='#51cf66')
            messagebox.showinfo("Success", "Desktop Link server started!")
        else:
            messagebox.showerror("Error", "Failed to start server")
    
    def _stop_service(self):
        if self.service.stop_service():
            self.status_label.configure(text=" Stopped", foreground='#ff6b6b')
    
    def _discover_peers(self):
        discovered = self.service.discover_peers()
        if discovered:
            for peer in discovered:
                self.service.add_peer(
                    peer.get('device_name', peer.get('hostname', 'Unknown')),
                    peer['ip_address']
                )
            self._refresh_peers()
            messagebox.showinfo("Discovery", f"Found {len(discovered)} device(s)")
        else:
            messagebox.showinfo("Discovery", "No devices found on the network")
    
    def _add_peer_dialog(self):
        dialog = tk.Toplevel(self.root)
        dialog.title("Add Device")
        dialog.geometry("450x300")
        dialog.configure(bg='#1e1e1e')
        dialog.transient(self.root)
        dialog.grab_set()
        
        frame = ttk.Frame(dialog, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(frame, text="Add New Device", style='Header.TLabel').pack(pady=(0, 20))
        
        fields_frame = ttk.Frame(frame)
        fields_frame.pack(fill=tk.X)
        
        ttk.Label(fields_frame, text="Device Name:").grid(row=0, column=0, sticky=tk.W, pady=8)
        name_entry = ttk.Entry(fields_frame, width=35)
        name_entry.grid(row=0, column=1, pady=8, padx=10)
        
        ttk.Label(fields_frame, text="IP Address:").grid(row=1, column=0, sticky=tk.W, pady=8)
        ip_entry = ttk.Entry(fields_frame, width=35)
        ip_entry.grid(row=1, column=1, pady=8, padx=10)
        
        ttk.Label(fields_frame, text="Edge Position:").grid(row=2, column=0, sticky=tk.W, pady=8)
        edge_combo = ttk.Combobox(fields_frame, values=['left', 'right', 'top', 'bottom'], width=32)
        edge_combo.set('right')
        edge_combo.grid(row=2, column=1, pady=8, padx=10)
        
        trust_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(fields_frame, text="Trust this device immediately",
                       variable=trust_var).grid(row=3, column=1, sticky=tk.W, pady=8, padx=10)
        
        def add():
            name = name_entry.get().strip()
            ip = ip_entry.get().strip()
            edge = edge_combo.get()
            trust = trust_var.get()
            
            if name and ip:
                self.service.add_peer(name, ip, edge, trust)
                self._refresh_peers()
                dialog.destroy()
            else:
                messagebox.showerror("Error", "Please fill all required fields")
        
        ttk.Button(frame, text="Add Device", command=add).pack(pady=20)
    
    def _on_peer_double_click(self, event):
        """Handle double-click on peer"""
        selection = self.peers_tree.selection()
        if selection:
            peer_id = selection[0]
            self._show_peer_details(peer_id)
    
    def _show_peer_context_menu(self, event):
        """Show context menu for peer"""
        selection = self.peers_tree.identify_row(event.y)
        if selection:
            self.peers_tree.selection_set(selection)
            
            menu = tk.Menu(self.root, tearoff=0)
            menu.add_command(label="Edit", command=lambda: self._show_peer_details(selection))
            menu.add_command(label="Trust", command=lambda: self._trust_peer(selection))
            menu.add_command(label="Untrust", command=lambda: self._untrust_peer(selection))
            menu.add_separator()
            menu.add_command(label="Send File", command=lambda: self._send_file_to_peer(selection))
            menu.add_separator()
            menu.add_command(label="Remove", command=lambda: self._remove_peer(selection))
            
            menu.tk_popup(event.x_root, event.y_root)
    
    def _show_peer_details(self, peer_id: str):
        """Show peer details dialog"""
        if peer_id not in self.service.peers:
            return
        
        peer = self.service.peers[peer_id]
        
        dialog = tk.Toplevel(self.root)
        dialog.title(f"Device: {peer.name}")
        dialog.geometry("400x350")
        dialog.configure(bg='#1e1e1e')
        dialog.transient(self.root)
        
        frame = ttk.Frame(dialog, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(frame, text=peer.name, style='Header.TLabel').pack(anchor=tk.W)
        
        info_frame = ttk.Frame(frame)
        info_frame.pack(fill=tk.X, pady=20)
        
        ttk.Label(info_frame, text=f"IP Address: {peer.ip_address}").pack(anchor=tk.W, pady=2)
        ttk.Label(info_frame, text=f"Status: {peer.status}").pack(anchor=tk.W, pady=2)
        ttk.Label(info_frame, text=f"Latency: {peer.latency_ms:.1f}ms" if peer.latency_ms > 0 else "Latency: N/A").pack(anchor=tk.W, pady=2)
        ttk.Label(info_frame, text=f"Trusted: {'Yes' if peer.trusted else 'No'}").pack(anchor=tk.W, pady=2)
        ttk.Label(info_frame, text=f"Last Seen: {peer.last_seen}").pack(anchor=tk.W, pady=2)
        
        edge_frame = ttk.Frame(frame)
        edge_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(edge_frame, text="Edge Position:").pack(side=tk.LEFT)
        edge_combo = ttk.Combobox(edge_frame, values=['left', 'right', 'top', 'bottom'], width=15)
        edge_combo.set(peer.edge_position)
        edge_combo.pack(side=tk.LEFT, padx=10)
        
        def save_edge():
            self.service.update_peer_edge(peer_id, edge_combo.get())
            self._refresh_peers()
            dialog.destroy()
        
        ttk.Button(frame, text="Save", command=save_edge).pack(pady=10)
    
    def _trust_peer(self, peer_id: str):
        """Trust a peer device"""
        if self.service.trust_device(peer_id):
            self._refresh_peers()
            messagebox.showinfo("Success", "Device trusted")
    
    def _untrust_peer(self, peer_id: str):
        """Untrust a peer device"""
        if self.service.untrust_device(peer_id):
            self._refresh_peers()
            messagebox.showinfo("Success", "Device removed from trusted list")
    
    def _remove_peer(self, peer_id: str):
        """Remove a peer device"""
        if messagebox.askyesno("Confirm", "Remove this device?"):
            if self.service.remove_peer(peer_id):
                self._refresh_peers()
    
    def _send_file_to_peer(self, peer_id: str):
        """Send file to peer"""
        filepath = filedialog.askopenfilename(title="Select file to send")
        if filepath:
            if self.service.send_file_to_peer(peer_id, filepath):
                messagebox.showinfo("Success", "File transfer started")
            else:
                messagebox.showerror("Error", "Failed to start file transfer")
    
    def _toggle_gaming(self):
        """Toggle gaming mode"""
        mode = self.service.toggle_gaming_mode()
        self.gaming_btn.configure(text=f" Gaming: {mode.upper()}")
    
    def _save_settings(self):
        """Save settings"""
        self.service.config.encryption_enabled = self.encrypt_var.get()
        self.service.config.auto_lock_on_disconnect = self.auto_lock_var.get()
        self.service.config.clipboard_sharing = self.clipboard_var.get()
        self.service.config.file_sharing = self.file_var.get()
        self.service.config.lock_sync = self.lock_var.get()
        self.service.config.auto_discovery = self.discovery_var.get()
        self.service.config.auto_reconnect = self.reconnect_var.get()
        self.service.config.nas_integration = self.nas_var.get()
        self.service.config.mobile_integration = self.mobile_var.get()
        self.service._save_config()
    
    def _apply_layout(self):
        """Apply screen layout"""
        edge_config = {
            "left": self.edge_left.get() if self.edge_left.get() != "(None)" else "",
            "right": self.edge_right.get() if self.edge_right.get() != "(None)" else "",
            "top": self.edge_top.get() if self.edge_top.get() != "(None)" else "",
            "bottom": self.edge_bottom.get() if self.edge_bottom.get() != "(None)" else ""
        }
        
        for peer in self.service.peers.values():
            if peer.name == edge_config["left"]:
                peer.edge_position = "left"
            elif peer.name == edge_config["right"]:
                peer.edge_position = "right"
            elif peer.name == edge_config["top"]:
                peer.edge_position = "top"
            elif peer.name == edge_config["bottom"]:
                peer.edge_position = "bottom"
        
        self.service._save_peers()
        self._refresh_peers()
        messagebox.showinfo("Success", "Screen layout applied")
    
    def _apply_gaming_settings(self):
        """Apply gaming settings"""
        mode = self.gaming_mode_var.get()
        self.service.set_gaming_mode(mode)
        self.service.config.raw_input_passthrough = self.raw_input_var.get()
        self.service._save_config()
        messagebox.showinfo("Success", f"Gaming mode set to: {mode}")
    
    def _on_close(self):
        """Handle window close"""
        if self.status_refresh_job:
            self.root.after_cancel(self.status_refresh_job)
        self.root.destroy()


def main():
    parser = argparse.ArgumentParser(
        description=f"{APP_NAME} v{VERSION} - Share mouse/keyboard across computers"
    )
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--status', action='store_true', help='Show status as JSON')
    parser.add_argument('--start', action='store_true', help='Start server')
    parser.add_argument('--stop', action='store_true', help='Stop server')
    parser.add_argument('--discover', action='store_true', help='Discover peers')
    parser.add_argument('--add', nargs=2, metavar=('NAME', 'IP'), help='Add peer manually')
    parser.add_argument('--list', action='store_true', help='List connected peers')
    parser.add_argument('--remove', metavar='PEER_ID', help='Remove peer by ID')
    parser.add_argument('--trust', metavar='PEER_ID', help='Trust a device')
    parser.add_argument('--untrust', metavar='PEER_ID', help='Untrust a device')
    parser.add_argument('--send-file', nargs=2, metavar=('PEER_ID', 'FILE'), help='Send file to peer')
    parser.add_argument('--gaming', choices=['off', 'low_latency', 'ultra_low', 'disabled'],
                       help='Set gaming mode')
    parser.add_argument('--refresh', action='store_true', help='Refresh peer status')
    parser.add_argument('--version', action='version', version=f'{APP_NAME} v{VERSION}')
    
    args = parser.parse_args()
    service = DesktopLinkService()
    
    if args.status:
        print(json.dumps(service.get_status(), indent=2))
    elif args.start:
        if service.start_service():
            print("Desktop Link server started")
        else:
            print("Failed to start server", file=sys.stderr)
            sys.exit(1)
    elif args.stop:
        if service.stop_service():
            print("Desktop Link server stopped")
    elif args.discover:
        peers = service.discover_peers()
        if peers:
            print(f"Found {len(peers)} device(s):")
            for p in peers:
                latency = f" ({p.get('latency_ms', -1):.1f}ms)" if p.get('latency_ms', -1) > 0 else ""
                print(f"  - {p.get('device_name', 'Unknown')} ({p['ip_address']}){latency}")
        else:
            print("No devices found")
    elif args.add:
        peer = service.add_peer(args.add[0], args.add[1])
        print(f"Added device: {peer.name} ({peer.ip_address})")
    elif args.list:
        if service.peers:
            print("Configured devices:")
            for peer in service.peers.values():
                status = "" if peer.status == "connected" else ""
                trusted = "[trusted]" if peer.trusted else ""
                latency = f"({peer.latency_ms:.1f}ms)" if peer.latency_ms > 0 else "(offline)"
                print(f"  {status} {peer.name} ({peer.ip_address}) [{peer.edge_position}] {latency} {trusted}")
        else:
            print("No devices configured")
    elif args.remove:
        if service.remove_peer(args.remove):
            print(f"Removed device: {args.remove}")
        else:
            print(f"Device not found: {args.remove}", file=sys.stderr)
    elif args.trust:
        if service.trust_device(args.trust):
            print(f"Device trusted: {args.trust}")
        else:
            print(f"Device not found: {args.trust}", file=sys.stderr)
    elif args.untrust:
        if service.untrust_device(args.untrust):
            print(f"Device untrusted: {args.untrust}")
        else:
            print(f"Device not found: {args.untrust}", file=sys.stderr)
    elif args.send_file:
        if service.send_file_to_peer(args.send_file[0], args.send_file[1]):
            print("File transfer started")
        else:
            print("Failed to start file transfer", file=sys.stderr)
            sys.exit(1)
    elif args.gaming:
        if service.set_gaming_mode(args.gaming):
            print(f"Gaming mode set to: {args.gaming}")
        else:
            print("Failed to set gaming mode", file=sys.stderr)
    elif args.refresh:
        service.refresh_peer_status()
        print("Peer status refreshed")
    elif args.gui or (not any([args.status, args.start, args.stop, args.discover, 
                                args.add, args.list, args.remove, args.trust, 
                                args.untrust, args.send_file, args.gaming, args.refresh])):
        if TKINTER_AVAILABLE:
            gui = DesktopLinkGUI(service)
            gui.run()
        else:
            print("GUI mode requires tkinter. Use --help for CLI options.")
            sys.exit(1)


if __name__ == "__main__":
    main()
