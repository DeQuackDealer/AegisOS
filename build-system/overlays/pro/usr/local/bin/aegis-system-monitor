#!/usr/bin/env python3
"""
Aegis System Monitor v1.0.0
Real-time system monitoring and process management

Features:
  - Real-time CPU, memory, disk usage
  - Process manager with kill/priority
  - Network traffic monitoring
  - Disk I/O tracking
  - Temperature monitoring
  - GPU stats (NVIDIA/AMD)
  - System load graphs
  - Resource alerts

Copyright (c) 2024 Aegis OS Team
License: GPL-3.0
"""

import os
import sys
import json
import subprocess
import argparse
import time
import threading
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field, asdict

try:
    import tkinter as tk
    from tkinter import ttk, messagebox
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

VERSION = "1.0.0"
APP_NAME = "Aegis System Monitor"
CONFIG_DIR = Path.home() / ".config" / "aegis" / "system-monitor"
CONFIG_FILE = CONFIG_DIR / "config.json"
TIER_FILE = Path("/etc/aegis/tier")


@dataclass
class SystemMonitorConfig:
    """Main configuration"""
    update_interval_ms: int = 1000
    show_all_processes: bool = False
    cpu_alert_threshold: int = 90
    memory_alert_threshold: int = 90
    disk_alert_threshold: int = 90
    temp_alert_threshold: int = 80
    graph_history_points: int = 60


@dataclass
class ProcessInfo:
    """Process information"""
    pid: int
    name: str
    user: str
    cpu_percent: float
    memory_percent: float
    memory_mb: float
    status: str
    command: str = ""


@dataclass
class NetworkInterface:
    """Network interface stats"""
    name: str
    bytes_sent: int
    bytes_recv: int
    packets_sent: int
    packets_recv: int
    ip_address: str = ""


@dataclass
class DiskInfo:
    """Disk information"""
    device: str
    mountpoint: str
    total_gb: float
    used_gb: float
    free_gb: float
    percent_used: float
    read_bytes: int = 0
    write_bytes: int = 0


class SystemMonitorService:
    """Core System Monitor service"""
    
    def __init__(self):
        self.config = self._load_config()
        self.cpu_history: List[float] = []
        self.memory_history: List[float] = []
        self.net_history: List[Tuple[int, int]] = []
        self.tier = self._get_tier()
    
    def _get_tier(self) -> str:
        if TIER_FILE.exists():
            try:
                return TIER_FILE.read_text().strip()
            except:
                pass
        return "pro"
    
    def _load_config(self) -> SystemMonitorConfig:
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE, 'r') as f:
                    data = json.load(f)
                    return SystemMonitorConfig(**data)
            except Exception:
                pass
        
        config = SystemMonitorConfig()
        self._save_config(config)
        return config
    
    def _save_config(self, config: SystemMonitorConfig = None):
        if config:
            self.config = config
        with open(CONFIG_FILE, 'w') as f:
            json.dump(asdict(self.config), f, indent=2)
    
    def get_cpu_info(self) -> Dict:
        cpu_percent = 0.0
        cpu_count = os.cpu_count() or 1
        per_cpu = []
        load_avg = (0.0, 0.0, 0.0)
        
        try:
            with open('/proc/stat', 'r') as f:
                lines = f.readlines()
                cpu_line = lines[0].split()
                total = sum(int(x) for x in cpu_line[1:])
                idle = int(cpu_line[4])
                cpu_percent = 100.0 * (1 - idle / total) if total > 0 else 0.0
                
                for i in range(cpu_count):
                    if i + 1 < len(lines):
                        line = lines[i + 1].split()
                        if line[0].startswith('cpu'):
                            t = sum(int(x) for x in line[1:])
                            i_val = int(line[4])
                            per_cpu.append(100.0 * (1 - i_val / t) if t > 0 else 0.0)
        except:
            pass
        
        try:
            load_avg = os.getloadavg()
        except:
            pass
        
        try:
            freq_path = Path('/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq')
            if freq_path.exists():
                freq_mhz = int(freq_path.read_text().strip()) / 1000
            else:
                freq_mhz = 0
        except:
            freq_mhz = 0
        
        self.cpu_history.append(cpu_percent)
        if len(self.cpu_history) > self.config.graph_history_points:
            self.cpu_history.pop(0)
        
        return {
            "percent": round(cpu_percent, 1),
            "count": cpu_count,
            "per_cpu": [round(p, 1) for p in per_cpu],
            "load_avg": [round(l, 2) for l in load_avg],
            "frequency_mhz": round(freq_mhz, 0),
            "history": self.cpu_history[-30:]
        }
    
    def get_memory_info(self) -> Dict:
        total = 0
        available = 0
        used = 0
        cached = 0
        buffers = 0
        swap_total = 0
        swap_used = 0
        
        try:
            with open('/proc/meminfo', 'r') as f:
                for line in f:
                    parts = line.split()
                    key = parts[0].rstrip(':')
                    value = int(parts[1]) * 1024
                    
                    if key == 'MemTotal':
                        total = value
                    elif key == 'MemAvailable':
                        available = value
                    elif key == 'Buffers':
                        buffers = value
                    elif key == 'Cached':
                        cached = value
                    elif key == 'SwapTotal':
                        swap_total = value
                    elif key == 'SwapFree':
                        swap_used = swap_total - value
            
            used = total - available
        except:
            pass
        
        percent = (used / total * 100) if total > 0 else 0
        
        self.memory_history.append(percent)
        if len(self.memory_history) > self.config.graph_history_points:
            self.memory_history.pop(0)
        
        return {
            "total_gb": round(total / (1024**3), 2),
            "used_gb": round(used / (1024**3), 2),
            "available_gb": round(available / (1024**3), 2),
            "cached_gb": round(cached / (1024**3), 2),
            "buffers_gb": round(buffers / (1024**3), 2),
            "percent": round(percent, 1),
            "swap_total_gb": round(swap_total / (1024**3), 2),
            "swap_used_gb": round(swap_used / (1024**3), 2),
            "swap_percent": round((swap_used / swap_total * 100) if swap_total > 0 else 0, 1),
            "history": self.memory_history[-30:]
        }
    
    def get_disk_info(self) -> List[Dict]:
        disks = []
        
        try:
            result = subprocess.run(['df', '-B1'], capture_output=True, text=True, timeout=5)
            lines = result.stdout.strip().split('\n')[1:]
            
            for line in lines:
                parts = line.split()
                if len(parts) >= 6:
                    device = parts[0]
                    if not device.startswith('/dev/'):
                        continue
                    
                    total = int(parts[1])
                    used = int(parts[2])
                    free = int(parts[3])
                    percent = int(parts[4].rstrip('%'))
                    mountpoint = parts[5]
                    
                    disks.append({
                        "device": device,
                        "mountpoint": mountpoint,
                        "total_gb": round(total / (1024**3), 2),
                        "used_gb": round(used / (1024**3), 2),
                        "free_gb": round(free / (1024**3), 2),
                        "percent": percent
                    })
        except:
            pass
        
        return disks
    
    def get_network_info(self) -> List[Dict]:
        interfaces = []
        
        try:
            with open('/proc/net/dev', 'r') as f:
                lines = f.readlines()[2:]
                
                for line in lines:
                    parts = line.split()
                    if len(parts) >= 10:
                        name = parts[0].rstrip(':')
                        if name == 'lo':
                            continue
                        
                        bytes_recv = int(parts[1])
                        packets_recv = int(parts[2])
                        bytes_sent = int(parts[9])
                        packets_sent = int(parts[10])
                        
                        ip_addr = ""
                        try:
                            result = subprocess.run(
                                ['ip', '-4', 'addr', 'show', name],
                                capture_output=True, text=True, timeout=2
                            )
                            for ln in result.stdout.split('\n'):
                                if 'inet ' in ln:
                                    ip_addr = ln.split()[1].split('/')[0]
                                    break
                        except:
                            pass
                        
                        interfaces.append({
                            "name": name,
                            "bytes_sent": bytes_sent,
                            "bytes_recv": bytes_recv,
                            "packets_sent": packets_sent,
                            "packets_recv": packets_recv,
                            "ip_address": ip_addr
                        })
        except:
            pass
        
        return interfaces
    
    def get_temperature_info(self) -> List[Dict]:
        temps = []
        
        hwmon_path = Path('/sys/class/hwmon')
        if hwmon_path.exists():
            for hwmon in hwmon_path.iterdir():
                try:
                    name_file = hwmon / 'name'
                    if name_file.exists():
                        sensor_name = name_file.read_text().strip()
                    else:
                        sensor_name = hwmon.name
                    
                    for temp_file in hwmon.glob('temp*_input'):
                        temp_c = int(temp_file.read_text().strip()) / 1000
                        
                        label_file = temp_file.parent / temp_file.name.replace('_input', '_label')
                        if label_file.exists():
                            label = label_file.read_text().strip()
                        else:
                            label = temp_file.name.replace('_input', '')
                        
                        temps.append({
                            "sensor": sensor_name,
                            "label": label,
                            "temperature_c": round(temp_c, 1)
                        })
                except:
                    pass
        
        return temps
    
    def get_processes(self, sort_by: str = "cpu", limit: int = 50) -> List[Dict]:
        processes = []
        
        try:
            result = subprocess.run(
                ['ps', 'aux', '--sort=-%cpu'],
                capture_output=True, text=True, timeout=5
            )
            lines = result.stdout.strip().split('\n')[1:]
            
            for line in lines[:limit * 2]:
                parts = line.split(None, 10)
                if len(parts) >= 11:
                    try:
                        processes.append({
                            "pid": int(parts[1]),
                            "user": parts[0],
                            "cpu_percent": float(parts[2]),
                            "memory_percent": float(parts[3]),
                            "memory_mb": float(parts[5]) / 1024,
                            "status": parts[7],
                            "name": parts[10].split()[0] if parts[10] else "",
                            "command": parts[10]
                        })
                    except:
                        pass
            
            if sort_by == "memory":
                processes.sort(key=lambda p: p['memory_percent'], reverse=True)
            elif sort_by == "pid":
                processes.sort(key=lambda p: p['pid'])
            elif sort_by == "name":
                processes.sort(key=lambda p: p['name'].lower())
            
        except:
            pass
        
        return processes[:limit]
    
    def kill_process(self, pid: int, force: bool = False) -> bool:
        try:
            sig = '-9' if force else '-15'
            result = subprocess.run(['kill', sig, str(pid)], capture_output=True)
            return result.returncode == 0
        except:
            return False
    
    def change_priority(self, pid: int, priority: int) -> bool:
        try:
            result = subprocess.run(['renice', str(priority), '-p', str(pid)], capture_output=True)
            return result.returncode == 0
        except:
            return False
    
    def get_gpu_info(self) -> Dict:
        gpu_info = {"available": False}
        
        if Path('/usr/bin/nvidia-smi').exists():
            try:
                result = subprocess.run(
                    ['nvidia-smi', '--query-gpu=name,temperature.gpu,utilization.gpu,memory.used,memory.total', 
                     '--format=csv,noheader,nounits'],
                    capture_output=True, text=True, timeout=5
                )
                if result.returncode == 0:
                    parts = result.stdout.strip().split(', ')
                    if len(parts) >= 5:
                        gpu_info = {
                            "available": True,
                            "type": "nvidia",
                            "name": parts[0],
                            "temperature_c": int(parts[1]),
                            "utilization_percent": int(parts[2]),
                            "memory_used_mb": int(parts[3]),
                            "memory_total_mb": int(parts[4])
                        }
            except:
                pass
        
        if not gpu_info["available"]:
            amd_path = Path('/sys/class/drm/card0/device')
            if amd_path.exists():
                try:
                    gpu_info = {
                        "available": True,
                        "type": "amd",
                        "name": "AMD GPU"
                    }
                    
                    temp_file = amd_path / 'hwmon' / 'hwmon0' / 'temp1_input'
                    if temp_file.exists():
                        gpu_info["temperature_c"] = int(temp_file.read_text().strip()) / 1000
                except:
                    pass
        
        return gpu_info
    
    def get_uptime(self) -> Dict:
        try:
            with open('/proc/uptime', 'r') as f:
                uptime_seconds = float(f.read().split()[0])
            
            days = int(uptime_seconds // 86400)
            hours = int((uptime_seconds % 86400) // 3600)
            minutes = int((uptime_seconds % 3600) // 60)
            
            return {
                "seconds": int(uptime_seconds),
                "days": days,
                "hours": hours,
                "minutes": minutes,
                "formatted": f"{days}d {hours}h {minutes}m"
            }
        except:
            return {"seconds": 0, "days": 0, "hours": 0, "minutes": 0, "formatted": "unknown"}
    
    def get_status(self) -> Dict:
        return {
            "version": VERSION,
            "tier": self.tier,
            "cpu": self.get_cpu_info(),
            "memory": self.get_memory_info(),
            "disks": self.get_disk_info(),
            "network": self.get_network_info(),
            "temperatures": self.get_temperature_info(),
            "gpu": self.get_gpu_info(),
            "uptime": self.get_uptime(),
            "process_count": len(self.get_processes(limit=1000))
        }


class SystemMonitorGUI:
    """GUI for System Monitor"""
    
    def __init__(self, service: SystemMonitorService):
        self.service = service
        self.root = None
        self.running = True
    
    def run(self):
        if not TKINTER_AVAILABLE:
            print("Error: Tkinter not available")
            sys.exit(1)
        
        self.root = tk.Tk()
        self.root.title(f"{APP_NAME} v{VERSION}")
        self.root.geometry("1000x750")
        self.root.configure(bg='#0d1117')
        
        style = ttk.Style()
        style.theme_use('clam')
        style.configure('TFrame', background='#0d1117')
        style.configure('TLabel', background='#0d1117', foreground='#c9d1d9')
        style.configure('Header.TLabel', font=('Segoe UI', 16, 'bold'), foreground='#58a6ff')
        style.configure('Stat.TLabel', font=('Segoe UI', 24, 'bold'))
        style.configure('TNotebook', background='#0d1117')
        style.configure('TButton', padding=6)
        style.configure("green.Horizontal.TProgressbar", troughcolor='#21262d', background='#3fb950')
        style.configure("yellow.Horizontal.TProgressbar", troughcolor='#21262d', background='#d29922')
        style.configure("red.Horizontal.TProgressbar", troughcolor='#21262d', background='#f85149')
        
        self._create_widgets()
        self._start_update_thread()
        
        self.root.protocol("WM_DELETE_WINDOW", self._on_close)
        self.root.mainloop()
    
    def _on_close(self):
        self.running = False
        self.root.destroy()
    
    def _create_widgets(self):
        main = ttk.Frame(self.root, padding=15)
        main.pack(fill=tk.BOTH, expand=True)
        
        header = ttk.Frame(main)
        header.pack(fill=tk.X, pady=(0, 15))
        
        ttk.Label(header, text="ðŸ“Š Aegis System Monitor", style='Header.TLabel').pack(side=tk.LEFT)
        
        self.uptime_label = ttk.Label(header, text="Uptime: --", foreground='#8b949e')
        self.uptime_label.pack(side=tk.RIGHT)
        
        overview_frame = ttk.Frame(main)
        overview_frame.pack(fill=tk.X, pady=(0, 15))
        
        self.cpu_frame = self._create_stat_card(overview_frame, "CPU", "0%")
        self.cpu_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        self.mem_frame = self._create_stat_card(overview_frame, "Memory", "0%")
        self.mem_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        self.disk_frame = self._create_stat_card(overview_frame, "Disk", "0%")
        self.disk_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        self.temp_frame = self._create_stat_card(overview_frame, "Temp", "-- Â°C")
        self.temp_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        notebook = ttk.Notebook(main)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        processes_frame = ttk.Frame(notebook, padding=10)
        notebook.add(processes_frame, text="Processes")
        
        proc_toolbar = ttk.Frame(processes_frame)
        proc_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(proc_toolbar, text="Sort by:").pack(side=tk.LEFT)
        self.sort_var = tk.StringVar(value="cpu")
        sort_combo = ttk.Combobox(proc_toolbar, textvariable=self.sort_var,
                                  values=["cpu", "memory", "pid", "name"], width=10)
        sort_combo.pack(side=tk.LEFT, padx=5)
        sort_combo.bind('<<ComboboxSelected>>', lambda e: self._refresh_processes())
        
        ttk.Button(proc_toolbar, text="Kill Process", 
                  command=self._kill_selected).pack(side=tk.RIGHT)
        ttk.Button(proc_toolbar, text="Force Kill", 
                  command=lambda: self._kill_selected(force=True)).pack(side=tk.RIGHT, padx=5)
        
        columns = ('pid', 'name', 'user', 'cpu', 'memory', 'status')
        self.proc_tree = ttk.Treeview(processes_frame, columns=columns, show='headings', height=18)
        
        self.proc_tree.heading('pid', text='PID')
        self.proc_tree.heading('name', text='Name')
        self.proc_tree.heading('user', text='User')
        self.proc_tree.heading('cpu', text='CPU %')
        self.proc_tree.heading('memory', text='Memory %')
        self.proc_tree.heading('status', text='Status')
        
        self.proc_tree.column('pid', width=70)
        self.proc_tree.column('name', width=200)
        self.proc_tree.column('user', width=100)
        self.proc_tree.column('cpu', width=80)
        self.proc_tree.column('memory', width=80)
        self.proc_tree.column('status', width=80)
        
        proc_scroll = ttk.Scrollbar(processes_frame, orient=tk.VERTICAL, command=self.proc_tree.yview)
        self.proc_tree.configure(yscrollcommand=proc_scroll.set)
        
        self.proc_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        proc_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        network_frame = ttk.Frame(notebook, padding=10)
        notebook.add(network_frame, text="Network")
        
        net_columns = ('interface', 'ip', 'sent', 'received')
        self.net_tree = ttk.Treeview(network_frame, columns=net_columns, show='headings', height=10)
        
        self.net_tree.heading('interface', text='Interface')
        self.net_tree.heading('ip', text='IP Address')
        self.net_tree.heading('sent', text='Sent')
        self.net_tree.heading('received', text='Received')
        
        self.net_tree.pack(fill=tk.BOTH, expand=True)
        
        disks_frame = ttk.Frame(notebook, padding=10)
        notebook.add(disks_frame, text="Disks")
        
        disk_columns = ('device', 'mount', 'total', 'used', 'free', 'percent')
        self.disk_tree = ttk.Treeview(disks_frame, columns=disk_columns, show='headings', height=10)
        
        self.disk_tree.heading('device', text='Device')
        self.disk_tree.heading('mount', text='Mount Point')
        self.disk_tree.heading('total', text='Total')
        self.disk_tree.heading('used', text='Used')
        self.disk_tree.heading('free', text='Free')
        self.disk_tree.heading('percent', text='Usage')
        
        self.disk_tree.pack(fill=tk.BOTH, expand=True)
        
        temps_frame = ttk.Frame(notebook, padding=10)
        notebook.add(temps_frame, text="Temperatures")
        
        temp_columns = ('sensor', 'label', 'temp')
        self.temp_tree = ttk.Treeview(temps_frame, columns=temp_columns, show='headings', height=10)
        
        self.temp_tree.heading('sensor', text='Sensor')
        self.temp_tree.heading('label', text='Label')
        self.temp_tree.heading('temp', text='Temperature')
        
        self.temp_tree.pack(fill=tk.BOTH, expand=True)
        
        gpu_frame = ttk.Frame(notebook, padding=10)
        notebook.add(gpu_frame, text="GPU")
        
        self.gpu_info_frame = ttk.Frame(gpu_frame)
        self.gpu_info_frame.pack(fill=tk.X, pady=10)
        
        self.gpu_labels = {}
        for label in ["Name", "Temperature", "Utilization", "Memory"]:
            row = ttk.Frame(self.gpu_info_frame)
            row.pack(fill=tk.X, pady=5)
            ttk.Label(row, text=f"{label}:", width=15).pack(side=tk.LEFT)
            self.gpu_labels[label.lower()] = ttk.Label(row, text="--")
            self.gpu_labels[label.lower()].pack(side=tk.LEFT)
    
    def _create_stat_card(self, parent, title: str, value: str) -> ttk.Frame:
        frame = ttk.Frame(parent)
        frame.configure(style='TFrame')
        
        inner = tk.Frame(frame, bg='#21262d', padx=15, pady=10)
        inner.pack(fill=tk.BOTH, expand=True)
        
        tk.Label(inner, text=title, bg='#21262d', fg='#8b949e', 
                font=('Segoe UI', 10)).pack(anchor=tk.W)
        
        value_label = tk.Label(inner, text=value, bg='#21262d', fg='#c9d1d9', 
                              font=('Segoe UI', 20, 'bold'))
        value_label.pack(anchor=tk.W)
        
        progress = ttk.Progressbar(inner, length=150, mode='determinate', 
                                   style='green.Horizontal.TProgressbar')
        progress.pack(fill=tk.X, pady=(5, 0))
        
        frame.value_label = value_label
        frame.progress = progress
        
        return frame
    
    def _start_update_thread(self):
        def update():
            while self.running:
                try:
                    self.root.after(0, self._update_display)
                except:
                    break
                time.sleep(self.service.config.update_interval_ms / 1000)
        
        thread = threading.Thread(target=update, daemon=True)
        thread.start()
    
    def _update_display(self):
        try:
            cpu = self.service.get_cpu_info()
            self.cpu_frame.value_label.configure(text=f"{cpu['percent']}%")
            self.cpu_frame.progress['value'] = cpu['percent']
            self._update_progress_color(self.cpu_frame.progress, cpu['percent'])
            
            mem = self.service.get_memory_info()
            self.mem_frame.value_label.configure(text=f"{mem['percent']}%")
            self.mem_frame.progress['value'] = mem['percent']
            self._update_progress_color(self.mem_frame.progress, mem['percent'])
            
            disks = self.service.get_disk_info()
            if disks:
                root_disk = next((d for d in disks if d['mountpoint'] == '/'), disks[0])
                self.disk_frame.value_label.configure(text=f"{root_disk['percent']}%")
                self.disk_frame.progress['value'] = root_disk['percent']
                self._update_progress_color(self.disk_frame.progress, root_disk['percent'])
            
            temps = self.service.get_temperature_info()
            if temps:
                cpu_temp = next((t for t in temps if 'cpu' in t['label'].lower() or 
                               'core' in t['label'].lower() or 'package' in t['label'].lower()), 
                              temps[0])
                self.temp_frame.value_label.configure(text=f"{cpu_temp['temperature_c']}Â°C")
                temp_pct = min(100, cpu_temp['temperature_c'] / 100 * 100)
                self.temp_frame.progress['value'] = temp_pct
                self._update_progress_color(self.temp_frame.progress, temp_pct)
            
            uptime = self.service.get_uptime()
            self.uptime_label.configure(text=f"Uptime: {uptime['formatted']}")
            
            self._refresh_network()
            self._refresh_disks()
            self._refresh_temps()
            self._refresh_gpu()
            self._refresh_processes()
        except Exception as e:
            pass
    
    def _update_progress_color(self, progress: ttk.Progressbar, value: float):
        if value >= 90:
            progress.configure(style='red.Horizontal.TProgressbar')
        elif value >= 70:
            progress.configure(style='yellow.Horizontal.TProgressbar')
        else:
            progress.configure(style='green.Horizontal.TProgressbar')
    
    def _refresh_processes(self):
        for item in self.proc_tree.get_children():
            self.proc_tree.delete(item)
        
        processes = self.service.get_processes(sort_by=self.sort_var.get())
        for proc in processes[:50]:
            self.proc_tree.insert('', tk.END, values=(
                proc['pid'], proc['name'][:30], proc['user'],
                f"{proc['cpu_percent']:.1f}", f"{proc['memory_percent']:.1f}",
                proc['status']
            ))
    
    def _refresh_network(self):
        for item in self.net_tree.get_children():
            self.net_tree.delete(item)
        
        interfaces = self.service.get_network_info()
        for iface in interfaces:
            sent_mb = iface['bytes_sent'] / (1024**2)
            recv_mb = iface['bytes_recv'] / (1024**2)
            self.net_tree.insert('', tk.END, values=(
                iface['name'], iface['ip_address'],
                f"{sent_mb:.1f} MB", f"{recv_mb:.1f} MB"
            ))
    
    def _refresh_disks(self):
        for item in self.disk_tree.get_children():
            self.disk_tree.delete(item)
        
        disks = self.service.get_disk_info()
        for disk in disks:
            self.disk_tree.insert('', tk.END, values=(
                disk['device'], disk['mountpoint'],
                f"{disk['total_gb']:.1f} GB", f"{disk['used_gb']:.1f} GB",
                f"{disk['free_gb']:.1f} GB", f"{disk['percent']}%"
            ))
    
    def _refresh_temps(self):
        for item in self.temp_tree.get_children():
            self.temp_tree.delete(item)
        
        temps = self.service.get_temperature_info()
        for temp in temps:
            self.temp_tree.insert('', tk.END, values=(
                temp['sensor'], temp['label'], f"{temp['temperature_c']}Â°C"
            ))
    
    def _refresh_gpu(self):
        gpu = self.service.get_gpu_info()
        if gpu['available']:
            self.gpu_labels['name'].configure(text=gpu.get('name', 'Unknown'))
            self.gpu_labels['temperature'].configure(text=f"{gpu.get('temperature_c', '--')}Â°C")
            self.gpu_labels['utilization'].configure(text=f"{gpu.get('utilization_percent', '--')}%")
            mem_used = gpu.get('memory_used_mb', 0)
            mem_total = gpu.get('memory_total_mb', 1)
            self.gpu_labels['memory'].configure(text=f"{mem_used} / {mem_total} MB")
        else:
            for label in self.gpu_labels.values():
                label.configure(text="Not available")
    
    def _kill_selected(self, force: bool = False):
        selection = self.proc_tree.selection()
        if not selection:
            return
        
        item = self.proc_tree.item(selection[0])
        pid = item['values'][0]
        name = item['values'][1]
        
        if messagebox.askyesno("Confirm", f"Kill process '{name}' (PID: {pid})?"):
            if self.service.kill_process(pid, force):
                self._refresh_processes()
            else:
                messagebox.showerror("Error", "Failed to kill process")


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - System monitoring tool")
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--status', action='store_true', help='Show status as JSON')
    parser.add_argument('--cpu', action='store_true', help='Show CPU info')
    parser.add_argument('--memory', action='store_true', help='Show memory info')
    parser.add_argument('--disk', action='store_true', help='Show disk info')
    parser.add_argument('--network', action='store_true', help='Show network info')
    parser.add_argument('--temp', action='store_true', help='Show temperature info')
    parser.add_argument('--gpu', action='store_true', help='Show GPU info')
    parser.add_argument('--processes', action='store_true', help='Show top processes')
    parser.add_argument('--kill', type=int, metavar='PID', help='Kill process by PID')
    parser.add_argument('--force', action='store_true', help='Force kill (SIGKILL)')
    parser.add_argument('--uptime', action='store_true', help='Show uptime')
    parser.add_argument('--watch', action='store_true', help='Continuous monitoring')
    parser.add_argument('--version', action='version', version=f'{APP_NAME} v{VERSION}')
    
    args = parser.parse_args()
    service = SystemMonitorService()
    
    if args.status:
        print(json.dumps(service.get_status(), indent=2))
    elif args.cpu:
        info = service.get_cpu_info()
        print(f"CPU: {info['percent']}%")
        print(f"Cores: {info['count']}")
        print(f"Load: {info['load_avg']}")
        print(f"Frequency: {info['frequency_mhz']} MHz")
    elif args.memory:
        info = service.get_memory_info()
        print(f"Memory: {info['used_gb']:.1f} / {info['total_gb']:.1f} GB ({info['percent']}%)")
        print(f"Swap: {info['swap_used_gb']:.1f} / {info['swap_total_gb']:.1f} GB")
    elif args.disk:
        for disk in service.get_disk_info():
            print(f"{disk['device']} ({disk['mountpoint']}): {disk['used_gb']:.1f}/{disk['total_gb']:.1f} GB ({disk['percent']}%)")
    elif args.network:
        for iface in service.get_network_info():
            print(f"{iface['name']} ({iface['ip_address']}): TX {iface['bytes_sent']/(1024**2):.1f} MB, RX {iface['bytes_recv']/(1024**2):.1f} MB")
    elif args.temp:
        for temp in service.get_temperature_info():
            print(f"{temp['sensor']} {temp['label']}: {temp['temperature_c']}Â°C")
    elif args.gpu:
        gpu = service.get_gpu_info()
        if gpu['available']:
            print(f"GPU: {gpu.get('name', 'Unknown')}")
            print(f"Temperature: {gpu.get('temperature_c', '--')}Â°C")
            print(f"Utilization: {gpu.get('utilization_percent', '--')}%")
        else:
            print("No GPU detected")
    elif args.processes:
        print(f"{'PID':<8} {'CPU%':<8} {'MEM%':<8} {'NAME':<20}")
        for proc in service.get_processes(limit=20):
            print(f"{proc['pid']:<8} {proc['cpu_percent']:<8.1f} {proc['memory_percent']:<8.1f} {proc['name'][:20]}")
    elif args.kill:
        if service.kill_process(args.kill, args.force):
            print(f"Killed process {args.kill}")
        else:
            print(f"Failed to kill process {args.kill}", file=sys.stderr)
            sys.exit(1)
    elif args.uptime:
        uptime = service.get_uptime()
        print(f"Uptime: {uptime['formatted']}")
    elif args.watch:
        try:
            while True:
                os.system('clear')
                cpu = service.get_cpu_info()
                mem = service.get_memory_info()
                print(f"CPU: {cpu['percent']:5.1f}%  |  Memory: {mem['percent']:5.1f}%  |  Load: {cpu['load_avg']}")
                print("-" * 60)
                print(f"{'PID':<8} {'CPU%':<8} {'MEM%':<8} {'NAME':<30}")
                for proc in service.get_processes(limit=15):
                    print(f"{proc['pid']:<8} {proc['cpu_percent']:<8.1f} {proc['memory_percent']:<8.1f} {proc['name'][:30]}")
                time.sleep(2)
        except KeyboardInterrupt:
            pass
    elif args.gui or not any([args.status, args.cpu, args.memory, args.disk, args.network,
                               args.temp, args.gpu, args.processes, args.kill, args.uptime, args.watch]):
        if TKINTER_AVAILABLE:
            gui = SystemMonitorGUI(service)
            gui.run()
        else:
            print("GUI requires tkinter. Use --help for CLI options.")
            sys.exit(1)


if __name__ == "__main__":
    main()
