#!/usr/bin/env python3
"""
Aegis Cloud Sync v1.0.0
Unified cloud storage management

Features:
  - Nextcloud, Google Drive, OneDrive, Dropbox integration
  - Sync status dashboard
  - Conflict resolution
  - Bandwidth management
  - Selective sync
  - File versioning
  - Encryption support

Copyright (c) 2024 Aegis OS Team
License: GPL-3.0
"""

import os
import sys
import json
import subprocess
import argparse
import shutil
import threading
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field, asdict
from enum import Enum

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

VERSION = "1.0.0"
APP_NAME = "Aegis Cloud Sync"
CONFIG_DIR = Path.home() / ".config" / "aegis" / "cloud-sync"
CONFIG_FILE = CONFIG_DIR / "config.json"
ACCOUNTS_FILE = CONFIG_DIR / "accounts.json"
TIER_FILE = Path("/etc/aegis/tier")


class SyncStatus(Enum):
    IDLE = "idle"
    SYNCING = "syncing"
    ERROR = "error"
    PAUSED = "paused"


class ConflictResolution(Enum):
    KEEP_LOCAL = "keep_local"
    KEEP_REMOTE = "keep_remote"
    KEEP_BOTH = "keep_both"
    ASK = "ask"


@dataclass
class CloudProvider:
    """Represents a cloud provider"""
    id: str
    name: str
    icon: str
    cli_tool: str
    config_command: str
    installed: bool = False


@dataclass
class CloudAccount:
    """Represents a connected cloud account"""
    id: str
    provider: str
    name: str
    email: str = ""
    sync_folder: str = ""
    enabled: bool = True
    last_sync: str = ""
    status: str = "idle"
    bytes_synced: int = 0
    files_synced: int = 0
    selective_folders: List[str] = field(default_factory=list)


@dataclass
class SyncConflict:
    """Represents a sync conflict"""
    id: str
    account_id: str
    local_path: str
    remote_path: str
    local_modified: str
    remote_modified: str
    resolved: bool = False


@dataclass
class CloudSyncConfig:
    """Main configuration"""
    auto_sync: bool = True
    sync_interval_minutes: int = 15
    bandwidth_limit_kbps: int = 0
    conflict_resolution: str = "ask"
    encrypt_local: bool = False
    show_notifications: bool = True
    pause_on_metered: bool = True


CLOUD_PROVIDERS = [
    CloudProvider("nextcloud", "Nextcloud", "nextcloud", "nextcloudcmd", "nextcloud --logwindow"),
    CloudProvider("gdrive", "Google Drive", "google-drive", "rclone", "rclone config"),
    CloudProvider("onedrive", "OneDrive", "onedrive", "rclone", "rclone config"),
    CloudProvider("dropbox", "Dropbox", "dropbox", "dropbox-cli", "dropbox start -i"),
    CloudProvider("mega", "MEGA", "mega", "megacmd", "mega-login"),
    CloudProvider("pcloud", "pCloud", "pcloud", "pcloud", "pcloud"),
]


class CloudSyncService:
    """Core Cloud Sync service"""
    
    def __init__(self):
        self.config = self._load_config()
        self.providers = {p.id: p for p in CLOUD_PROVIDERS}
        self.accounts: Dict[str, CloudAccount] = {}
        self.conflicts: List[SyncConflict] = []
        self._check_installed_providers()
        self._load_accounts()
        self.tier = self._get_tier()
        self.sync_thread = None
        self.running = False
    
    def _get_tier(self) -> str:
        if TIER_FILE.exists():
            try:
                return TIER_FILE.read_text().strip()
            except:
                pass
        return "pro"
    
    def _load_config(self) -> CloudSyncConfig:
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE, 'r') as f:
                    data = json.load(f)
                    return CloudSyncConfig(**data)
            except Exception:
                pass
        
        config = CloudSyncConfig()
        self._save_config(config)
        return config
    
    def _save_config(self, config: CloudSyncConfig = None):
        if config:
            self.config = config
        with open(CONFIG_FILE, 'w') as f:
            json.dump(asdict(self.config), f, indent=2)
    
    def _load_accounts(self):
        if ACCOUNTS_FILE.exists():
            try:
                with open(ACCOUNTS_FILE, 'r') as f:
                    data = json.load(f)
                    for acc_id, acc_data in data.items():
                        self.accounts[acc_id] = CloudAccount(**acc_data)
            except Exception:
                pass
    
    def _save_accounts(self):
        with open(ACCOUNTS_FILE, 'w') as f:
            json.dump({k: asdict(v) for k, v in self.accounts.items()}, f, indent=2)
    
    def _check_installed_providers(self):
        for provider_id, provider in self.providers.items():
            provider.installed = shutil.which(provider.cli_tool) is not None
        
        if shutil.which("rclone"):
            self.providers["gdrive"].installed = True
            self.providers["onedrive"].installed = True
    
    def _check_rclone(self) -> Dict[str, Any]:
        """Verifies rclone is installed and returns version info"""
        result = {
            "installed": False,
            "version": None,
            "path": None,
            "error": None
        }
        
        rclone_path = shutil.which("rclone")
        if not rclone_path:
            result["error"] = "rclone is not installed or not in PATH"
            return result
        
        result["installed"] = True
        result["path"] = rclone_path
        
        try:
            proc = subprocess.run(
                ["rclone", "version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            if proc.returncode == 0:
                lines = proc.stdout.strip().split('\n')
                if lines:
                    version_line = lines[0]
                    if 'rclone' in version_line.lower():
                        result["version"] = version_line.split()[-1] if len(version_line.split()) > 1 else version_line
        except subprocess.TimeoutExpired:
            result["error"] = "rclone version check timed out"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _list_rclone_remotes(self) -> Dict[str, Any]:
        """Runs rclone listremotes to get configured providers"""
        result = {
            "success": False,
            "remotes": [],
            "error": None
        }
        
        rclone_check = self._check_rclone()
        if not rclone_check["installed"]:
            result["error"] = rclone_check["error"]
            return result
        
        try:
            proc = subprocess.run(
                ["rclone", "listremotes"],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if proc.returncode == 0:
                result["success"] = True
                remotes = proc.stdout.strip().split('\n')
                result["remotes"] = [r.rstrip(':') for r in remotes if r.strip()]
            else:
                result["error"] = proc.stderr.strip() or "Failed to list remotes"
        except subprocess.TimeoutExpired:
            result["error"] = "rclone listremotes timed out"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _configure_rclone_remote(self, remote_name: Optional[str] = None, provider_type: Optional[str] = None) -> Dict[str, Any]:
        """Opens rclone config for a new provider or interactive configuration"""
        result = {
            "success": False,
            "message": None,
            "error": None
        }
        
        rclone_check = self._check_rclone()
        if not rclone_check["installed"]:
            result["error"] = rclone_check["error"]
            return result
        
        try:
            if remote_name and provider_type:
                cmd = ["rclone", "config", "create", remote_name, provider_type]
                proc = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                if proc.returncode == 0:
                    result["success"] = True
                    result["message"] = f"Remote '{remote_name}' created with provider '{provider_type}'"
                else:
                    result["error"] = proc.stderr.strip() or "Failed to create remote"
            else:
                proc = subprocess.Popen(
                    ["rclone", "config"],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                result["success"] = True
                result["message"] = "rclone config launched interactively"
        except subprocess.TimeoutExpired:
            result["error"] = "rclone config timed out"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _sync_folder(self, remote_name: str, remote_path: str, local_path: str, 
                     bidirectional: bool = False, dry_run: bool = False,
                     bandwidth_limit: Optional[int] = None) -> Dict[str, Any]:
        """Runs rclone sync or rclone bisync for bidirectional sync"""
        result = {
            "success": False,
            "files_transferred": 0,
            "bytes_transferred": 0,
            "errors": 0,
            "output": None,
            "error": None
        }
        
        rclone_check = self._check_rclone()
        if not rclone_check["installed"]:
            result["error"] = rclone_check["error"]
            return result
        
        Path(local_path).mkdir(parents=True, exist_ok=True)
        
        remote_spec = f"{remote_name}:{remote_path}"
        
        if bidirectional:
            cmd = ["rclone", "bisync", remote_spec, local_path]
        else:
            cmd = ["rclone", "sync", remote_spec, local_path]
        
        cmd.extend(["--stats-one-line", "--stats", "0"])
        
        if dry_run:
            cmd.append("--dry-run")
        
        bw_limit = bandwidth_limit or self.config.bandwidth_limit_kbps
        if bw_limit > 0:
            cmd.extend(["--bwlimit", f"{bw_limit}k"])
        
        cmd.extend(["-v", "--use-json-log"])
        
        try:
            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=3600
            )
            
            result["output"] = proc.stdout + proc.stderr
            
            if proc.returncode == 0:
                result["success"] = True
                for line in proc.stderr.split('\n'):
                    if 'Transferred:' in line:
                        parts = line.split()
                        for i, part in enumerate(parts):
                            if part.isdigit():
                                if 'files' in line.lower():
                                    result["files_transferred"] = int(part)
                                else:
                                    result["bytes_transferred"] = int(part)
            else:
                result["error"] = proc.stderr.strip() or f"rclone exited with code {proc.returncode}"
                error_count = proc.stderr.count("ERROR")
                result["errors"] = error_count
        except subprocess.TimeoutExpired:
            result["error"] = "Sync operation timed out after 1 hour"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _get_sync_status(self) -> Dict[str, Any]:
        """Checks if a sync is running by looking for rclone processes"""
        result = {
            "syncing": False,
            "processes": [],
            "error": None
        }
        
        try:
            if sys.platform == "win32":
                cmd = ["tasklist", "/FI", "IMAGENAME eq rclone.exe", "/FO", "CSV"]
            else:
                cmd = ["pgrep", "-a", "rclone"]
            
            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if proc.returncode == 0 and proc.stdout.strip():
                lines = proc.stdout.strip().split('\n')
                
                if sys.platform == "win32":
                    for line in lines[1:]:
                        if 'rclone' in line.lower():
                            result["syncing"] = True
                            result["processes"].append({"raw": line})
                else:
                    for line in lines:
                        if line.strip():
                            parts = line.split(None, 1)
                            if len(parts) >= 2:
                                pid, cmdline = parts
                                if 'sync' in cmdline or 'bisync' in cmdline or 'copy' in cmdline:
                                    result["syncing"] = True
                                    result["processes"].append({
                                        "pid": int(pid),
                                        "command": cmdline
                                    })
        except subprocess.TimeoutExpired:
            result["error"] = "Process check timed out"
        except FileNotFoundError:
            try:
                proc = subprocess.run(
                    ["ps", "aux"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                if proc.returncode == 0:
                    for line in proc.stdout.split('\n'):
                        if 'rclone' in line and ('sync' in line or 'bisync' in line or 'copy' in line):
                            result["syncing"] = True
                            result["processes"].append({"raw": line})
            except Exception as e:
                result["error"] = f"Failed to check processes: {e}"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def get_installed_providers(self) -> List[CloudProvider]:
        return [p for p in self.providers.values() if p.installed]
    
    def add_account(self, provider_id: str, name: str, sync_folder: str = "") -> Optional[CloudAccount]:
        if provider_id not in self.providers:
            return None
        
        account_id = f"{provider_id}-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        if not sync_folder:
            sync_folder = str(Path.home() / "Cloud" / name)
        
        Path(sync_folder).mkdir(parents=True, exist_ok=True)
        
        account = CloudAccount(
            id=account_id,
            provider=provider_id,
            name=name,
            sync_folder=sync_folder,
            last_sync=datetime.now().isoformat()
        )
        
        self.accounts[account_id] = account
        self._save_accounts()
        return account
    
    def remove_account(self, account_id: str) -> bool:
        if account_id in self.accounts:
            del self.accounts[account_id]
            self._save_accounts()
            return True
        return False
    
    def configure_provider(self, provider_id: str) -> bool:
        if provider_id not in self.providers:
            return False
        
        provider = self.providers[provider_id]
        try:
            subprocess.Popen(
                provider.config_command.split(),
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
            )
            return True
        except Exception:
            return False
    
    def sync_account(self, account_id: str) -> bool:
        if account_id not in self.accounts:
            return False
        
        account = self.accounts[account_id]
        provider = self.providers.get(account.provider)
        
        if not provider or not provider.installed:
            return False
        
        account.status = "syncing"
        self._save_accounts()
        
        try:
            if provider.id == "nextcloud":
                cmd = ["nextcloudcmd", account.sync_folder, f"https://cloud.example.com/remote.php/dav/files/{account.name}"]
            elif provider.id in ["gdrive", "onedrive"]:
                cmd = ["rclone", "sync", f"{account.name}:", account.sync_folder, "--progress"]
            elif provider.id == "dropbox":
                cmd = ["dropbox-cli", "sync"]
            else:
                cmd = []
            
            if cmd:
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=3600)
                account.status = "idle" if result.returncode == 0 else "error"
            else:
                account.status = "idle"
            
            account.last_sync = datetime.now().isoformat()
            self._save_accounts()
            return account.status == "idle"
        except subprocess.TimeoutExpired:
            account.status = "error"
            self._save_accounts()
            return False
        except Exception:
            account.status = "error"
            self._save_accounts()
            return False
    
    def sync_all(self) -> Dict[str, bool]:
        results = {}
        for account_id, account in self.accounts.items():
            if account.enabled:
                results[account_id] = self.sync_account(account_id)
        return results
    
    def pause_sync(self, account_id: Optional[str] = None):
        if account_id:
            if account_id in self.accounts:
                self.accounts[account_id].status = "paused"
                self._save_accounts()
        else:
            for account in self.accounts.values():
                account.status = "paused"
            self._save_accounts()
    
    def resume_sync(self, account_id: Optional[str] = None):
        if account_id:
            if account_id in self.accounts:
                self.accounts[account_id].status = "idle"
                self._save_accounts()
        else:
            for account in self.accounts.values():
                account.status = "idle"
            self._save_accounts()
    
    def get_sync_stats(self) -> Dict:
        total_bytes = sum(a.bytes_synced for a in self.accounts.values())
        total_files = sum(a.files_synced for a in self.accounts.values())
        
        return {
            "accounts_count": len(self.accounts),
            "enabled_count": len([a for a in self.accounts.values() if a.enabled]),
            "syncing_count": len([a for a in self.accounts.values() if a.status == "syncing"]),
            "error_count": len([a for a in self.accounts.values() if a.status == "error"]),
            "total_bytes_synced": total_bytes,
            "total_files_synced": total_files,
            "conflicts_count": len([c for c in self.conflicts if not c.resolved])
        }
    
    def resolve_conflict(self, conflict_id: str, resolution: str) -> bool:
        for conflict in self.conflicts:
            if conflict.id == conflict_id:
                if resolution == "keep_local":
                    pass
                elif resolution == "keep_remote":
                    pass
                elif resolution == "keep_both":
                    pass
                conflict.resolved = True
                return True
        return False
    
    def set_bandwidth_limit(self, kbps: int):
        self.config.bandwidth_limit_kbps = kbps
        self._save_config()
    
    def get_status(self) -> Dict:
        return {
            "version": VERSION,
            "tier": self.tier,
            "auto_sync": self.config.auto_sync,
            "sync_interval": self.config.sync_interval_minutes,
            "bandwidth_limit": self.config.bandwidth_limit_kbps,
            "providers": [asdict(p) for p in self.providers.values()],
            "accounts": [asdict(a) for a in self.accounts.values()],
            "stats": self.get_sync_stats(),
            "conflicts": [asdict(c) for c in self.conflicts if not c.resolved]
        }


class CloudSyncGUI:
    """GUI for Cloud Sync"""
    
    def __init__(self, service: CloudSyncService):
        self.service = service
        self.root = None
    
    def run(self):
        if not TKINTER_AVAILABLE:
            print("Error: Tkinter not available")
            sys.exit(1)
        
        self.root = tk.Tk()
        self.root.title(f"{APP_NAME} v{VERSION}")
        self.root.geometry("950x700")
        self.root.configure(bg='#1e1e2e')
        
        style = ttk.Style()
        style.theme_use('clam')
        style.configure('TFrame', background='#1e1e2e')
        style.configure('TLabel', background='#1e1e2e', foreground='#cdd6f4')
        style.configure('Header.TLabel', font=('Segoe UI', 18, 'bold'), foreground='#89b4fa')
        style.configure('Status.TLabel', font=('Segoe UI', 10))
        style.configure('TButton', padding=8)
        style.configure('TNotebook', background='#1e1e2e')
        
        self._create_widgets()
        self._start_status_update()
        self.root.mainloop()
    
    def _create_widgets(self):
        main = ttk.Frame(self.root, padding=20)
        main.pack(fill=tk.BOTH, expand=True)
        
        header = ttk.Frame(main)
        header.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(header, text="☁️ Aegis Cloud Sync", style='Header.TLabel').pack(side=tk.LEFT)
        
        self.status_label = ttk.Label(header, text="Status: Idle", foreground='#a6e3a1')
        self.status_label.pack(side=tk.RIGHT)
        
        stats_frame = ttk.Frame(main)
        stats_frame.pack(fill=tk.X, pady=(0, 15))
        
        stats = self.service.get_sync_stats()
        
        self.stats_labels = {}
        for i, (label, key) in enumerate([
            ("Accounts", "accounts_count"),
            ("Syncing", "syncing_count"),
            ("Errors", "error_count"),
            ("Conflicts", "conflicts_count")
        ]):
            frame = ttk.Frame(stats_frame)
            frame.pack(side=tk.LEFT, padx=20)
            ttk.Label(frame, text=label, foreground='#6c7086').pack()
            self.stats_labels[key] = ttk.Label(frame, text=str(stats.get(key, 0)), 
                                               font=('Segoe UI', 16, 'bold'))
            self.stats_labels[key].pack()
        
        notebook = ttk.Notebook(main)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        accounts_frame = ttk.Frame(notebook, padding=15)
        notebook.add(accounts_frame, text="Accounts")
        
        toolbar = ttk.Frame(accounts_frame)
        toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(toolbar, text="+ Add Account", command=self._add_account_dialog).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="Sync All", command=self._sync_all).pack(side=tk.LEFT, padx=5)
        ttk.Button(toolbar, text="Pause All", command=self._pause_all).pack(side=tk.LEFT, padx=5)
        ttk.Button(toolbar, text="Resume All", command=self._resume_all).pack(side=tk.LEFT, padx=5)
        
        columns = ('name', 'provider', 'folder', 'status', 'last_sync')
        self.accounts_tree = ttk.Treeview(accounts_frame, columns=columns, show='headings', height=12)
        
        self.accounts_tree.heading('name', text='Account Name')
        self.accounts_tree.heading('provider', text='Provider')
        self.accounts_tree.heading('folder', text='Sync Folder')
        self.accounts_tree.heading('status', text='Status')
        self.accounts_tree.heading('last_sync', text='Last Sync')
        
        self.accounts_tree.column('name', width=150)
        self.accounts_tree.column('provider', width=100)
        self.accounts_tree.column('folder', width=250)
        self.accounts_tree.column('status', width=80)
        self.accounts_tree.column('last_sync', width=150)
        
        scrollbar = ttk.Scrollbar(accounts_frame, orient=tk.VERTICAL, command=self.accounts_tree.yview)
        self.accounts_tree.configure(yscrollcommand=scrollbar.set)
        
        self.accounts_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        providers_frame = ttk.Frame(notebook, padding=15)
        notebook.add(providers_frame, text="Providers")
        
        ttk.Label(providers_frame, text="Available Cloud Providers", 
                 font=('Segoe UI', 12, 'bold')).pack(anchor=tk.W, pady=(0, 10))
        
        for provider in self.service.providers.values():
            prov_frame = ttk.Frame(providers_frame)
            prov_frame.pack(fill=tk.X, pady=5)
            
            status = "✓ Installed" if provider.installed else "✗ Not Installed"
            color = '#a6e3a1' if provider.installed else '#f38ba8'
            
            ttk.Label(prov_frame, text=provider.name, font=('Segoe UI', 11)).pack(side=tk.LEFT)
            ttk.Label(prov_frame, text=status, foreground=color).pack(side=tk.LEFT, padx=20)
            
            if provider.installed:
                ttk.Button(prov_frame, text="Configure", 
                          command=lambda p=provider: self._configure_provider(p)).pack(side=tk.RIGHT)
        
        conflicts_frame = ttk.Frame(notebook, padding=15)
        notebook.add(conflicts_frame, text="Conflicts")
        
        if self.service.conflicts:
            for conflict in self.service.conflicts:
                if not conflict.resolved:
                    cf_frame = ttk.Frame(conflicts_frame)
                    cf_frame.pack(fill=tk.X, pady=5)
                    
                    ttk.Label(cf_frame, text=conflict.local_path).pack(side=tk.LEFT)
                    
                    ttk.Button(cf_frame, text="Keep Local", 
                              command=lambda c=conflict: self._resolve_conflict(c, "keep_local")).pack(side=tk.RIGHT)
                    ttk.Button(cf_frame, text="Keep Remote", 
                              command=lambda c=conflict: self._resolve_conflict(c, "keep_remote")).pack(side=tk.RIGHT, padx=5)
                    ttk.Button(cf_frame, text="Keep Both", 
                              command=lambda c=conflict: self._resolve_conflict(c, "keep_both")).pack(side=tk.RIGHT, padx=5)
        else:
            ttk.Label(conflicts_frame, text="No conflicts", foreground='#a6adc8').pack(pady=20)
        
        settings_frame = ttk.Frame(notebook, padding=15)
        notebook.add(settings_frame, text="Settings")
        
        self.auto_sync_var = tk.BooleanVar(value=self.service.config.auto_sync)
        ttk.Checkbutton(settings_frame, text="Enable automatic sync", 
                       variable=self.auto_sync_var).pack(anchor=tk.W, pady=5)
        
        interval_frame = ttk.Frame(settings_frame)
        interval_frame.pack(fill=tk.X, pady=10)
        ttk.Label(interval_frame, text="Sync interval (minutes):").pack(side=tk.LEFT)
        self.interval_var = tk.StringVar(value=str(self.service.config.sync_interval_minutes))
        ttk.Entry(interval_frame, textvariable=self.interval_var, width=10).pack(side=tk.LEFT, padx=10)
        
        bw_frame = ttk.Frame(settings_frame)
        bw_frame.pack(fill=tk.X, pady=10)
        ttk.Label(bw_frame, text="Bandwidth limit (KB/s, 0=unlimited):").pack(side=tk.LEFT)
        self.bw_var = tk.StringVar(value=str(self.service.config.bandwidth_limit_kbps))
        ttk.Entry(bw_frame, textvariable=self.bw_var, width=10).pack(side=tk.LEFT, padx=10)
        
        self.notify_var = tk.BooleanVar(value=self.service.config.show_notifications)
        ttk.Checkbutton(settings_frame, text="Show sync notifications", 
                       variable=self.notify_var).pack(anchor=tk.W, pady=5)
        
        self.metered_var = tk.BooleanVar(value=self.service.config.pause_on_metered)
        ttk.Checkbutton(settings_frame, text="Pause on metered connections", 
                       variable=self.metered_var).pack(anchor=tk.W, pady=5)
        
        ttk.Label(settings_frame, text="Conflict resolution:").pack(anchor=tk.W, pady=(10, 5))
        self.conflict_var = tk.StringVar(value=self.service.config.conflict_resolution)
        for opt in ["ask", "keep_local", "keep_remote", "keep_both"]:
            ttk.Radiobutton(settings_frame, text=opt.replace("_", " ").title(), 
                           variable=self.conflict_var, value=opt).pack(anchor=tk.W, padx=20)
        
        ttk.Button(settings_frame, text="Save Settings", 
                  command=self._save_settings).pack(anchor=tk.W, pady=15)
        
        self._refresh_accounts()
    
    def _refresh_accounts(self):
        for item in self.accounts_tree.get_children():
            self.accounts_tree.delete(item)
        
        for account in self.service.accounts.values():
            provider_name = self.service.providers.get(account.provider, 
                                                       CloudProvider("", "Unknown", "", "", "")).name
            last_sync = account.last_sync[:19] if account.last_sync else "Never"
            self.accounts_tree.insert('', tk.END, iid=account.id, values=(
                account.name, provider_name, account.sync_folder, account.status, last_sync
            ))
    
    def _refresh_stats(self):
        stats = self.service.get_sync_stats()
        for key, label in self.stats_labels.items():
            label.configure(text=str(stats.get(key, 0)))
    
    def _start_status_update(self):
        def update():
            while True:
                try:
                    self._refresh_stats()
                    self._refresh_accounts()
                except:
                    pass
                time.sleep(5)
        
        thread = threading.Thread(target=update, daemon=True)
        thread.start()
    
    def _add_account_dialog(self):
        dialog = tk.Toplevel(self.root)
        dialog.title("Add Cloud Account")
        dialog.geometry("450x300")
        dialog.configure(bg='#1e1e2e')
        dialog.transient(self.root)
        dialog.grab_set()
        
        frame = ttk.Frame(dialog, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(frame, text="Provider:").grid(row=0, column=0, sticky=tk.W, pady=5)
        installed = self.service.get_installed_providers()
        provider_combo = ttk.Combobox(frame, values=[p.name for p in installed], width=30)
        provider_combo.grid(row=0, column=1, pady=5)
        if installed:
            provider_combo.set(installed[0].name)
        
        ttk.Label(frame, text="Account Name:").grid(row=1, column=0, sticky=tk.W, pady=5)
        name_entry = ttk.Entry(frame, width=33)
        name_entry.grid(row=1, column=1, pady=5)
        
        ttk.Label(frame, text="Sync Folder:").grid(row=2, column=0, sticky=tk.W, pady=5)
        folder_frame = ttk.Frame(frame)
        folder_frame.grid(row=2, column=1, pady=5)
        folder_entry = ttk.Entry(folder_frame, width=25)
        folder_entry.pack(side=tk.LEFT)
        
        def browse():
            folder = filedialog.askdirectory()
            if folder:
                folder_entry.delete(0, tk.END)
                folder_entry.insert(0, folder)
        
        ttk.Button(folder_frame, text="...", command=browse, width=3).pack(side=tk.LEFT, padx=2)
        
        def add():
            provider_name = provider_combo.get()
            provider_id = next((p.id for p in self.service.providers.values() if p.name == provider_name), None)
            name = name_entry.get().strip()
            folder = folder_entry.get().strip()
            
            if provider_id and name:
                self.service.add_account(provider_id, name, folder)
                self._refresh_accounts()
                dialog.destroy()
            else:
                messagebox.showerror("Error", "Please fill required fields")
        
        ttk.Button(frame, text="Add Account", command=add).grid(row=3, column=1, pady=20)
    
    def _configure_provider(self, provider: CloudProvider):
        self.service.configure_provider(provider.id)
    
    def _sync_all(self):
        def do_sync():
            results = self.service.sync_all()
            success = sum(1 for v in results.values() if v)
            messagebox.showinfo("Sync Complete", f"Synced {success}/{len(results)} accounts")
            self._refresh_accounts()
        
        threading.Thread(target=do_sync, daemon=True).start()
    
    def _pause_all(self):
        self.service.pause_sync()
        self._refresh_accounts()
    
    def _resume_all(self):
        self.service.resume_sync()
        self._refresh_accounts()
    
    def _resolve_conflict(self, conflict: SyncConflict, resolution: str):
        self.service.resolve_conflict(conflict.id, resolution)
    
    def _save_settings(self):
        try:
            self.service.config.auto_sync = self.auto_sync_var.get()
            self.service.config.sync_interval_minutes = int(self.interval_var.get())
            self.service.config.bandwidth_limit_kbps = int(self.bw_var.get())
            self.service.config.show_notifications = self.notify_var.get()
            self.service.config.pause_on_metered = self.metered_var.get()
            self.service.config.conflict_resolution = self.conflict_var.get()
            self.service._save_config()
            messagebox.showinfo("Success", "Settings saved!")
        except ValueError:
            messagebox.showerror("Error", "Invalid number format")


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - Unified cloud storage management")
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--status', action='store_true', help='Show status as JSON')
    parser.add_argument('--list', action='store_true', help='List accounts')
    parser.add_argument('--providers', action='store_true', help='List available providers')
    parser.add_argument('--sync', metavar='ACCOUNT_ID', nargs='?', const='all', help='Sync account(s)')
    parser.add_argument('--pause', metavar='ACCOUNT_ID', nargs='?', const='all', help='Pause sync')
    parser.add_argument('--resume', metavar='ACCOUNT_ID', nargs='?', const='all', help='Resume sync')
    parser.add_argument('--add', nargs=2, metavar=('PROVIDER', 'NAME'), help='Add account')
    parser.add_argument('--remove', metavar='ACCOUNT_ID', help='Remove account')
    parser.add_argument('--stats', action='store_true', help='Show sync statistics')
    parser.add_argument('--bandwidth', metavar='KBPS', type=int, help='Set bandwidth limit')
    parser.add_argument('--version', action='version', version=f'{APP_NAME} v{VERSION}')
    
    args = parser.parse_args()
    service = CloudSyncService()
    
    if args.status:
        print(json.dumps(service.get_status(), indent=2))
    elif args.list:
        print("Cloud accounts:")
        for account in service.accounts.values():
            print(f"  [{account.id}] {account.name} ({account.provider}) - {account.status}")
    elif args.providers:
        print("Cloud providers:")
        for provider in service.providers.values():
            status = "✓" if provider.installed else "✗"
            print(f"  {status} [{provider.id}] {provider.name}")
    elif args.sync:
        if args.sync == 'all':
            results = service.sync_all()
            for acc_id, success in results.items():
                print(f"  {acc_id}: {'✓' if success else '✗'}")
        else:
            if service.sync_account(args.sync):
                print(f"Synced {args.sync}")
            else:
                print(f"Failed to sync {args.sync}", file=sys.stderr)
                sys.exit(1)
    elif args.pause:
        service.pause_sync(None if args.pause == 'all' else args.pause)
        print("Sync paused")
    elif args.resume:
        service.resume_sync(None if args.resume == 'all' else args.resume)
        print("Sync resumed")
    elif args.add:
        account = service.add_account(args.add[0], args.add[1])
        if account:
            print(f"Added account: {account.name}")
        else:
            print("Failed to add account", file=sys.stderr)
            sys.exit(1)
    elif args.remove:
        if service.remove_account(args.remove):
            print(f"Removed account: {args.remove}")
        else:
            print(f"Account not found: {args.remove}", file=sys.stderr)
    elif args.stats:
        stats = service.get_sync_stats()
        print("Sync statistics:")
        for key, value in stats.items():
            print(f"  {key}: {value}")
    elif args.bandwidth is not None:
        service.set_bandwidth_limit(args.bandwidth)
        print(f"Bandwidth limit set to {args.bandwidth} KB/s")
    elif args.gui or not any([args.status, args.list, args.providers, args.sync, 
                               args.pause, args.resume, args.add, args.remove, 
                               args.stats, args.bandwidth is not None]):
        if TKINTER_AVAILABLE:
            gui = CloudSyncGUI(service)
            gui.run()
        else:
            print("GUI requires tkinter. Use --help for CLI options.")
            sys.exit(1)


if __name__ == "__main__":
    main()
