#!/usr/bin/env python3
"""
Aegis Home NAS v1.0.0
Comprehensive local NAS server for desktop use

Features:
  - NAS Server Management (Samba, NFS, WebDAV)
  - Storage Management (RAID, S.M.A.R.T., pools)
  - Network File Sharing (SMB, NFS, WebDAV, SFTP)
  - Media Server (DLNA/UPnP, Jellyfin/Plex integration)
  - Backup Target (Time Machine, Windows backup, rsync)
  - Web Interface (file browser, user management)
  - Mobile Access (QR codes, Mobile Link integration)
  - Performance optimization (low idle usage, priority management)

Copyright (c) 2024 Aegis OS Team
License: GPL-3.0
"""

import os
import sys
import json
import subprocess
import argparse
import socket
import threading
import time
import hashlib
import secrets
import shutil
import signal
import pwd
import grp
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
from http.server import HTTPServer, SimpleHTTPRequestHandler
import urllib.parse

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog, simpledialog
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

VERSION = "1.0.0"
APP_NAME = "Aegis Home NAS"
CONFIG_DIR = Path.home() / ".config" / "aegis" / "home-nas"
CONFIG_FILE = CONFIG_DIR / "config.json"
SHARES_FILE = CONFIG_DIR / "shares.json"
USERS_FILE = CONFIG_DIR / "users.json"
POOLS_FILE = CONFIG_DIR / "pools.json"
TIER_FILE = Path("/etc/aegis/tier")
DEFAULT_WEB_PORT = 8080
DEFAULT_SHARE_PATH = Path.home() / "NAS"


class ServiceStatus(Enum):
    RUNNING = "running"
    STOPPED = "stopped"
    ERROR = "error"
    UNKNOWN = "unknown"


class AccessLevel(Enum):
    READ_ONLY = "read_only"
    READ_WRITE = "read_write"
    ADMIN = "admin"


class RAIDLevel(Enum):
    SINGLE = "single"
    MIRROR = "mirror"
    STRIPE = "stripe"
    RAID5 = "raid5"
    RAID6 = "raid6"


@dataclass
class NASUser:
    """Represents a NAS user"""
    id: str
    username: str
    password_hash: str = ""
    access_level: str = "read_only"
    enabled: bool = True
    shares: List[str] = field(default_factory=list)
    created: str = ""
    last_login: str = ""


@dataclass
class SharedFolder:
    """Represents a shared folder"""
    id: str
    name: str
    path: str
    description: str = ""
    enabled: bool = True
    smb_enabled: bool = True
    nfs_enabled: bool = False
    webdav_enabled: bool = False
    guest_access: bool = False
    read_only: bool = False
    allowed_users: List[str] = field(default_factory=list)
    time_machine: bool = False
    created: str = ""


@dataclass
class StoragePool:
    """Represents a storage pool"""
    id: str
    name: str
    devices: List[str] = field(default_factory=list)
    raid_level: str = "single"
    mount_point: str = ""
    total_bytes: int = 0
    used_bytes: int = 0
    health: str = "healthy"
    created: str = ""


@dataclass
class DiskInfo:
    """Disk information"""
    device: str
    model: str = ""
    serial: str = ""
    size_bytes: int = 0
    temperature: int = 0
    health: str = "unknown"
    smart_status: str = "unknown"
    power_on_hours: int = 0
    in_pool: bool = False
    pool_id: str = ""


@dataclass
class NASConfig:
    """Main NAS configuration"""
    hostname: str = ""
    web_port: int = DEFAULT_WEB_PORT
    default_share_path: str = ""
    smb_enabled: bool = True
    nfs_enabled: bool = False
    webdav_enabled: bool = False
    sftp_enabled: bool = True
    dlna_enabled: bool = False
    avahi_enabled: bool = True
    auto_start: bool = True
    spin_down_minutes: int = 30
    wol_enabled: bool = True
    desktop_priority: bool = True
    max_connections: int = 10


class NASService:
    """Core NAS service"""
    
    def __init__(self):
        self.config = self._load_config()
        self.shares: Dict[str, SharedFolder] = {}
        self.users: Dict[str, NASUser] = {}
        self.pools: Dict[str, StoragePool] = {}
        self.disks: Dict[str, DiskInfo] = {}
        self.tier = self._get_tier()
        self.web_server = None
        self.web_thread = None
        self._load_shares()
        self._load_users()
        self._load_pools()
        self._scan_disks()
    
    def _get_tier(self) -> str:
        if TIER_FILE.exists():
            try:
                return TIER_FILE.read_text().strip()
            except:
                pass
        return "pro"
    
    def _load_config(self) -> NASConfig:
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        
        config = NASConfig()
        config.hostname = socket.gethostname()
        config.default_share_path = str(DEFAULT_SHARE_PATH)
        
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE, 'r') as f:
                    data = json.load(f)
                    for k, v in data.items():
                        if hasattr(config, k):
                            setattr(config, k, v)
            except Exception:
                pass
        
        DEFAULT_SHARE_PATH.mkdir(parents=True, exist_ok=True)
        return config
    
    def _save_config(self):
        with open(CONFIG_FILE, 'w') as f:
            json.dump(asdict(self.config), f, indent=2)
    
    def _load_shares(self):
        if SHARES_FILE.exists():
            try:
                with open(SHARES_FILE, 'r') as f:
                    data = json.load(f)
                    for share_id, share_data in data.items():
                        self.shares[share_id] = SharedFolder(**share_data)
            except Exception:
                pass
    
    def _save_shares(self):
        with open(SHARES_FILE, 'w') as f:
            json.dump({k: asdict(v) for k, v in self.shares.items()}, f, indent=2)
    
    def _load_users(self):
        if USERS_FILE.exists():
            try:
                with open(USERS_FILE, 'r') as f:
                    data = json.load(f)
                    for user_id, user_data in data.items():
                        self.users[user_id] = NASUser(**user_data)
            except Exception:
                pass
    
    def _save_users(self):
        with open(USERS_FILE, 'w') as f:
            json.dump({k: asdict(v) for k, v in self.users.items()}, f, indent=2)
    
    def _load_pools(self):
        if POOLS_FILE.exists():
            try:
                with open(POOLS_FILE, 'r') as f:
                    data = json.load(f)
                    for pool_id, pool_data in data.items():
                        self.pools[pool_id] = StoragePool(**pool_data)
            except Exception:
                pass
    
    def _save_pools(self):
        with open(POOLS_FILE, 'w') as f:
            json.dump({k: asdict(v) for k, v in self.pools.items()}, f, indent=2)
    
    def _scan_disks(self):
        """Scan available disks"""
        self.disks.clear()
        
        try:
            result = subprocess.run(['lsblk', '-J', '-o', 
                                    'NAME,SIZE,TYPE,MOUNTPOINT,MODEL,SERIAL'],
                                   capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                data = json.loads(result.stdout)
                for device in data.get('blockdevices', []):
                    if device.get('type') == 'disk':
                        dev_path = f"/dev/{device['name']}"
                        disk = DiskInfo(
                            device=dev_path,
                            model=device.get('model', '').strip() or 'Unknown',
                            serial=device.get('serial', '').strip() or '',
                            size_bytes=self._parse_size(device.get('size', '0')),
                        )
                        
                        for pool in self.pools.values():
                            if dev_path in pool.devices:
                                disk.in_pool = True
                                disk.pool_id = pool.id
                                break
                        
                        self.disks[dev_path] = disk
        except Exception:
            pass
        
        self._check_smart_status()
    
    def _parse_size(self, size_str: str) -> int:
        """Parse size string to bytes"""
        if not size_str:
            return 0
        
        size_str = size_str.upper().strip()
        multipliers = {'B': 1, 'K': 1024, 'M': 1024**2, 'G': 1024**3, 'T': 1024**4}
        
        for suffix, mult in multipliers.items():
            if size_str.endswith(suffix):
                try:
                    return int(float(size_str[:-1]) * mult)
                except:
                    return 0
        
        try:
            return int(size_str)
        except:
            return 0
    
    def _check_smart_status(self):
        """Check S.M.A.R.T. status for all disks"""
        smartctl = shutil.which('smartctl')
        if not smartctl:
            return
        
        for dev_path, disk in self.disks.items():
            try:
                result = subprocess.run(
                    ['sudo', 'smartctl', '-H', '-A', dev_path],
                    capture_output=True, text=True, timeout=30
                )
                
                output = result.stdout.lower()
                if 'passed' in output:
                    disk.health = 'healthy'
                    disk.smart_status = 'passed'
                elif 'failed' in output:
                    disk.health = 'failing'
                    disk.smart_status = 'failed'
                else:
                    disk.smart_status = 'unknown'
                
                for line in result.stdout.split('\n'):
                    if 'temperature' in line.lower():
                        parts = line.split()
                        for i, part in enumerate(parts):
                            if part.isdigit() and int(part) < 100:
                                disk.temperature = int(part)
                                break
                    if 'power_on_hours' in line.lower() or 'power-on' in line.lower():
                        parts = line.split()
                        for part in parts:
                            if part.isdigit():
                                disk.power_on_hours = int(part)
                                break
            except Exception:
                pass
    
    def _hash_password(self, password: str) -> str:
        """Hash password with salt"""
        salt = secrets.token_hex(16)
        hash_val = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)
        return f"{salt}:{hash_val.hex()}"
    
    def _verify_password(self, password: str, password_hash: str) -> bool:
        """Verify password against hash"""
        try:
            salt, hash_val = password_hash.split(':')
            new_hash = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)
            return new_hash.hex() == hash_val
        except:
            return False
    
    def add_user(self, username: str, password: str, access_level: str = "read_only") -> Optional[NASUser]:
        """Add a new NAS user"""
        user_id = f"user-{secrets.token_hex(4)}"
        
        for user in self.users.values():
            if user.username == username:
                return None
        
        user = NASUser(
            id=user_id,
            username=username,
            password_hash=self._hash_password(password),
            access_level=access_level,
            created=datetime.now().isoformat()
        )
        
        self.users[user_id] = user
        self._save_users()
        
        self._sync_samba_user(username, password)
        
        return user
    
    def remove_user(self, user_id: str) -> bool:
        """Remove a NAS user"""
        if user_id in self.users:
            username = self.users[user_id].username
            del self.users[user_id]
            self._save_users()
            self._remove_samba_user(username)
            return True
        return False
    
    def change_password(self, user_id: str, new_password: str) -> bool:
        """Change user password"""
        if user_id in self.users:
            self.users[user_id].password_hash = self._hash_password(new_password)
            self._save_users()
            self._sync_samba_user(self.users[user_id].username, new_password)
            return True
        return False
    
    def _sync_samba_user(self, username: str, password: str):
        """Sync user to Samba"""
        try:
            subprocess.run(['sudo', 'useradd', '-M', '-s', '/usr/sbin/nologin', username],
                          capture_output=True, timeout=10)
            
            proc = subprocess.Popen(['sudo', 'smbpasswd', '-a', '-s', username],
                                   stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
            proc.communicate(input=f"{password}\n{password}\n".encode(), timeout=10)
        except Exception:
            pass
    
    def _remove_samba_user(self, username: str):
        """Remove user from Samba"""
        try:
            subprocess.run(['sudo', 'smbpasswd', '-x', username], 
                          capture_output=True, timeout=10)
            subprocess.run(['sudo', 'userdel', username],
                          capture_output=True, timeout=10)
        except Exception:
            pass
    
    def add_share(self, name: str, path: str, **kwargs) -> Optional[SharedFolder]:
        """Add a new shared folder"""
        share_id = f"share-{secrets.token_hex(4)}"
        
        path = Path(path)
        path.mkdir(parents=True, exist_ok=True)
        
        share = SharedFolder(
            id=share_id,
            name=name,
            path=str(path),
            created=datetime.now().isoformat(),
            **kwargs
        )
        
        self.shares[share_id] = share
        self._save_shares()
        self._update_samba_config()
        
        return share
    
    def remove_share(self, share_id: str) -> bool:
        """Remove a shared folder"""
        if share_id in self.shares:
            del self.shares[share_id]
            self._save_shares()
            self._update_samba_config()
            return True
        return False
    
    def update_share(self, share_id: str, **kwargs) -> bool:
        """Update shared folder settings"""
        if share_id in self.shares:
            share = self.shares[share_id]
            for key, value in kwargs.items():
                if hasattr(share, key):
                    setattr(share, key, value)
            self._save_shares()
            self._update_samba_config()
            return True
        return False
    
    def _update_samba_config(self):
        """Update Samba configuration"""
        smb_conf = f"""# Aegis Home NAS - Auto-generated Samba configuration
[global]
    workgroup = WORKGROUP
    server string = {self.config.hostname} NAS
    netbios name = {self.config.hostname}
    security = user
    map to guest = Bad User
    dns proxy = no
    log file = /var/log/samba/log.%m
    max log size = 1000
    server role = standalone server
    passdb backend = tdbsam
    obey pam restrictions = yes
    unix password sync = yes
    pam password change = yes
    min protocol = SMB2
    ea support = yes
    vfs objects = fruit streams_xattr
    fruit:metadata = stream
    fruit:model = MacSamba
    fruit:veto_appledouble = no
    fruit:posix_rename = yes
    fruit:zero_file_id = yes
    fruit:wipe_intentionally_left_blank_rfork = yes
    fruit:delete_empty_adfiles = yes

"""
        
        for share in self.shares.values():
            if share.enabled and share.smb_enabled:
                guest = "yes" if share.guest_access else "no"
                writable = "no" if share.read_only else "yes"
                
                smb_conf += f"""
[{share.name}]
    path = {share.path}
    browseable = yes
    read only = {"yes" if share.read_only else "no"}
    writable = {writable}
    guest ok = {guest}
    create mask = 0644
    directory mask = 0755
"""
                
                if share.time_machine:
                    smb_conf += f"""    vfs objects = fruit streams_xattr
    fruit:time machine = yes
    fruit:time machine max size = 1T
"""
                
                if share.allowed_users and not share.guest_access:
                    users_str = ' '.join(share.allowed_users)
                    smb_conf += f"    valid users = {users_str}\n"
        
        smb_conf_path = CONFIG_DIR / "smb.conf.aegis"
        try:
            with open(smb_conf_path, 'w') as f:
                f.write(smb_conf)
        except Exception:
            pass
    
    def _update_nfs_exports(self):
        """Update NFS exports"""
        exports = ""
        
        for share in self.shares.values():
            if share.enabled and share.nfs_enabled:
                opts = "rw" if not share.read_only else "ro"
                exports += f"{share.path} *(${opts},sync,no_subtree_check,no_root_squash)\n"
        
        exports_path = CONFIG_DIR / "exports.aegis"
        try:
            with open(exports_path, 'w') as f:
                f.write(exports)
        except Exception:
            pass
    
    def create_pool(self, name: str, devices: List[str], raid_level: str = "single") -> Optional[StoragePool]:
        """Create a storage pool"""
        pool_id = f"pool-{secrets.token_hex(4)}"
        
        mount_point = f"/mnt/aegis-pool-{pool_id}"
        
        pool = StoragePool(
            id=pool_id,
            name=name,
            devices=devices,
            raid_level=raid_level,
            mount_point=mount_point,
            created=datetime.now().isoformat()
        )
        
        success = self._setup_raid(pool)
        if not success:
            return None
        
        self.pools[pool_id] = pool
        self._save_pools()
        
        for dev in devices:
            if dev in self.disks:
                self.disks[dev].in_pool = True
                self.disks[dev].pool_id = pool_id
        
        return pool
    
    def _setup_raid(self, pool: StoragePool) -> bool:
        """Setup RAID array using mdadm"""
        if not pool.devices:
            return False
        
        if pool.raid_level == "single":
            return True
        
        try:
            raid_device = f"/dev/md/{pool.id}"
            
            level_map = {
                "mirror": "1",
                "stripe": "0",
                "raid5": "5",
                "raid6": "6"
            }
            
            level = level_map.get(pool.raid_level, "1")
            
            cmd = [
                'sudo', 'mdadm', '--create', raid_device,
                '--level=' + level,
                '--raid-devices=' + str(len(pool.devices))
            ] + pool.devices
            
            result = subprocess.run(cmd, capture_output=True, timeout=60)
            return result.returncode == 0
        except Exception:
            return False
    
    def remove_pool(self, pool_id: str) -> bool:
        """Remove a storage pool"""
        if pool_id in self.pools:
            pool = self.pools[pool_id]
            
            for dev in pool.devices:
                if dev in self.disks:
                    self.disks[dev].in_pool = False
                    self.disks[dev].pool_id = ""
            
            del self.pools[pool_id]
            self._save_pools()
            return True
        return False
    
    def get_service_status(self, service: str) -> str:
        """Get status of a system service"""
        try:
            result = subprocess.run(
                ['systemctl', 'is-active', service],
                capture_output=True, text=True, timeout=5
            )
            status = result.stdout.strip()
            if status == 'active':
                return ServiceStatus.RUNNING.value
            elif status == 'inactive':
                return ServiceStatus.STOPPED.value
            else:
                return ServiceStatus.UNKNOWN.value
        except Exception:
            return ServiceStatus.UNKNOWN.value
    
    def start_service(self, service: str) -> bool:
        """Start a system service"""
        try:
            result = subprocess.run(
                ['sudo', 'systemctl', 'start', service],
                capture_output=True, timeout=30
            )
            return result.returncode == 0
        except Exception:
            return False
    
    def stop_service(self, service: str) -> bool:
        """Stop a system service"""
        try:
            result = subprocess.run(
                ['sudo', 'systemctl', 'stop', service],
                capture_output=True, timeout=30
            )
            return result.returncode == 0
        except Exception:
            return False
    
    def restart_service(self, service: str) -> bool:
        """Restart a system service"""
        try:
            result = subprocess.run(
                ['sudo', 'systemctl', 'restart', service],
                capture_output=True, timeout=30
            )
            return result.returncode == 0
        except Exception:
            return False
    
    def get_all_services_status(self) -> Dict[str, str]:
        """Get status of all NAS services"""
        services = {
            'smbd': 'Samba (SMB)',
            'nmbd': 'NetBIOS',
            'nfs-server': 'NFS Server',
            'avahi-daemon': 'Avahi (Discovery)',
            'minidlna': 'DLNA Server',
            'ssh': 'SSH/SFTP'
        }
        
        status = {}
        for service, name in services.items():
            status[service] = {
                'name': name,
                'status': self.get_service_status(service)
            }
        
        return status
    
    def start_all_services(self) -> Dict[str, bool]:
        """Start all enabled NAS services"""
        results = {}
        
        if self.config.smb_enabled:
            results['smbd'] = self.start_service('smbd')
            results['nmbd'] = self.start_service('nmbd')
        
        if self.config.nfs_enabled:
            results['nfs-server'] = self.start_service('nfs-server')
        
        if self.config.avahi_enabled:
            results['avahi-daemon'] = self.start_service('avahi-daemon')
        
        if self.config.dlna_enabled:
            results['minidlna'] = self.start_service('minidlna')
        
        return results
    
    def stop_all_services(self) -> Dict[str, bool]:
        """Stop all NAS services"""
        results = {}
        
        for service in ['smbd', 'nmbd', 'nfs-server', 'minidlna']:
            results[service] = self.stop_service(service)
        
        return results
    
    def start_web_interface(self) -> bool:
        """Start web interface"""
        if self.web_server:
            return True
        
        try:
            handler = self._create_web_handler()
            self.web_server = HTTPServer(('0.0.0.0', self.config.web_port), handler)
            
            self.web_thread = threading.Thread(target=self.web_server.serve_forever, daemon=True)
            self.web_thread.start()
            return True
        except Exception:
            return False
    
    def stop_web_interface(self):
        """Stop web interface"""
        if self.web_server:
            self.web_server.shutdown()
            self.web_server = None
    
    def _create_web_handler(self):
        """Create custom web request handler"""
        nas_service = self
        
        class NASWebHandler(SimpleHTTPRequestHandler):
            def do_GET(self):
                parsed = urllib.parse.urlparse(self.path)
                path = parsed.path
                
                if path == '/' or path == '/index.html':
                    self._send_dashboard()
                elif path == '/api/status':
                    self._send_json(nas_service.get_status())
                elif path == '/api/shares':
                    self._send_json([asdict(s) for s in nas_service.shares.values()])
                elif path == '/api/users':
                    users = [{k: v for k, v in asdict(u).items() if k != 'password_hash'} 
                            for u in nas_service.users.values()]
                    self._send_json(users)
                elif path == '/api/disks':
                    self._send_json([asdict(d) for d in nas_service.disks.values()])
                elif path.startswith('/files'):
                    self._serve_file_browser(path[6:] or '/')
                else:
                    self.send_error(404)
            
            def _send_json(self, data):
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Cache-Control', 'no-cache')
                self.end_headers()
                self.wfile.write(json.dumps(data, indent=2).encode())
            
            def _send_dashboard(self):
                html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{APP_NAME}</title>
    <style>
        * {{ box-sizing: border-box; margin: 0; padding: 0; }}
        body {{ font-family: 'Segoe UI', sans-serif; background: #1e1e2e; color: #cdd6f4; }}
        .header {{ background: #313244; padding: 20px; border-bottom: 1px solid #45475a; }}
        .header h1 {{ color: #89b4fa; }}
        .container {{ max-width: 1200px; margin: 0 auto; padding: 20px; }}
        .grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }}
        .card {{ background: #313244; border-radius: 10px; padding: 20px; }}
        .card h2 {{ color: #89b4fa; margin-bottom: 15px; font-size: 1.2em; }}
        .stat {{ display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #45475a; }}
        .stat:last-child {{ border-bottom: none; }}
        .status-running {{ color: #a6e3a1; }}
        .status-stopped {{ color: #f38ba8; }}
        .btn {{ background: #89b4fa; color: #1e1e2e; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }}
        .btn:hover {{ background: #b4befe; }}
        .btn-danger {{ background: #f38ba8; }}
        table {{ width: 100%; border-collapse: collapse; }}
        th, td {{ text-align: left; padding: 10px; border-bottom: 1px solid #45475a; }}
        th {{ color: #89b4fa; }}
        .nav {{ background: #313244; padding: 10px 20px; }}
        .nav a {{ color: #cdd6f4; text-decoration: none; margin-right: 20px; }}
        .nav a:hover {{ color: #89b4fa; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>üè† {APP_NAME}</h1>
        <p>Version {VERSION} | {nas_service.config.hostname}</p>
    </div>
    <nav class="nav">
        <a href="/">Dashboard</a>
        <a href="/files/">File Browser</a>
        <a href="#shares">Shares</a>
        <a href="#users">Users</a>
        <a href="#storage">Storage</a>
    </nav>
    <div class="container">
        <div class="grid">
            <div class="card">
                <h2>üìä Server Status</h2>
                <div id="services-status">Loading...</div>
            </div>
            <div class="card">
                <h2>üìÅ Shared Folders</h2>
                <div id="shares-list">Loading...</div>
            </div>
            <div class="card">
                <h2>üíæ Storage</h2>
                <div id="storage-info">Loading...</div>
            </div>
            <div class="card">
                <h2>üë• Users</h2>
                <div id="users-list">Loading...</div>
            </div>
        </div>
    </div>
    <script>
        async function loadStatus() {{
            try {{
                const resp = await fetch('/api/status');
                const data = await resp.json();
                
                let servicesHtml = '';
                for (const [service, info] of Object.entries(data.services || {{}})) {{
                    const statusClass = info.status === 'running' ? 'status-running' : 'status-stopped';
                    servicesHtml += `<div class="stat"><span>${{info.name}}</span><span class="${{statusClass}}">${{info.status}}</span></div>`;
                }}
                document.getElementById('services-status').innerHTML = servicesHtml || 'No services';
                
                let sharesHtml = '';
                for (const share of data.shares || []) {{
                    sharesHtml += `<div class="stat"><span>${{share.name}}</span><span>${{share.enabled ? '‚úì' : '‚úó'}}</span></div>`;
                }}
                document.getElementById('shares-list').innerHTML = sharesHtml || 'No shares configured';
                
                let storageHtml = `<div class="stat"><span>Disks</span><span>${{data.disks_count || 0}}</span></div>`;
                storageHtml += `<div class="stat"><span>Pools</span><span>${{data.pools_count || 0}}</span></div>`;
                document.getElementById('storage-info').innerHTML = storageHtml;
                
                let usersHtml = `<div class="stat"><span>Total Users</span><span>${{data.users_count || 0}}</span></div>`;
                document.getElementById('users-list').innerHTML = usersHtml;
            }} catch (e) {{
                console.error('Failed to load status:', e);
            }}
        }}
        
        loadStatus();
        setInterval(loadStatus, 10000);
    </script>
</body>
</html>"""
                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.send_header('Cache-Control', 'no-cache')
                self.end_headers()
                self.wfile.write(html.encode())
            
            def _serve_file_browser(self, path):
                base = Path(nas_service.config.default_share_path)
                target = (base / path.lstrip('/')).resolve()
                
                if not str(target).startswith(str(base)):
                    self.send_error(403)
                    return
                
                if not target.exists():
                    self.send_error(404)
                    return
                
                if target.is_file():
                    self.send_response(200)
                    self.send_header('Content-Type', 'application/octet-stream')
                    self.send_header('Content-Disposition', f'attachment; filename="{target.name}"')
                    self.end_headers()
                    with open(target, 'rb') as f:
                        self.wfile.write(f.read())
                    return
                
                items = []
                try:
                    for item in sorted(target.iterdir()):
                        items.append({
                            'name': item.name,
                            'is_dir': item.is_dir(),
                            'size': item.stat().st_size if item.is_file() else 0
                        })
                except PermissionError:
                    items = []
                
                html = f"""<!DOCTYPE html>
<html>
<head>
    <title>File Browser - {path}</title>
    <style>
        body {{ font-family: sans-serif; background: #1e1e2e; color: #cdd6f4; padding: 20px; }}
        a {{ color: #89b4fa; text-decoration: none; }}
        a:hover {{ text-decoration: underline; }}
        .file-list {{ list-style: none; padding: 0; }}
        .file-list li {{ padding: 10px; border-bottom: 1px solid #45475a; }}
        .folder {{ color: #f9e2af; }}
    </style>
</head>
<body>
    <h1>üìÅ {path or '/'}</h1>
    <ul class="file-list">
        <li><a href="/files{str(Path(path).parent)}">‚¨ÜÔ∏è ..</a></li>
"""
                for item in items:
                    icon = 'üìÅ' if item['is_dir'] else 'üìÑ'
                    link = f"/files{path}/{item['name']}"
                    size = f" ({item['size']:,} bytes)" if not item['is_dir'] else ''
                    html += f'        <li><a href="{link}">{icon} {item["name"]}</a>{size}</li>\n'
                
                html += """    </ul>
</body>
</html>"""
                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.end_headers()
                self.wfile.write(html.encode())
            
            def log_message(self, format, *args):
                pass
        
        return NASWebHandler
    
    def generate_qr_code(self) -> Optional[str]:
        """Generate QR code for mobile connection"""
        try:
            ip = socket.gethostbyname(socket.gethostname())
        except:
            ip = "127.0.0.1"
        
        connection_info = {
            "type": "aegis-nas",
            "hostname": self.config.hostname,
            "ip": ip,
            "smb_port": 445,
            "web_port": self.config.web_port,
            "version": VERSION
        }
        
        return json.dumps(connection_info)
    
    def set_spin_down_time(self, minutes: int):
        """Set disk spin-down time"""
        self.config.spin_down_minutes = minutes
        self._save_config()
        
        try:
            for disk in self.disks.keys():
                standby = minutes // 5
                subprocess.run(['sudo', 'hdparm', '-S', str(standby), disk],
                              capture_output=True, timeout=10)
        except Exception:
            pass
    
    def enable_wol(self, interface: str = "eth0") -> bool:
        """Enable Wake-on-LAN"""
        try:
            result = subprocess.run(
                ['sudo', 'ethtool', '-s', interface, 'wol', 'g'],
                capture_output=True, timeout=10
            )
            self.config.wol_enabled = result.returncode == 0
            self._save_config()
            return result.returncode == 0
        except Exception:
            return False
    
    def set_desktop_priority(self, enabled: bool):
        """Set desktop priority mode"""
        self.config.desktop_priority = enabled
        self._save_config()
        
        if enabled:
            try:
                for service in ['smbd', 'nmbd', 'nfs-server', 'minidlna']:
                    subprocess.run(['sudo', 'renice', '10', '-p', 
                                   subprocess.check_output(['pgrep', service]).decode().strip()],
                                  capture_output=True, timeout=10)
            except Exception:
                pass
    
    def get_status(self) -> Dict:
        """Get comprehensive NAS status"""
        services_status = self.get_all_services_status()
        
        try:
            ip = socket.gethostbyname(socket.gethostname())
        except:
            ip = "127.0.0.1"
        
        return {
            "version": VERSION,
            "tier": self.tier,
            "hostname": self.config.hostname,
            "ip_address": ip,
            "web_port": self.config.web_port,
            "web_url": f"http://{ip}:{self.config.web_port}",
            "smb_enabled": self.config.smb_enabled,
            "nfs_enabled": self.config.nfs_enabled,
            "webdav_enabled": self.config.webdav_enabled,
            "dlna_enabled": self.config.dlna_enabled,
            "services": services_status,
            "shares": [asdict(s) for s in self.shares.values()],
            "shares_count": len(self.shares),
            "users_count": len(self.users),
            "pools_count": len(self.pools),
            "disks_count": len(self.disks),
            "disks": [asdict(d) for d in self.disks.values()],
            "pools": [asdict(p) for p in self.pools.values()],
            "spin_down_minutes": self.config.spin_down_minutes,
            "wol_enabled": self.config.wol_enabled,
            "desktop_priority": self.config.desktop_priority
        }


class NASManagerGUI:
    """GUI for NAS Manager"""
    
    def __init__(self, service: NASService):
        self.service = service
        self.root = None
    
    def run(self):
        if not TKINTER_AVAILABLE:
            print("Error: Tkinter not available")
            sys.exit(1)
        
        self.root = tk.Tk()
        self.root.title(f"{APP_NAME} v{VERSION}")
        self.root.geometry("1000x700")
        self.root.configure(bg='#1e1e2e')
        
        style = ttk.Style()
        style.theme_use('clam')
        style.configure('TFrame', background='#1e1e2e')
        style.configure('TLabel', background='#1e1e2e', foreground='#cdd6f4')
        style.configure('Header.TLabel', font=('Segoe UI', 18, 'bold'), foreground='#89b4fa')
        style.configure('TButton', padding=8)
        style.configure('Success.TLabel', foreground='#a6e3a1')
        style.configure('Error.TLabel', foreground='#f38ba8')
        style.configure('TNotebook', background='#1e1e2e')
        style.configure('TNotebook.Tab', padding=[15, 5])
        
        self._create_widgets()
        self._refresh_all()
        self.root.mainloop()
    
    def _create_widgets(self):
        main = ttk.Frame(self.root, padding=20)
        main.pack(fill=tk.BOTH, expand=True)
        
        header = ttk.Frame(main)
        header.pack(fill=tk.X, pady=(0, 20))
        
        ttk.Label(header, text="üè† Aegis Home NAS", style='Header.TLabel').pack(side=tk.LEFT)
        
        self.status_label = ttk.Label(header, text="", style='Success.TLabel')
        self.status_label.pack(side=tk.RIGHT)
        
        control_frame = ttk.Frame(main)
        control_frame.pack(fill=tk.X, pady=(0, 15))
        
        ttk.Button(control_frame, text="‚ñ∂ Start All", 
                  command=self._start_all).pack(side=tk.LEFT, padx=5)
        ttk.Button(control_frame, text="‚èπ Stop All", 
                  command=self._stop_all).pack(side=tk.LEFT, padx=5)
        ttk.Button(control_frame, text="üîÑ Refresh", 
                  command=self._refresh_all).pack(side=tk.LEFT, padx=5)
        ttk.Button(control_frame, text="üåê Open Web UI", 
                  command=self._open_web).pack(side=tk.LEFT, padx=5)
        
        notebook = ttk.Notebook(main)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        self._create_overview_tab(notebook)
        self._create_shares_tab(notebook)
        self._create_users_tab(notebook)
        self._create_storage_tab(notebook)
        self._create_services_tab(notebook)
        self._create_settings_tab(notebook)
    
    def _create_overview_tab(self, notebook):
        frame = ttk.Frame(notebook, padding=15)
        notebook.add(frame, text="Overview")
        
        status = self.service.get_status()
        
        info_frame = ttk.Frame(frame)
        info_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(info_frame, text=f"Hostname: {status['hostname']}", 
                 font=('Segoe UI', 11)).pack(anchor=tk.W)
        ttk.Label(info_frame, text=f"IP Address: {status['ip_address']}", 
                 font=('Segoe UI', 11)).pack(anchor=tk.W)
        ttk.Label(info_frame, text=f"Web Interface: {status['web_url']}", 
                 font=('Segoe UI', 11)).pack(anchor=tk.W)
        
        stats_frame = ttk.Frame(frame)
        stats_frame.pack(fill=tk.X, pady=20)
        
        stats = [
            ("Shares", status['shares_count']),
            ("Users", status['users_count']),
            ("Disks", status['disks_count']),
            ("Pools", status['pools_count'])
        ]
        
        for i, (label, value) in enumerate(stats):
            sf = ttk.Frame(stats_frame)
            sf.pack(side=tk.LEFT, padx=30)
            ttk.Label(sf, text=str(value), font=('Segoe UI', 24, 'bold'), 
                     foreground='#89b4fa').pack()
            ttk.Label(sf, text=label).pack()
        
        services_frame = ttk.LabelFrame(frame, text="Services Status", padding=10)
        services_frame.pack(fill=tk.X, pady=10)
        
        self.services_status_frame = services_frame
        self._update_services_status()
    
    def _update_services_status(self):
        for widget in self.services_status_frame.winfo_children():
            widget.destroy()
        
        services = self.service.get_all_services_status()
        
        for i, (service, info) in enumerate(services.items()):
            row = i // 3
            col = i % 3
            
            sf = ttk.Frame(self.services_status_frame)
            sf.grid(row=row, column=col, padx=20, pady=5, sticky=tk.W)
            
            status_color = '#a6e3a1' if info['status'] == 'running' else '#f38ba8'
            status_icon = '‚óè' if info['status'] == 'running' else '‚óã'
            
            ttk.Label(sf, text=f"{status_icon} {info['name']}", 
                     foreground=status_color).pack(side=tk.LEFT)
    
    def _create_shares_tab(self, notebook):
        frame = ttk.Frame(notebook, padding=15)
        notebook.add(frame, text="Shares")
        
        toolbar = ttk.Frame(frame)
        toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(toolbar, text="+ Add Share", 
                  command=self._add_share_dialog).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="Edit", 
                  command=self._edit_share).pack(side=tk.LEFT, padx=5)
        ttk.Button(toolbar, text="Delete", 
                  command=self._delete_share).pack(side=tk.LEFT, padx=5)
        
        columns = ('name', 'path', 'smb', 'nfs', 'webdav', 'status')
        self.shares_tree = ttk.Treeview(frame, columns=columns, show='headings', height=15)
        
        self.shares_tree.heading('name', text='Name')
        self.shares_tree.heading('path', text='Path')
        self.shares_tree.heading('smb', text='SMB')
        self.shares_tree.heading('nfs', text='NFS')
        self.shares_tree.heading('webdav', text='WebDAV')
        self.shares_tree.heading('status', text='Status')
        
        self.shares_tree.column('name', width=150)
        self.shares_tree.column('path', width=300)
        self.shares_tree.column('smb', width=60)
        self.shares_tree.column('nfs', width=60)
        self.shares_tree.column('webdav', width=70)
        self.shares_tree.column('status', width=80)
        
        scrollbar = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=self.shares_tree.yview)
        self.shares_tree.configure(yscrollcommand=scrollbar.set)
        
        self.shares_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    def _create_users_tab(self, notebook):
        frame = ttk.Frame(notebook, padding=15)
        notebook.add(frame, text="Users")
        
        toolbar = ttk.Frame(frame)
        toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(toolbar, text="+ Add User", 
                  command=self._add_user_dialog).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="Change Password", 
                  command=self._change_password_dialog).pack(side=tk.LEFT, padx=5)
        ttk.Button(toolbar, text="Delete", 
                  command=self._delete_user).pack(side=tk.LEFT, padx=5)
        
        columns = ('username', 'access', 'enabled', 'last_login')
        self.users_tree = ttk.Treeview(frame, columns=columns, show='headings', height=15)
        
        self.users_tree.heading('username', text='Username')
        self.users_tree.heading('access', text='Access Level')
        self.users_tree.heading('enabled', text='Enabled')
        self.users_tree.heading('last_login', text='Last Login')
        
        self.users_tree.column('username', width=150)
        self.users_tree.column('access', width=120)
        self.users_tree.column('enabled', width=80)
        self.users_tree.column('last_login', width=200)
        
        self.users_tree.pack(fill=tk.BOTH, expand=True)
    
    def _create_storage_tab(self, notebook):
        frame = ttk.Frame(notebook, padding=15)
        notebook.add(frame, text="Storage")
        
        disks_frame = ttk.LabelFrame(frame, text="Disks", padding=10)
        disks_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        columns = ('device', 'model', 'size', 'health', 'temp', 'pool')
        self.disks_tree = ttk.Treeview(disks_frame, columns=columns, show='headings', height=8)
        
        self.disks_tree.heading('device', text='Device')
        self.disks_tree.heading('model', text='Model')
        self.disks_tree.heading('size', text='Size')
        self.disks_tree.heading('health', text='Health')
        self.disks_tree.heading('temp', text='Temp')
        self.disks_tree.heading('pool', text='Pool')
        
        self.disks_tree.pack(fill=tk.BOTH, expand=True)
        
        pools_frame = ttk.LabelFrame(frame, text="Storage Pools", padding=10)
        pools_frame.pack(fill=tk.BOTH, expand=True)
        
        pool_toolbar = ttk.Frame(pools_frame)
        pool_toolbar.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(pool_toolbar, text="+ Create Pool", 
                  command=self._create_pool_dialog).pack(side=tk.LEFT)
        ttk.Button(pool_toolbar, text="Delete Pool", 
                  command=self._delete_pool).pack(side=tk.LEFT, padx=5)
        
        columns = ('name', 'raid', 'devices', 'size', 'health')
        self.pools_tree = ttk.Treeview(pools_frame, columns=columns, show='headings', height=5)
        
        self.pools_tree.heading('name', text='Name')
        self.pools_tree.heading('raid', text='RAID Level')
        self.pools_tree.heading('devices', text='Devices')
        self.pools_tree.heading('size', text='Size')
        self.pools_tree.heading('health', text='Health')
        
        self.pools_tree.pack(fill=tk.BOTH, expand=True)
    
    def _create_services_tab(self, notebook):
        frame = ttk.Frame(notebook, padding=15)
        notebook.add(frame, text="Services")
        
        services = [
            ('smbd', 'Samba (SMB/CIFS)', 'Windows/Mac/Linux file sharing'),
            ('nmbd', 'NetBIOS Name Service', 'Network discovery'),
            ('nfs-server', 'NFS Server', 'Linux/Unix file sharing'),
            ('avahi-daemon', 'Avahi/Bonjour', 'Zero-conf discovery'),
            ('minidlna', 'DLNA/UPnP', 'Media streaming'),
            ('ssh', 'SSH/SFTP', 'Secure file transfer')
        ]
        
        self.service_controls = {}
        
        for service_id, name, desc in services:
            sf = ttk.Frame(frame)
            sf.pack(fill=tk.X, pady=5)
            
            info_frame = ttk.Frame(sf)
            info_frame.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            ttk.Label(info_frame, text=name, font=('Segoe UI', 11, 'bold')).pack(anchor=tk.W)
            ttk.Label(info_frame, text=desc, foreground='#a6adc8').pack(anchor=tk.W)
            
            btn_frame = ttk.Frame(sf)
            btn_frame.pack(side=tk.RIGHT)
            
            status_label = ttk.Label(btn_frame, text="‚óè", foreground='#f38ba8')
            status_label.pack(side=tk.LEFT, padx=10)
            
            ttk.Button(btn_frame, text="Start", 
                      command=lambda s=service_id: self._start_service(s)).pack(side=tk.LEFT, padx=2)
            ttk.Button(btn_frame, text="Stop", 
                      command=lambda s=service_id: self._stop_service(s)).pack(side=tk.LEFT, padx=2)
            ttk.Button(btn_frame, text="Restart", 
                      command=lambda s=service_id: self._restart_service(s)).pack(side=tk.LEFT, padx=2)
            
            self.service_controls[service_id] = status_label
    
    def _create_settings_tab(self, notebook):
        frame = ttk.Frame(notebook, padding=15)
        notebook.add(frame, text="Settings")
        
        general_frame = ttk.LabelFrame(frame, text="General", padding=10)
        general_frame.pack(fill=tk.X, pady=5)
        
        row = ttk.Frame(general_frame)
        row.pack(fill=tk.X, pady=5)
        ttk.Label(row, text="Web Port:").pack(side=tk.LEFT)
        self.web_port_var = tk.StringVar(value=str(self.service.config.web_port))
        ttk.Entry(row, textvariable=self.web_port_var, width=10).pack(side=tk.LEFT, padx=10)
        
        self.auto_start_var = tk.BooleanVar(value=self.service.config.auto_start)
        ttk.Checkbutton(general_frame, text="Start NAS services on boot", 
                       variable=self.auto_start_var).pack(anchor=tk.W, pady=5)
        
        power_frame = ttk.LabelFrame(frame, text="Power Management", padding=10)
        power_frame.pack(fill=tk.X, pady=5)
        
        row = ttk.Frame(power_frame)
        row.pack(fill=tk.X, pady=5)
        ttk.Label(row, text="Disk spin-down (minutes):").pack(side=tk.LEFT)
        self.spin_down_var = tk.StringVar(value=str(self.service.config.spin_down_minutes))
        ttk.Entry(row, textvariable=self.spin_down_var, width=10).pack(side=tk.LEFT, padx=10)
        
        self.wol_var = tk.BooleanVar(value=self.service.config.wol_enabled)
        ttk.Checkbutton(power_frame, text="Enable Wake-on-LAN", 
                       variable=self.wol_var).pack(anchor=tk.W, pady=5)
        
        self.priority_var = tk.BooleanVar(value=self.service.config.desktop_priority)
        ttk.Checkbutton(power_frame, text="Desktop priority (lower NAS process priority)", 
                       variable=self.priority_var).pack(anchor=tk.W, pady=5)
        
        protocols_frame = ttk.LabelFrame(frame, text="Protocols", padding=10)
        protocols_frame.pack(fill=tk.X, pady=5)
        
        self.smb_var = tk.BooleanVar(value=self.service.config.smb_enabled)
        ttk.Checkbutton(protocols_frame, text="SMB/CIFS (Windows sharing)", 
                       variable=self.smb_var).pack(anchor=tk.W, pady=2)
        
        self.nfs_var = tk.BooleanVar(value=self.service.config.nfs_enabled)
        ttk.Checkbutton(protocols_frame, text="NFS (Linux/Unix sharing)", 
                       variable=self.nfs_var).pack(anchor=tk.W, pady=2)
        
        self.webdav_var = tk.BooleanVar(value=self.service.config.webdav_enabled)
        ttk.Checkbutton(protocols_frame, text="WebDAV (Web access)", 
                       variable=self.webdav_var).pack(anchor=tk.W, pady=2)
        
        self.dlna_var = tk.BooleanVar(value=self.service.config.dlna_enabled)
        ttk.Checkbutton(protocols_frame, text="DLNA/UPnP (Media streaming)", 
                       variable=self.dlna_var).pack(anchor=tk.W, pady=2)
        
        self.avahi_var = tk.BooleanVar(value=self.service.config.avahi_enabled)
        ttk.Checkbutton(protocols_frame, text="Avahi/Bonjour (Auto-discovery)", 
                       variable=self.avahi_var).pack(anchor=tk.W, pady=2)
        
        ttk.Button(frame, text="Save Settings", 
                  command=self._save_settings).pack(pady=20)
    
    def _refresh_all(self):
        self._refresh_shares()
        self._refresh_users()
        self._refresh_disks()
        self._refresh_pools()
        self._update_services_status()
        self._update_service_indicators()
        
        status = self.service.get_status()
        running = sum(1 for s in status['services'].values() if s['status'] == 'running')
        self.status_label.configure(text=f"Services: {running}/{len(status['services'])} running")
    
    def _refresh_shares(self):
        for item in self.shares_tree.get_children():
            self.shares_tree.delete(item)
        
        for share in self.service.shares.values():
            self.shares_tree.insert('', tk.END, iid=share.id, values=(
                share.name,
                share.path,
                '‚úì' if share.smb_enabled else '‚úó',
                '‚úì' if share.nfs_enabled else '‚úó',
                '‚úì' if share.webdav_enabled else '‚úó',
                'Enabled' if share.enabled else 'Disabled'
            ))
    
    def _refresh_users(self):
        for item in self.users_tree.get_children():
            self.users_tree.delete(item)
        
        for user in self.service.users.values():
            self.users_tree.insert('', tk.END, iid=user.id, values=(
                user.username,
                user.access_level,
                '‚úì' if user.enabled else '‚úó',
                user.last_login or 'Never'
            ))
    
    def _refresh_disks(self):
        self.service._scan_disks()
        
        for item in self.disks_tree.get_children():
            self.disks_tree.delete(item)
        
        for disk in self.service.disks.values():
            size_gb = disk.size_bytes / (1024**3)
            pool_name = ""
            if disk.pool_id and disk.pool_id in self.service.pools:
                pool_name = self.service.pools[disk.pool_id].name
            
            self.disks_tree.insert('', tk.END, values=(
                disk.device,
                disk.model,
                f"{size_gb:.1f} GB",
                disk.health,
                f"{disk.temperature}¬∞C" if disk.temperature else "N/A",
                pool_name or "-"
            ))
    
    def _refresh_pools(self):
        for item in self.pools_tree.get_children():
            self.pools_tree.delete(item)
        
        for pool in self.service.pools.values():
            total_gb = pool.total_bytes / (1024**3) if pool.total_bytes else 0
            
            self.pools_tree.insert('', tk.END, iid=pool.id, values=(
                pool.name,
                pool.raid_level.upper(),
                len(pool.devices),
                f"{total_gb:.1f} GB",
                pool.health
            ))
    
    def _update_service_indicators(self):
        services = self.service.get_all_services_status()
        
        for service_id, label in self.service_controls.items():
            if service_id in services:
                status = services[service_id]['status']
                color = '#a6e3a1' if status == 'running' else '#f38ba8'
                label.configure(foreground=color)
    
    def _start_all(self):
        results = self.service.start_all_services()
        self.service.start_web_interface()
        self._refresh_all()
        messagebox.showinfo("NAS Started", "NAS services have been started")
    
    def _stop_all(self):
        results = self.service.stop_all_services()
        self.service.stop_web_interface()
        self._refresh_all()
        messagebox.showinfo("NAS Stopped", "NAS services have been stopped")
    
    def _start_service(self, service: str):
        if self.service.start_service(service):
            self._update_service_indicators()
        else:
            messagebox.showerror("Error", f"Failed to start {service}")
    
    def _stop_service(self, service: str):
        if self.service.stop_service(service):
            self._update_service_indicators()
        else:
            messagebox.showerror("Error", f"Failed to stop {service}")
    
    def _restart_service(self, service: str):
        if self.service.restart_service(service):
            self._update_service_indicators()
        else:
            messagebox.showerror("Error", f"Failed to restart {service}")
    
    def _open_web(self):
        status = self.service.get_status()
        url = status['web_url']
        try:
            subprocess.Popen(['xdg-open', url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception:
            messagebox.showinfo("Web Interface", f"Open in browser: {url}")
    
    def _add_share_dialog(self):
        dialog = tk.Toplevel(self.root)
        dialog.title("Add Share")
        dialog.geometry("400x300")
        dialog.configure(bg='#1e1e2e')
        dialog.transient(self.root)
        dialog.grab_set()
        
        ttk.Label(dialog, text="Share Name:").pack(anchor=tk.W, padx=20, pady=(20, 5))
        name_var = tk.StringVar()
        ttk.Entry(dialog, textvariable=name_var, width=40).pack(padx=20)
        
        ttk.Label(dialog, text="Path:").pack(anchor=tk.W, padx=20, pady=(10, 5))
        path_var = tk.StringVar(value=str(self.service.config.default_share_path))
        path_frame = ttk.Frame(dialog)
        path_frame.pack(fill=tk.X, padx=20)
        ttk.Entry(path_frame, textvariable=path_var, width=30).pack(side=tk.LEFT)
        ttk.Button(path_frame, text="Browse", 
                  command=lambda: path_var.set(filedialog.askdirectory() or path_var.get())).pack(side=tk.LEFT, padx=5)
        
        smb_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(dialog, text="Enable SMB/CIFS", variable=smb_var).pack(anchor=tk.W, padx=20, pady=5)
        
        nfs_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(dialog, text="Enable NFS", variable=nfs_var).pack(anchor=tk.W, padx=20, pady=5)
        
        guest_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(dialog, text="Allow guest access", variable=guest_var).pack(anchor=tk.W, padx=20, pady=5)
        
        def create():
            name = name_var.get().strip()
            path = path_var.get().strip()
            
            if not name or not path:
                messagebox.showerror("Error", "Name and path are required")
                return
            
            share = self.service.add_share(
                name, path,
                smb_enabled=smb_var.get(),
                nfs_enabled=nfs_var.get(),
                guest_access=guest_var.get()
            )
            
            if share:
                dialog.destroy()
                self._refresh_shares()
            else:
                messagebox.showerror("Error", "Failed to create share")
        
        ttk.Button(dialog, text="Create Share", command=create).pack(pady=20)
    
    def _edit_share(self):
        selection = self.shares_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a share first")
            return
        
        share_id = selection[0]
        if share_id in self.service.shares:
            share = self.service.shares[share_id]
            messagebox.showinfo("Edit Share", f"Editing: {share.name}\n(Full edit dialog would appear here)")
    
    def _delete_share(self):
        selection = self.shares_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a share first")
            return
        
        share_id = selection[0]
        if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this share?"):
            if self.service.remove_share(share_id):
                self._refresh_shares()
            else:
                messagebox.showerror("Error", "Failed to delete share")
    
    def _add_user_dialog(self):
        dialog = tk.Toplevel(self.root)
        dialog.title("Add User")
        dialog.geometry("350x250")
        dialog.configure(bg='#1e1e2e')
        dialog.transient(self.root)
        dialog.grab_set()
        
        ttk.Label(dialog, text="Username:").pack(anchor=tk.W, padx=20, pady=(20, 5))
        username_var = tk.StringVar()
        ttk.Entry(dialog, textvariable=username_var, width=30).pack(padx=20)
        
        ttk.Label(dialog, text="Password:").pack(anchor=tk.W, padx=20, pady=(10, 5))
        password_var = tk.StringVar()
        ttk.Entry(dialog, textvariable=password_var, width=30, show='*').pack(padx=20)
        
        ttk.Label(dialog, text="Access Level:").pack(anchor=tk.W, padx=20, pady=(10, 5))
        access_var = tk.StringVar(value="read_write")
        ttk.Combobox(dialog, textvariable=access_var, values=['read_only', 'read_write', 'admin'], 
                    state='readonly', width=27).pack(padx=20)
        
        def create():
            username = username_var.get().strip()
            password = password_var.get()
            
            if not username or not password:
                messagebox.showerror("Error", "Username and password are required")
                return
            
            user = self.service.add_user(username, password, access_var.get())
            
            if user:
                dialog.destroy()
                self._refresh_users()
            else:
                messagebox.showerror("Error", "Failed to create user (username may exist)")
        
        ttk.Button(dialog, text="Create User", command=create).pack(pady=20)
    
    def _change_password_dialog(self):
        selection = self.users_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a user first")
            return
        
        user_id = selection[0]
        new_password = simpledialog.askstring("Change Password", "Enter new password:", show='*')
        
        if new_password:
            if self.service.change_password(user_id, new_password):
                messagebox.showinfo("Success", "Password changed successfully")
            else:
                messagebox.showerror("Error", "Failed to change password")
    
    def _delete_user(self):
        selection = self.users_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a user first")
            return
        
        user_id = selection[0]
        if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this user?"):
            if self.service.remove_user(user_id):
                self._refresh_users()
            else:
                messagebox.showerror("Error", "Failed to delete user")
    
    def _create_pool_dialog(self):
        available = [d for d in self.service.disks.values() if not d.in_pool]
        
        if not available:
            messagebox.showwarning("Warning", "No available disks to create pool")
            return
        
        dialog = tk.Toplevel(self.root)
        dialog.title("Create Storage Pool")
        dialog.geometry("400x400")
        dialog.configure(bg='#1e1e2e')
        dialog.transient(self.root)
        dialog.grab_set()
        
        ttk.Label(dialog, text="Pool Name:").pack(anchor=tk.W, padx=20, pady=(20, 5))
        name_var = tk.StringVar()
        ttk.Entry(dialog, textvariable=name_var, width=35).pack(padx=20)
        
        ttk.Label(dialog, text="RAID Level:").pack(anchor=tk.W, padx=20, pady=(10, 5))
        raid_var = tk.StringVar(value="single")
        ttk.Combobox(dialog, textvariable=raid_var, 
                    values=['single', 'mirror', 'stripe', 'raid5', 'raid6'],
                    state='readonly', width=32).pack(padx=20)
        
        ttk.Label(dialog, text="Select Disks:").pack(anchor=tk.W, padx=20, pady=(10, 5))
        
        disk_listbox = tk.Listbox(dialog, selectmode=tk.MULTIPLE, height=8, bg='#313244', fg='#cdd6f4')
        disk_listbox.pack(padx=20, fill=tk.X)
        
        for disk in available:
            size_gb = disk.size_bytes / (1024**3)
            disk_listbox.insert(tk.END, f"{disk.device} - {disk.model} ({size_gb:.1f} GB)")
        
        def create():
            name = name_var.get().strip()
            if not name:
                messagebox.showerror("Error", "Pool name is required")
                return
            
            selected = disk_listbox.curselection()
            if not selected:
                messagebox.showerror("Error", "Select at least one disk")
                return
            
            devices = [available[i].device for i in selected]
            
            pool = self.service.create_pool(name, devices, raid_var.get())
            if pool:
                dialog.destroy()
                self._refresh_pools()
                self._refresh_disks()
            else:
                messagebox.showerror("Error", "Failed to create pool")
        
        ttk.Button(dialog, text="Create Pool", command=create).pack(pady=20)
    
    def _delete_pool(self):
        selection = self.pools_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a pool first")
            return
        
        pool_id = selection[0]
        if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this pool?"):
            if self.service.remove_pool(pool_id):
                self._refresh_pools()
                self._refresh_disks()
            else:
                messagebox.showerror("Error", "Failed to delete pool")
    
    def _save_settings(self):
        try:
            self.service.config.web_port = int(self.web_port_var.get())
            self.service.config.spin_down_minutes = int(self.spin_down_var.get())
        except ValueError:
            messagebox.showerror("Error", "Invalid numeric value")
            return
        
        self.service.config.auto_start = self.auto_start_var.get()
        self.service.config.wol_enabled = self.wol_var.get()
        self.service.config.desktop_priority = self.priority_var.get()
        self.service.config.smb_enabled = self.smb_var.get()
        self.service.config.nfs_enabled = self.nfs_var.get()
        self.service.config.webdav_enabled = self.webdav_var.get()
        self.service.config.dlna_enabled = self.dlna_var.get()
        self.service.config.avahi_enabled = self.avahi_var.get()
        
        self.service._save_config()
        
        if self.service.config.desktop_priority:
            self.service.set_desktop_priority(True)
        
        self.service.set_spin_down_time(self.service.config.spin_down_minutes)
        
        messagebox.showinfo("Success", "Settings saved successfully")


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - Local NAS Server")
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--cli', action='store_true', help='CLI mode')
    parser.add_argument('--status', action='store_true', help='Show status as JSON')
    parser.add_argument('--start', action='store_true', help='Start NAS services')
    parser.add_argument('--stop', action='store_true', help='Stop NAS services')
    parser.add_argument('--restart', action='store_true', help='Restart NAS services')
    parser.add_argument('--web', action='store_true', help='Start web interface only')
    parser.add_argument('--add-share', metavar='NAME:PATH', help='Add a share (name:path)')
    parser.add_argument('--add-user', metavar='USER:PASS', help='Add a user (username:password)')
    parser.add_argument('--list-shares', action='store_true', help='List all shares')
    parser.add_argument('--list-users', action='store_true', help='List all users')
    parser.add_argument('--list-disks', action='store_true', help='List all disks')
    parser.add_argument('--qr', action='store_true', help='Show connection QR code data')
    parser.add_argument('--version', action='version', version=f'{APP_NAME} v{VERSION}')
    
    args = parser.parse_args()
    service = NASService()
    
    if args.status:
        print(json.dumps(service.get_status(), indent=2))
    elif args.start:
        print("Starting NAS services...")
        results = service.start_all_services()
        service.start_web_interface()
        for svc, success in results.items():
            status = "started" if success else "failed"
            print(f"  {svc}: {status}")
        print(f"\nWeb interface: http://localhost:{service.config.web_port}")
    elif args.stop:
        print("Stopping NAS services...")
        results = service.stop_all_services()
        service.stop_web_interface()
        for svc, success in results.items():
            status = "stopped" if success else "failed"
            print(f"  {svc}: {status}")
    elif args.restart:
        print("Restarting NAS services...")
        service.stop_all_services()
        time.sleep(2)
        results = service.start_all_services()
        for svc, success in results.items():
            status = "restarted" if success else "failed"
            print(f"  {svc}: {status}")
    elif args.web:
        print(f"Starting web interface on port {service.config.web_port}...")
        service.start_web_interface()
        print(f"Web interface available at: http://localhost:{service.config.web_port}")
        print("Press Ctrl+C to stop")
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            service.stop_web_interface()
            print("\nWeb interface stopped")
    elif args.add_share:
        try:
            name, path = args.add_share.split(':', 1)
            share = service.add_share(name.strip(), path.strip())
            if share:
                print(f"Share '{share.name}' created at {share.path}")
            else:
                print("Failed to create share", file=sys.stderr)
                sys.exit(1)
        except ValueError:
            print("Invalid format. Use: --add-share 'name:path'", file=sys.stderr)
            sys.exit(1)
    elif args.add_user:
        try:
            username, password = args.add_user.split(':', 1)
            user = service.add_user(username.strip(), password)
            if user:
                print(f"User '{user.username}' created")
            else:
                print("Failed to create user", file=sys.stderr)
                sys.exit(1)
        except ValueError:
            print("Invalid format. Use: --add-user 'username:password'", file=sys.stderr)
            sys.exit(1)
    elif args.list_shares:
        shares = service.shares
        if shares:
            print("Configured Shares:")
            for share in shares.values():
                protocols = []
                if share.smb_enabled: protocols.append('SMB')
                if share.nfs_enabled: protocols.append('NFS')
                if share.webdav_enabled: protocols.append('WebDAV')
                print(f"  - {share.name}: {share.path} [{', '.join(protocols)}]")
        else:
            print("No shares configured")
    elif args.list_users:
        users = service.users
        if users:
            print("NAS Users:")
            for user in users.values():
                print(f"  - {user.username} ({user.access_level}) {'[enabled]' if user.enabled else '[disabled]'}")
        else:
            print("No users configured")
    elif args.list_disks:
        service._scan_disks()
        if service.disks:
            print("Available Disks:")
            for disk in service.disks.values():
                size_gb = disk.size_bytes / (1024**3)
                pool_info = f" [Pool: {disk.pool_id}]" if disk.in_pool else ""
                print(f"  - {disk.device}: {disk.model} ({size_gb:.1f} GB) - {disk.health}{pool_info}")
        else:
            print("No disks found")
    elif args.qr:
        qr_data = service.generate_qr_code()
        print("Connection data for mobile app:")
        print(qr_data)
    elif args.gui or not args.cli:
        if TKINTER_AVAILABLE:
            gui = NASManagerGUI(service)
            gui.run()
        else:
            print("GUI requires tkinter. Use --cli for command-line mode.")
            print("Use --help for all available options.")
            sys.exit(1)
    elif args.cli:
        print(f"{APP_NAME} v{VERSION}")
        print("Use --help for available commands")


if __name__ == "__main__":
    main()
