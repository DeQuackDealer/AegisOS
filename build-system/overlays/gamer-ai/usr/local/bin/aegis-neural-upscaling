#!/usr/bin/env python3
"""
Aegis Neural Upscaling - DLSS/FSR/XeSS configuration for Gamer AI edition
Features: DLSS 3.5, FSR 3.0, XeSS configs, frame generation

Provides GUI (GTK) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import shutil
from pathlib import Path
from typing import Dict, List, Any

TIER_LIMIT = "gamer-ai"
VERSION = "1.5.0"
APP_NAME = "Aegis Neural Upscaling"

CONFIG_FILE = "/etc/aegis/gamer-ai-config.json"
LOG_FILE = "/var/log/aegis/neural-upscaling.log"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False


class LicenseTier:
    FREEMIUM = 1
    GAMER = 4
    GAMER_AI = 5


UPSCALING_TECH = {
    "dlss": {
        "name": "NVIDIA DLSS 3.5",
        "vendor": "nvidia",
        "modes": ["Quality", "Balanced", "Performance", "Ultra Performance"],
        "features": ["Super Resolution", "Frame Generation", "Ray Reconstruction"]
    },
    "fsr": {
        "name": "AMD FSR 3.0",
        "vendor": "amd",
        "modes": ["Quality", "Balanced", "Performance", "Ultra Performance"],
        "features": ["Super Resolution", "Frame Generation"]
    },
    "xess": {
        "name": "Intel XeSS",
        "vendor": "intel",
        "modes": ["Quality", "Balanced", "Performance", "Ultra Performance"],
        "features": ["Super Resolution"]
    }
}


class AegisNeuralUpscaling:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.license_tier = LicenseTier.FREEMIUM
        self.config = {}
        
        self.setup_logging()
        self.load_license_tier()
        self.load_config()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
            logging.basicConfig(level=logging.INFO)
        except Exception:
            pass
        self.logger = logging.getLogger("AegisNeuralUpscaling")
    
    def load_license_tier(self):
        if Path("/etc/aegis-gamer-ai-marker").exists():
            self.license_tier = LicenseTier.GAMER_AI
    
    def is_feature_available(self) -> bool:
        return self.license_tier >= LicenseTier.GAMER_AI
    
    def load_config(self):
        self.config = {
            "default_mode": "quality",
            "frame_generation": True,
            "auto_detect": True
        }
    
    def detect_gpu_vendor(self) -> str:
        try:
            result = subprocess.run(["lspci"], capture_output=True, text=True)
            output = result.stdout.lower()
            if "nvidia" in output:
                return "nvidia"
            elif "amd" in output:
                return "amd"
            elif "intel" in output:
                return "intel"
        except Exception:
            pass
        return "unknown"
    
    def get_recommended_tech(self) -> str:
        vendor = self.detect_gpu_vendor()
        if vendor == "nvidia":
            return "dlss"
        elif vendor == "amd":
            return "fsr"
        elif vendor == "intel":
            return "xess"
        return "fsr"
    
    def get_upscaling_options(self) -> List[Dict[str, Any]]:
        options = []
        for tech_id, info in UPSCALING_TECH.items():
            options.append({
                "id": tech_id,
                "name": info["name"],
                "vendor": info["vendor"],
                "modes": info["modes"],
                "features": info["features"],
                "available": self.is_feature_available()
            })
        return options
    
    def set_upscaling_mode(self, tech: str, mode: str) -> Dict[str, Any]:
        if not self.is_feature_available():
            return {"success": False, "error": "Requires Gamer AI edition"}
        
        if tech not in UPSCALING_TECH:
            return {"success": False, "error": f"Unknown technology: {tech}"}
        
        if mode not in UPSCALING_TECH[tech]["modes"]:
            return {"success": False, "error": f"Invalid mode: {mode}"}
        
        self.logger.info(f"Setting {tech.upper()} to {mode} mode")
        return {"success": True, "technology": tech, "mode": mode}
    
    def get_status(self) -> Dict[str, Any]:
        return {
            "gpu_vendor": self.detect_gpu_vendor(),
            "recommended": self.get_recommended_tech(),
            "technologies": self.get_upscaling_options(),
            "current_config": self.config,
            "tier": self.license_tier
        }
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"{'='*60}\n")
        
        vendor = self.detect_gpu_vendor()
        recommended = self.get_recommended_tech()
        
        print(f"Detected GPU: {vendor.upper()}")
        print(f"Recommended Technology: {UPSCALING_TECH.get(recommended, {}).get('name', 'Unknown')}")
        
        print("\nUpscaling Technologies:")
        for tech in self.get_upscaling_options():
            status = "✓" if tech["available"] else "✗"
            print(f"  {tech['name']}: {status}")
            print(f"    Modes: {', '.join(tech['modes'])}")
            print(f"    Features: {', '.join(tech['features'])}")
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            return self.run_cli()
        
        win = Gtk.Window(title=f"{APP_NAME}")
        win.set_default_size(800, 600)
        win.connect("destroy", Gtk.main_quit)
        
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        win.add(vbox)
        
        header = Gtk.Label()
        header.set_markup(f"<big><b>{APP_NAME}</b></big>")
        vbox.pack_start(header, False, False, 20)
        
        vendor = self.detect_gpu_vendor()
        gpu_label = Gtk.Label(label=f"GPU Vendor: {vendor.upper()}")
        vbox.pack_start(gpu_label, False, False, 10)
        
        for tech in self.get_upscaling_options():
            hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            label = Gtk.Label(label=tech['name'])
            label.set_xalign(0)
            hbox.pack_start(label, True, True, 10)
            
            combo = Gtk.ComboBoxText()
            for mode in tech['modes']:
                combo.append_text(mode)
            combo.set_active(0)
            combo.set_sensitive(self.license_tier >= LicenseTier.GAMER_AI)
            hbox.pack_end(combo, False, False, 10)
            
            vbox.pack_start(hbox, False, False, 5)
        
        win.show_all()
        Gtk.main()


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME}")
    parser.add_argument("--gui", action="store_true")
    parser.add_argument("--cli", action="store_true")
    parser.add_argument("--set-mode", nargs=2, metavar=("TECH", "MODE"))
    parser.add_argument("--status", action="store_true")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.set_mode:
        app = AegisNeuralUpscaling(headless=True)
        result = app.set_upscaling_mode(args.set_mode[0], args.set_mode[1])
        print(json.dumps(result, indent=2))
    elif args.status:
        app = AegisNeuralUpscaling(headless=True)
        print(json.dumps(app.get_status(), indent=2))
    elif args.cli or not GTK_AVAILABLE:
        app = AegisNeuralUpscaling(headless=False)
        app.run_cli()
    else:
        app = AegisNeuralUpscaling(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
