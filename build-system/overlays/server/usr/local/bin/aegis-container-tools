#!/usr/bin/env python3
"""
Aegis Container Tools - Kubernetes and Docker Swarm management for Server edition
Features: K8s config, Docker Swarm, Podman support, registry management

Provides GUI (GTK) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import shutil
from pathlib import Path
from typing import Dict, List, Any

TIER_LIMIT = "server"
VERSION = "1.5.0"
APP_NAME = "Aegis Container Tools"

CONFIG_FILE = "/etc/aegis/server-config.json"
LOG_FILE = "/var/log/aegis/container-tools.log"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False


class LicenseTier:
    FREEMIUM = 1
    SERVER = 5


CONTAINER_TOOLS = {
    "docker": {"name": "Docker", "command": "docker", "description": "Container runtime"},
    "podman": {"name": "Podman", "command": "podman", "description": "Daemonless containers"},
    "kubectl": {"name": "Kubectl", "command": "kubectl", "description": "Kubernetes CLI"},
    "k3s": {"name": "K3s", "command": "k3s", "description": "Lightweight Kubernetes"},
    "helm": {"name": "Helm", "command": "helm", "description": "Kubernetes package manager"},
    "docker-compose": {"name": "Docker Compose", "command": "docker-compose", "description": "Multi-container apps"}
}


class AegisContainerTools:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.license_tier = LicenseTier.FREEMIUM
        
        self.setup_logging()
        self.load_license_tier()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
            logging.basicConfig(level=logging.INFO)
        except Exception:
            pass
        self.logger = logging.getLogger("AegisContainerTools")
    
    def load_license_tier(self):
        if Path("/etc/aegis-server-marker").exists():
            self.license_tier = LicenseTier.SERVER
    
    def is_feature_available(self) -> bool:
        return self.license_tier >= LicenseTier.SERVER
    
    def check_tool_installed(self, command: str) -> bool:
        return shutil.which(command) is not None
    
    def get_tools_status(self) -> List[Dict[str, Any]]:
        tools = []
        for tool_id, info in CONTAINER_TOOLS.items():
            tools.append({
                "id": tool_id,
                "name": info["name"],
                "description": info["description"],
                "installed": self.check_tool_installed(info["command"])
            })
        return tools
    
    def list_docker_containers(self) -> List[Dict[str, Any]]:
        if not self.check_tool_installed("docker"):
            return []
        
        try:
            result = subprocess.run(
                ["docker", "ps", "--format", "{{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Image}}"],
                capture_output=True, text=True, timeout=30
            )
            if result.returncode == 0:
                containers = []
                for line in result.stdout.strip().split('\n'):
                    if line:
                        parts = line.split('\t')
                        if len(parts) >= 4:
                            containers.append({
                                "id": parts[0],
                                "name": parts[1],
                                "status": parts[2],
                                "image": parts[3]
                            })
                return containers
        except Exception:
            pass
        return []
    
    def list_k8s_pods(self) -> List[Dict[str, Any]]:
        if not self.check_tool_installed("kubectl"):
            return []
        
        try:
            result = subprocess.run(
                ["kubectl", "get", "pods", "-o", "json"],
                capture_output=True, text=True, timeout=30
            )
            if result.returncode == 0:
                data = json.loads(result.stdout)
                pods = []
                for item in data.get("items", []):
                    pods.append({
                        "name": item["metadata"]["name"],
                        "namespace": item["metadata"]["namespace"],
                        "status": item["status"]["phase"]
                    })
                return pods
        except Exception:
            pass
        return []
    
    def _detect_runtime(self) -> str:
        """Detect available container runtime (docker or podman)."""
        if self.check_tool_installed("docker"):
            try:
                result = subprocess.run(
                    ["docker", "info"],
                    capture_output=True, text=True, timeout=10
                )
                if result.returncode == 0:
                    return "docker"
            except Exception:
                pass
        
        if self.check_tool_installed("podman"):
            try:
                result = subprocess.run(
                    ["podman", "info"],
                    capture_output=True, text=True, timeout=10
                )
                if result.returncode == 0:
                    return "podman"
            except Exception:
                pass
        
        return ""
    
    def _list_containers(self, all_containers: bool = True) -> List[Dict[str, Any]]:
        """List containers using detected runtime (docker ps -a or podman ps -a)."""
        runtime = self._detect_runtime()
        if not runtime:
            return []
        
        try:
            cmd = [runtime, "ps", "--format", "{{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Image}}"]
            if all_containers:
                cmd.insert(2, "-a")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                containers = []
                for line in result.stdout.strip().split('\n'):
                    if line:
                        parts = line.split('\t')
                        if len(parts) >= 4:
                            containers.append({
                                "id": parts[0],
                                "name": parts[1],
                                "status": parts[2],
                                "image": parts[3],
                                "runtime": runtime
                            })
                return containers
        except Exception as e:
            self.logger.error(f"Error listing containers: {e}")
        return []
    
    def _list_images(self) -> List[Dict[str, Any]]:
        """List images using detected runtime (docker images or podman images)."""
        runtime = self._detect_runtime()
        if not runtime:
            return []
        
        try:
            result = subprocess.run(
                [runtime, "images", "--format", "{{.ID}}\t{{.Repository}}\t{{.Tag}}\t{{.Size}}"],
                capture_output=True, text=True, timeout=30
            )
            if result.returncode == 0:
                images = []
                for line in result.stdout.strip().split('\n'):
                    if line:
                        parts = line.split('\t')
                        if len(parts) >= 4:
                            images.append({
                                "id": parts[0],
                                "repository": parts[1],
                                "tag": parts[2],
                                "size": parts[3],
                                "runtime": runtime
                            })
                return images
        except Exception as e:
            self.logger.error(f"Error listing images: {e}")
        return []
    
    def _start_container(self, container: str) -> Dict[str, Any]:
        """Start a container using detected runtime (docker start or podman start)."""
        runtime = self._detect_runtime()
        if not runtime:
            return {"success": False, "error": "No container runtime available"}
        
        try:
            result = subprocess.run(
                [runtime, "start", container],
                capture_output=True, text=True, timeout=60
            )
            if result.returncode == 0:
                return {"success": True, "container": container, "runtime": runtime}
            else:
                return {"success": False, "error": result.stderr.strip(), "runtime": runtime}
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Command timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _stop_container(self, container: str) -> Dict[str, Any]:
        """Stop a container using detected runtime (docker stop or podman stop)."""
        runtime = self._detect_runtime()
        if not runtime:
            return {"success": False, "error": "No container runtime available"}
        
        try:
            result = subprocess.run(
                [runtime, "stop", container],
                capture_output=True, text=True, timeout=60
            )
            if result.returncode == 0:
                return {"success": True, "container": container, "runtime": runtime}
            else:
                return {"success": False, "error": result.stderr.strip(), "runtime": runtime}
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Command timed out"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _pull_image(self, image: str) -> Dict[str, Any]:
        """Pull an image using detected runtime (docker pull or podman pull)."""
        runtime = self._detect_runtime()
        if not runtime:
            return {"success": False, "error": "No container runtime available"}
        
        try:
            result = subprocess.run(
                [runtime, "pull", image],
                capture_output=True, text=True, timeout=300
            )
            if result.returncode == 0:
                return {"success": True, "image": image, "runtime": runtime, "output": result.stdout.strip()}
            else:
                return {"success": False, "error": result.stderr.strip(), "runtime": runtime}
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Command timed out (5 minutes)"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _build_image(self, dockerfile_path: str, tag: str = None, context_path: str = None) -> Dict[str, Any]:
        """Build an image using detected runtime (docker build or podman build)."""
        runtime = self._detect_runtime()
        if not runtime:
            return {"success": False, "error": "No container runtime available"}
        
        dockerfile = Path(dockerfile_path)
        if not dockerfile.exists():
            return {"success": False, "error": f"Dockerfile not found: {dockerfile_path}"}
        
        if context_path is None:
            context_path = str(dockerfile.parent)
        
        try:
            cmd = [runtime, "build", "-f", str(dockerfile)]
            if tag:
                cmd.extend(["-t", tag])
            cmd.append(context_path)
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            if result.returncode == 0:
                return {
                    "success": True,
                    "tag": tag,
                    "runtime": runtime,
                    "output": result.stdout.strip()
                }
            else:
                return {"success": False, "error": result.stderr.strip(), "runtime": runtime}
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Build timed out (10 minutes)"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def get_status(self) -> Dict[str, Any]:
        return {
            "tools": self.get_tools_status(),
            "runtime": self._detect_runtime(),
            "containers": len(self._list_containers()),
            "images": len(self._list_images()),
            "k8s_pods": len(self.list_k8s_pods()),
            "tier": self.license_tier
        }
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"{'='*60}\n")
        
        tools = self.get_tools_status()
        print("Container Tools:")
        for tool in tools:
            status = "✓" if tool["installed"] else "✗"
            print(f"  {tool['name']}: {status} - {tool['description']}")
        
        containers = self.list_docker_containers()
        if containers:
            print(f"\nRunning Docker Containers: {len(containers)}")
            for c in containers[:5]:
                print(f"  {c['name']}: {c['status']}")
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            return self.run_cli()
        
        win = Gtk.Window(title=f"{APP_NAME}")
        win.set_default_size(800, 600)
        win.connect("destroy", Gtk.main_quit)
        
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        win.add(vbox)
        
        header = Gtk.Label()
        header.set_markup(f"<big><b>{APP_NAME}</b></big>")
        vbox.pack_start(header, False, False, 20)
        
        for tool in self.get_tools_status():
            label = Gtk.Label(label=f"{'✓' if tool['installed'] else '✗'} {tool['name']}")
            label.set_xalign(0)
            vbox.pack_start(label, False, False, 5)
        
        win.show_all()
        Gtk.main()


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME}")
    parser.add_argument("--gui", action="store_true")
    parser.add_argument("--cli", action="store_true")
    parser.add_argument("--list-containers", action="store_true")
    parser.add_argument("--list-pods", action="store_true")
    parser.add_argument("--status", action="store_true")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.list_containers:
        app = AegisContainerTools(headless=True)
        print(json.dumps(app.list_docker_containers(), indent=2))
    elif args.list_pods:
        app = AegisContainerTools(headless=True)
        print(json.dumps(app.list_k8s_pods(), indent=2))
    elif args.status:
        app = AegisContainerTools(headless=True)
        print(json.dumps(app.get_status(), indent=2))
    elif args.cli or not GTK_AVAILABLE:
        app = AegisContainerTools(headless=False)
        app.run_cli()
    else:
        app = AegisContainerTools(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
