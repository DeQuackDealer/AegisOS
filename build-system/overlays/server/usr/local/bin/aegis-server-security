#!/usr/bin/env python3
"""
Aegis Server Security - XDR and threat intelligence for Server edition
Features: Extended detection, threat intelligence, IDS, advanced firewall

Provides GUI (GTK) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import shutil
import time
import threading
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any

TIER_LIMIT = "server"
VERSION = "1.5.0"
APP_NAME = "Aegis Server Security"

CONFIG_FILE = "/etc/aegis/server-config.json"
LOG_FILE = "/var/log/aegis/server-security.log"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False


class LicenseTier:
    FREEMIUM = 1
    BASIC = 2
    SERVER = 5


SECURITY_TOOLS = {
    "suricata": {"name": "Suricata IDS", "command": "suricata", "description": "Network threat detection"},
    "ossec": {"name": "OSSEC HIDS", "command": "ossec-control", "description": "Host-based intrusion detection"},
    "fail2ban": {"name": "Fail2ban", "command": "fail2ban-client", "description": "Brute force protection"},
    "clamav": {"name": "ClamAV", "command": "clamscan", "description": "Antivirus scanning"},
    "rkhunter": {"name": "Rootkit Hunter", "command": "rkhunter", "description": "Rootkit detection"},
    "lynis": {"name": "Lynis", "command": "lynis", "description": "Security auditing"}
}

THREAT_INTEL_FEEDS = [
    {"name": "Emerging Threats", "url": "https://rules.emergingthreats.net/"},
    {"name": "Abuse.ch", "url": "https://abuse.ch/"},
    {"name": "AlienVault OTX", "url": "https://otx.alienvault.com/"}
]


class AegisServerSecurity:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.config = {}
        self.license_tier = LicenseTier.FREEMIUM
        self.daemon_running = False
        
        self.setup_logging()
        self.load_license_tier()
        self.load_config()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[
                    logging.FileHandler(LOG_FILE) if os.access(str(log_dir), os.W_OK) else logging.NullHandler(),
                    logging.StreamHandler() if not self.headless else logging.NullHandler()
                ]
            )
        except Exception:
            logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger("AegisServerSecurity")
    
    def load_license_tier(self):
        if Path("/etc/aegis-server-marker").exists():
            self.license_tier = LicenseTier.SERVER
    
    def is_feature_available(self) -> bool:
        return self.license_tier >= LicenseTier.SERVER
    
    def load_config(self):
        self.config = {
            "xdr_enabled": True,
            "threat_intelligence": True,
            "ids_enabled": True
        }
    
    def check_tool_installed(self, command: str) -> bool:
        return shutil.which(command) is not None
    
    def get_security_tools_status(self) -> List[Dict[str, Any]]:
        tools = []
        for tool_id, tool_info in SECURITY_TOOLS.items():
            tools.append({
                "id": tool_id,
                "name": tool_info["name"],
                "description": tool_info["description"],
                "installed": self.check_tool_installed(tool_info["command"])
            })
        return tools
    
    def run_security_scan(self, scan_type: str = "quick") -> Dict[str, Any]:
        if not self.is_feature_available():
            return {"success": False, "error": "Requires Server edition"}
        
        results = {"scan_type": scan_type, "timestamp": datetime.now().isoformat(), "findings": []}
        
        if self.check_tool_installed("lynis"):
            try:
                result = subprocess.run(
                    ["lynis", "audit", "system", "--quick"],
                    capture_output=True, text=True, timeout=300
                )
                results["lynis_ran"] = result.returncode == 0
            except Exception as e:
                results["errors"] = [str(e)]
        
        return results
    
    def get_active_connections(self) -> List[Dict[str, Any]]:
        connections = []
        try:
            result = subprocess.run(
                ["ss", "-tuln"],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n')[1:]:
                    parts = line.split()
                    if len(parts) >= 5:
                        connections.append({
                            "protocol": parts[0],
                            "local": parts[4],
                            "state": parts[1] if len(parts) > 1 else "LISTEN"
                        })
        except Exception:
            pass
        return connections
    
    def _check_firewall_status(self) -> Dict[str, Any]:
        result = {
            "status": "unknown",
            "tool": None,
            "rules": [],
            "active": False,
            "error": None
        }
        
        try:
            if self.check_tool_installed("ufw"):
                proc = subprocess.run(
                    ["ufw", "status", "verbose"],
                    capture_output=True, text=True, timeout=10
                )
                result["tool"] = "ufw"
                if proc.returncode == 0:
                    output = proc.stdout.strip()
                    result["status"] = "active" if "Status: active" in output else "inactive"
                    result["active"] = "Status: active" in output
                    lines = output.split('\n')
                    for line in lines:
                        if line and not line.startswith('Status:') and not line.startswith('Logging:') and not line.startswith('Default:'):
                            result["rules"].append(line.strip())
                else:
                    result["error"] = proc.stderr.strip()
            elif self.check_tool_installed("iptables"):
                proc = subprocess.run(
                    ["iptables", "-L", "-n", "-v"],
                    capture_output=True, text=True, timeout=10
                )
                result["tool"] = "iptables"
                if proc.returncode == 0:
                    output = proc.stdout.strip()
                    result["status"] = "active"
                    result["active"] = True
                    lines = output.split('\n')
                    current_chain = None
                    for line in lines:
                        if line.startswith('Chain'):
                            current_chain = line
                        elif line and not line.startswith('pkts') and current_chain:
                            result["rules"].append(f"{current_chain}: {line.strip()}")
                else:
                    result["error"] = proc.stderr.strip()
            else:
                result["error"] = "No firewall tool (ufw or iptables) found"
        except subprocess.TimeoutExpired:
            result["error"] = "Command timed out"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _check_fail2ban_status(self) -> Dict[str, Any]:
        result = {
            "installed": False,
            "running": False,
            "jails": [],
            "banned_ips": {},
            "error": None
        }
        
        try:
            if not self.check_tool_installed("fail2ban-client"):
                result["error"] = "fail2ban-client not installed"
                return result
            
            result["installed"] = True
            
            proc = subprocess.run(
                ["fail2ban-client", "status"],
                capture_output=True, text=True, timeout=10
            )
            
            if proc.returncode == 0:
                result["running"] = True
                output = proc.stdout
                for line in output.split('\n'):
                    if 'Jail list:' in line:
                        jails_part = line.split('Jail list:')[1].strip()
                        result["jails"] = [j.strip() for j in jails_part.split(',') if j.strip()]
                
                for jail in result["jails"]:
                    try:
                        jail_proc = subprocess.run(
                            ["fail2ban-client", "status", jail],
                            capture_output=True, text=True, timeout=10
                        )
                        if jail_proc.returncode == 0:
                            jail_output = jail_proc.stdout
                            banned_count = 0
                            banned_list = []
                            for line in jail_output.split('\n'):
                                if 'Currently banned:' in line:
                                    try:
                                        banned_count = int(line.split(':')[1].strip())
                                    except ValueError:
                                        pass
                                elif 'Banned IP list:' in line:
                                    ips = line.split(':')[1].strip()
                                    banned_list = [ip.strip() for ip in ips.split() if ip.strip()]
                            result["banned_ips"][jail] = {
                                "count": banned_count,
                                "ips": banned_list
                            }
                    except Exception:
                        pass
            else:
                result["error"] = proc.stderr.strip() or "fail2ban service not running"
        except subprocess.TimeoutExpired:
            result["error"] = "Command timed out"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _list_open_ports(self) -> Dict[str, Any]:
        result = {
            "ports": [],
            "count": 0,
            "error": None
        }
        
        try:
            proc = subprocess.run(
                ["ss", "-tlnp"],
                capture_output=True, text=True, timeout=10
            )
            
            if proc.returncode == 0:
                lines = proc.stdout.strip().split('\n')
                for line in lines[1:]:
                    parts = line.split()
                    if len(parts) >= 5:
                        local_addr = parts[3]
                        if ':' in local_addr:
                            addr_parts = local_addr.rsplit(':', 1)
                            address = addr_parts[0]
                            port = addr_parts[1]
                        else:
                            address = "*"
                            port = local_addr
                        
                        process_info = ""
                        if len(parts) >= 6:
                            for part in parts[5:]:
                                if 'users:' in part:
                                    process_info = part
                                    break
                        
                        result["ports"].append({
                            "state": parts[0],
                            "recv_q": parts[1],
                            "send_q": parts[2],
                            "local_address": address,
                            "port": port,
                            "process": process_info
                        })
                result["count"] = len(result["ports"])
            else:
                result["error"] = proc.stderr.strip()
        except subprocess.TimeoutExpired:
            result["error"] = "Command timed out"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _check_ssh_config(self) -> Dict[str, Any]:
        result = {
            "file_exists": False,
            "readable": False,
            "settings": {},
            "security_recommendations": [],
            "error": None
        }
        
        ssh_config_path = Path("/etc/ssh/sshd_config")
        
        try:
            if not ssh_config_path.exists():
                result["error"] = "sshd_config not found"
                return result
            
            result["file_exists"] = True
            
            security_settings = [
                "PermitRootLogin",
                "PasswordAuthentication",
                "PubkeyAuthentication",
                "PermitEmptyPasswords",
                "X11Forwarding",
                "MaxAuthTries",
                "Protocol",
                "Port",
                "AllowUsers",
                "AllowGroups",
                "DenyUsers",
                "DenyGroups",
                "LoginGraceTime",
                "ClientAliveInterval",
                "ClientAliveCountMax",
                "UsePAM",
                "ChallengeResponseAuthentication"
            ]
            
            with open(ssh_config_path, 'r') as f:
                result["readable"] = True
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        parts = line.split(None, 1)
                        if len(parts) >= 2:
                            key = parts[0]
                            value = parts[1]
                            if key in security_settings:
                                result["settings"][key] = value
            
            if result["settings"].get("PermitRootLogin", "").lower() not in ["no", "prohibit-password"]:
                result["security_recommendations"].append("Consider disabling root login (PermitRootLogin no)")
            
            if result["settings"].get("PasswordAuthentication", "").lower() == "yes":
                result["security_recommendations"].append("Consider disabling password authentication in favor of key-based auth")
            
            if result["settings"].get("PermitEmptyPasswords", "").lower() == "yes":
                result["security_recommendations"].append("CRITICAL: Empty passwords are permitted - disable immediately")
            
            if result["settings"].get("X11Forwarding", "").lower() == "yes":
                result["security_recommendations"].append("X11 forwarding is enabled - disable if not needed")
            
            max_tries = result["settings"].get("MaxAuthTries", "6")
            try:
                if int(max_tries) > 4:
                    result["security_recommendations"].append(f"MaxAuthTries is {max_tries} - consider lowering to 3-4")
            except ValueError:
                pass
                
        except PermissionError:
            result["error"] = "Permission denied reading sshd_config"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _run_rootkit_scan(self) -> Dict[str, Any]:
        result = {
            "tool_used": None,
            "scan_completed": False,
            "warnings": [],
            "infected": [],
            "suspects": [],
            "error": None
        }
        
        try:
            if self.check_tool_installed("rkhunter"):
                result["tool_used"] = "rkhunter"
                proc = subprocess.run(
                    ["rkhunter", "--check", "--skip-keypress", "--report-warnings-only"],
                    capture_output=True, text=True, timeout=600
                )
                result["scan_completed"] = True
                output = proc.stdout + proc.stderr
                
                for line in output.split('\n'):
                    line = line.strip()
                    if 'Warning:' in line:
                        result["warnings"].append(line)
                    elif 'INFECTED' in line or 'infected' in line:
                        result["infected"].append(line)
                    elif 'SUSPECT' in line or 'suspect' in line:
                        result["suspects"].append(line)
                        
            elif self.check_tool_installed("chkrootkit"):
                result["tool_used"] = "chkrootkit"
                proc = subprocess.run(
                    ["chkrootkit"],
                    capture_output=True, text=True, timeout=600
                )
                result["scan_completed"] = True
                output = proc.stdout + proc.stderr
                
                for line in output.split('\n'):
                    line = line.strip()
                    if 'INFECTED' in line:
                        result["infected"].append(line)
                    elif 'Warning:' in line or 'warning:' in line:
                        result["warnings"].append(line)
                    elif 'Searching' not in line and 'nothing found' not in line.lower() and line:
                        if any(kw in line.lower() for kw in ['suspect', 'found', 'possible']):
                            result["suspects"].append(line)
            else:
                result["error"] = "No rootkit scanner (rkhunter or chkrootkit) installed"
                
        except subprocess.TimeoutExpired:
            result["error"] = "Rootkit scan timed out (10 minute limit)"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def _audit_sudo_logs(self, max_entries: int = 100) -> Dict[str, Any]:
        result = {
            "log_file": None,
            "readable": False,
            "sudo_events": [],
            "failed_attempts": [],
            "users": {},
            "error": None
        }
        
        log_paths = [
            Path("/var/log/auth.log"),
            Path("/var/log/secure"),
            Path("/var/log/auth.log.1")
        ]
        
        log_file = None
        for path in log_paths:
            if path.exists():
                log_file = path
                break
        
        if not log_file:
            result["error"] = "No auth log file found (checked /var/log/auth.log, /var/log/secure)"
            return result
        
        result["log_file"] = str(log_file)
        
        try:
            with open(log_file, 'r') as f:
                result["readable"] = True
                lines = f.readlines()
                
                sudo_lines = [line for line in lines if 'sudo' in line.lower()]
                
                recent_lines = sudo_lines[-max_entries:] if len(sudo_lines) > max_entries else sudo_lines
                
                for line in recent_lines:
                    line = line.strip()
                    
                    event = {
                        "raw": line,
                        "timestamp": "",
                        "user": "",
                        "command": "",
                        "success": True
                    }
                    
                    parts = line.split()
                    if len(parts) >= 3:
                        event["timestamp"] = ' '.join(parts[:3])
                    
                    if 'authentication failure' in line.lower() or 'auth could not identify' in line.lower():
                        event["success"] = False
                        result["failed_attempts"].append(event)
                    
                    if 'COMMAND=' in line:
                        try:
                            cmd_start = line.index('COMMAND=')
                            event["command"] = line[cmd_start + 8:].strip()
                        except ValueError:
                            pass
                    
                    if 'USER=' in line:
                        try:
                            user_start = line.index('USER=')
                            user_end = line.find(' ', user_start)
                            if user_end == -1:
                                user_end = len(line)
                            event["user"] = line[user_start + 5:user_end].strip()
                        except ValueError:
                            pass
                    
                    for part in parts:
                        if 'sudo:' in part or 'sudo[' in part:
                            idx = parts.index(part)
                            if idx + 1 < len(parts):
                                potential_user = parts[idx + 1].rstrip(':')
                                if potential_user and not potential_user.startswith('('):
                                    if not event["user"]:
                                        event["user"] = potential_user
                    
                    result["sudo_events"].append(event)
                    
                    if event["user"]:
                        if event["user"] not in result["users"]:
                            result["users"][event["user"]] = {"total": 0, "failed": 0}
                        result["users"][event["user"]]["total"] += 1
                        if not event["success"]:
                            result["users"][event["user"]]["failed"] += 1
                            
        except PermissionError:
            result["error"] = f"Permission denied reading {log_file}"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def get_status(self) -> Dict[str, Any]:
        return {
            "tools": self.get_security_tools_status(),
            "active_connections": len(self.get_active_connections()),
            "threat_feeds": len(THREAT_INTEL_FEEDS),
            "tier": self.license_tier
        }
    
    def run_daemon(self):
        self.daemon_running = True
        self.logger.info("Starting server security daemon")
        while self.daemon_running:
            time.sleep(60)
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"{'='*60}\n")
        
        tools = self.get_security_tools_status()
        print("Security Tools:")
        for tool in tools:
            status = "✓" if tool["installed"] else "✗"
            print(f"  {tool['name']}: {status} - {tool['description']}")
        
        print(f"\nActive Connections: {len(self.get_active_connections())}")
        print(f"Threat Intelligence Feeds: {len(THREAT_INTEL_FEEDS)}")
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            return self.run_cli()
        
        win = Gtk.Window(title=f"{APP_NAME}")
        win.set_default_size(800, 600)
        win.connect("destroy", Gtk.main_quit)
        
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        win.add(vbox)
        
        header = Gtk.Label()
        header.set_markup(f"<big><b>{APP_NAME}</b></big>")
        vbox.pack_start(header, False, False, 20)
        
        for tool in self.get_security_tools_status():
            label = Gtk.Label(label=f"{'✓' if tool['installed'] else '✗'} {tool['name']}")
            label.set_xalign(0)
            vbox.pack_start(label, False, False, 5)
        
        win.show_all()
        Gtk.main()


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME}")
    parser.add_argument("--gui", action="store_true")
    parser.add_argument("--cli", action="store_true")
    parser.add_argument("--daemon", action="store_true")
    parser.add_argument("--scan", action="store_true")
    parser.add_argument("--status", action="store_true")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.daemon:
        app = AegisServerSecurity(headless=True)
        app.run_daemon()
    elif args.scan:
        app = AegisServerSecurity(headless=True)
        print(json.dumps(app.run_security_scan(), indent=2))
    elif args.status:
        app = AegisServerSecurity(headless=True)
        print(json.dumps(app.get_status(), indent=2))
    elif args.cli or not GTK_AVAILABLE:
        app = AegisServerSecurity(headless=False)
        app.run_cli()
    else:
        app = AegisServerSecurity(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
