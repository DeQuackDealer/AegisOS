#!/usr/bin/env python3
"""
Aegis Monitoring - SIEM and log aggregation for Server edition
Features: SIEM setup, log aggregation, alerting, dashboards

Provides GUI (GTK) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import shutil
import time
import threading
import re
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional, Callable

TIER_LIMIT = "server"
VERSION = "1.6.0"
APP_NAME = "Aegis Monitoring"

CONFIG_FILE = "/etc/aegis/server-config.json"
LOG_FILE = "/var/log/aegis/monitoring.log"
ALERTS_FILE = "/var/log/aegis/alerts.log"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False
    print("Error: GTK3 is required. Install with: sudo pacman -S gtk3 python-gobject", file=sys.stderr)


class LicenseTier:
    FREEMIUM = 1
    SERVER = 5


MONITORING_TOOLS = {
    "prometheus": {"name": "Prometheus", "command": "prometheus", "port": 9090},
    "grafana": {"name": "Grafana", "command": "grafana-server", "port": 3000},
    "loki": {"name": "Loki", "command": "loki", "port": 3100},
    "alertmanager": {"name": "Alertmanager", "command": "alertmanager", "port": 9093},
    "node_exporter": {"name": "Node Exporter", "command": "node_exporter", "port": 9100}
}

DEFAULT_THRESHOLDS = {
    "cpu_percent": 90.0,
    "memory_percent": 85.0,
    "disk_percent": 90.0,
    "load_1m": 10.0,
    "network_errors": 100
}


class AegisMonitoring:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.license_tier = LicenseTier.FREEMIUM
        self.daemon_running = False
        self.collector_running = False
        self.collector_thread: Optional[threading.Thread] = None
        self.metrics_history: List[Dict[str, Any]] = []
        self.max_history = 1000
        self.collection_interval = 60
        self.thresholds = DEFAULT_THRESHOLDS.copy()
        self.alert_callbacks: List[Callable[[str, Dict[str, Any]], None]] = []
        self._prev_cpu_stats: Optional[Dict[str, int]] = None
        self._prev_net_stats: Optional[Dict[str, Dict[str, int]]] = None
        
        self.setup_logging()
        self.load_license_tier()
        self.load_config()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
            logging.basicConfig(level=logging.INFO)
        except Exception:
            pass
        self.logger = logging.getLogger("AegisMonitoring")
    
    def load_license_tier(self):
        if Path("/etc/aegis-server-marker").exists():
            self.license_tier = LicenseTier.SERVER
    
    def load_config(self):
        try:
            if Path(CONFIG_FILE).exists():
                with open(CONFIG_FILE, "r") as f:
                    config = json.load(f)
                    if "thresholds" in config:
                        self.thresholds.update(config["thresholds"])
                    if "collection_interval" in config:
                        self.collection_interval = config["collection_interval"]
        except Exception:
            pass
    
    def is_feature_available(self) -> bool:
        return self.license_tier >= LicenseTier.SERVER
    
    def check_tool_installed(self, command: str) -> bool:
        return shutil.which(command) is not None
    
    def check_service_running(self, service: str) -> bool:
        try:
            result = subprocess.run(
                ["systemctl", "is-active", service],
                capture_output=True, text=True, timeout=10
            )
            return result.stdout.strip() == "active"
        except Exception:
            return False
    
    def get_tools_status(self) -> List[Dict[str, Any]]:
        tools = []
        for tool_id, info in MONITORING_TOOLS.items():
            tools.append({
                "id": tool_id,
                "name": info["name"],
                "port": info["port"],
                "installed": self.check_tool_installed(info["command"]),
                "running": self.check_service_running(tool_id)
            })
        return tools
    
    def _get_system_metrics(self) -> Dict[str, Any]:
        metrics = {
            "timestamp": datetime.now().isoformat(),
            "cpu": self._get_cpu_metrics(),
            "memory": self._get_memory_metrics(),
            "disk": self._get_disk_metrics(),
            "network": self._get_network_metrics(),
            "load": self._get_load_metrics()
        }
        return metrics
    
    def _get_cpu_metrics(self) -> Dict[str, Any]:
        cpu_metrics = {
            "cores": 0,
            "usage_percent": 0.0,
            "per_cpu": [],
            "user": 0.0,
            "system": 0.0,
            "idle": 0.0,
            "iowait": 0.0
        }
        
        try:
            with open("/proc/cpuinfo", "r") as f:
                content = f.read()
                cpu_metrics["cores"] = content.count("processor")
        except Exception:
            pass
        
        try:
            with open("/proc/stat", "r") as f:
                lines = f.readlines()
                
            current_stats = {}
            for line in lines:
                if line.startswith("cpu"):
                    parts = line.split()
                    cpu_name = parts[0]
                    values = [int(x) for x in parts[1:8]]
                    current_stats[cpu_name] = {
                        "user": values[0],
                        "nice": values[1],
                        "system": values[2],
                        "idle": values[3],
                        "iowait": values[4] if len(values) > 4 else 0,
                        "irq": values[5] if len(values) > 5 else 0,
                        "softirq": values[6] if len(values) > 6 else 0
                    }
            
            if self._prev_cpu_stats and "cpu" in current_stats and "cpu" in self._prev_cpu_stats:
                prev = self._prev_cpu_stats["cpu"]
                curr = current_stats["cpu"]
                
                user_diff = curr["user"] - prev["user"]
                system_diff = curr["system"] - prev["system"]
                idle_diff = curr["idle"] - prev["idle"]
                iowait_diff = curr["iowait"] - prev["iowait"]
                total_diff = user_diff + system_diff + idle_diff + iowait_diff + \
                            (curr["nice"] - prev["nice"]) + (curr["irq"] - prev["irq"]) + \
                            (curr["softirq"] - prev["softirq"])
                
                if total_diff > 0:
                    cpu_metrics["user"] = round((user_diff / total_diff) * 100, 2)
                    cpu_metrics["system"] = round((system_diff / total_diff) * 100, 2)
                    cpu_metrics["idle"] = round((idle_diff / total_diff) * 100, 2)
                    cpu_metrics["iowait"] = round((iowait_diff / total_diff) * 100, 2)
                    cpu_metrics["usage_percent"] = round(100 - cpu_metrics["idle"], 2)
                
                for cpu_name in current_stats:
                    if cpu_name != "cpu" and cpu_name in self._prev_cpu_stats:
                        prev_cpu = self._prev_cpu_stats[cpu_name]
                        curr_cpu = current_stats[cpu_name]
                        cpu_total_diff = sum(curr_cpu.values()) - sum(prev_cpu.values())
                        if cpu_total_diff > 0:
                            cpu_idle_diff = curr_cpu["idle"] - prev_cpu["idle"]
                            cpu_metrics["per_cpu"].append({
                                "name": cpu_name,
                                "usage_percent": round(100 - (cpu_idle_diff / cpu_total_diff) * 100, 2)
                            })
            
            self._prev_cpu_stats = current_stats
            
        except Exception as e:
            self.logger.debug(f"Error reading CPU stats: {e}")
        
        return cpu_metrics
    
    def _get_memory_metrics(self) -> Dict[str, Any]:
        mem_metrics = {
            "total_kb": 0,
            "available_kb": 0,
            "used_kb": 0,
            "free_kb": 0,
            "buffers_kb": 0,
            "cached_kb": 0,
            "swap_total_kb": 0,
            "swap_free_kb": 0,
            "swap_used_kb": 0,
            "usage_percent": 0.0
        }
        
        try:
            with open("/proc/meminfo", "r") as f:
                for line in f:
                    parts = line.split()
                    key = parts[0].rstrip(":")
                    value = int(parts[1])
                    
                    if key == "MemTotal":
                        mem_metrics["total_kb"] = value
                    elif key == "MemAvailable":
                        mem_metrics["available_kb"] = value
                    elif key == "MemFree":
                        mem_metrics["free_kb"] = value
                    elif key == "Buffers":
                        mem_metrics["buffers_kb"] = value
                    elif key == "Cached":
                        mem_metrics["cached_kb"] = value
                    elif key == "SwapTotal":
                        mem_metrics["swap_total_kb"] = value
                    elif key == "SwapFree":
                        mem_metrics["swap_free_kb"] = value
            
            mem_metrics["used_kb"] = mem_metrics["total_kb"] - mem_metrics["available_kb"]
            mem_metrics["swap_used_kb"] = mem_metrics["swap_total_kb"] - mem_metrics["swap_free_kb"]
            
            if mem_metrics["total_kb"] > 0:
                mem_metrics["usage_percent"] = round(
                    (mem_metrics["used_kb"] / mem_metrics["total_kb"]) * 100, 2
                )
        except Exception as e:
            self.logger.debug(f"Error reading memory stats: {e}")
        
        return mem_metrics
    
    def _get_disk_metrics(self) -> Dict[str, Any]:
        disk_metrics = {
            "filesystems": [],
            "io_stats": []
        }
        
        try:
            result = subprocess.run(
                ["df", "-k", "--output=source,fstype,size,used,avail,pcent,target"],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')[1:]
                for line in lines:
                    parts = line.split()
                    if len(parts) >= 7 and not parts[0].startswith("tmpfs"):
                        disk_metrics["filesystems"].append({
                            "device": parts[0],
                            "fstype": parts[1],
                            "size_kb": int(parts[2]),
                            "used_kb": int(parts[3]),
                            "available_kb": int(parts[4]),
                            "usage_percent": float(parts[5].rstrip('%')),
                            "mount_point": parts[6]
                        })
        except Exception as e:
            self.logger.debug(f"Error getting disk usage: {e}")
        
        try:
            with open("/proc/diskstats", "r") as f:
                for line in f:
                    parts = line.split()
                    if len(parts) >= 14:
                        device = parts[2]
                        if re.match(r'^(sd[a-z]+|nvme\d+n\d+|vd[a-z]+)$', device):
                            disk_metrics["io_stats"].append({
                                "device": device,
                                "reads_completed": int(parts[3]),
                                "reads_merged": int(parts[4]),
                                "sectors_read": int(parts[5]),
                                "read_time_ms": int(parts[6]),
                                "writes_completed": int(parts[7]),
                                "writes_merged": int(parts[8]),
                                "sectors_written": int(parts[9]),
                                "write_time_ms": int(parts[10]),
                                "io_in_progress": int(parts[11]),
                                "io_time_ms": int(parts[12]),
                                "weighted_io_time_ms": int(parts[13])
                            })
        except Exception as e:
            self.logger.debug(f"Error reading disk I/O stats: {e}")
        
        return disk_metrics
    
    def _get_network_metrics(self) -> Dict[str, Any]:
        net_metrics = {
            "interfaces": [],
            "total_rx_bytes": 0,
            "total_tx_bytes": 0,
            "total_rx_packets": 0,
            "total_tx_packets": 0,
            "total_rx_errors": 0,
            "total_tx_errors": 0
        }
        
        current_stats = {}
        
        try:
            with open("/proc/net/dev", "r") as f:
                lines = f.readlines()[2:]
                
            for line in lines:
                parts = line.split()
                if len(parts) >= 17:
                    iface = parts[0].rstrip(':')
                    stats = {
                        "rx_bytes": int(parts[1]),
                        "rx_packets": int(parts[2]),
                        "rx_errors": int(parts[3]),
                        "rx_dropped": int(parts[4]),
                        "tx_bytes": int(parts[9]),
                        "tx_packets": int(parts[10]),
                        "tx_errors": int(parts[11]),
                        "tx_dropped": int(parts[12])
                    }
                    current_stats[iface] = stats
                    
                    iface_metrics = {
                        "name": iface,
                        **stats,
                        "rx_bytes_per_sec": 0,
                        "tx_bytes_per_sec": 0
                    }
                    
                    if self._prev_net_stats and iface in self._prev_net_stats:
                        prev = self._prev_net_stats[iface]
                        iface_metrics["rx_bytes_per_sec"] = max(0, stats["rx_bytes"] - prev["rx_bytes"]) // self.collection_interval
                        iface_metrics["tx_bytes_per_sec"] = max(0, stats["tx_bytes"] - prev["tx_bytes"]) // self.collection_interval
                    
                    net_metrics["interfaces"].append(iface_metrics)
                    net_metrics["total_rx_bytes"] += stats["rx_bytes"]
                    net_metrics["total_tx_bytes"] += stats["tx_bytes"]
                    net_metrics["total_rx_packets"] += stats["rx_packets"]
                    net_metrics["total_tx_packets"] += stats["tx_packets"]
                    net_metrics["total_rx_errors"] += stats["rx_errors"]
                    net_metrics["total_tx_errors"] += stats["tx_errors"]
            
            self._prev_net_stats = current_stats
            
        except Exception as e:
            self.logger.debug(f"Error reading network stats: {e}")
        
        return net_metrics
    
    def _get_load_metrics(self) -> Dict[str, Any]:
        load_metrics = {
            "load_1m": 0.0,
            "load_5m": 0.0,
            "load_15m": 0.0,
            "running_processes": 0,
            "total_processes": 0
        }
        
        try:
            with open("/proc/loadavg", "r") as f:
                parts = f.read().split()
                load_metrics["load_1m"] = float(parts[0])
                load_metrics["load_5m"] = float(parts[1])
                load_metrics["load_15m"] = float(parts[2])
                procs = parts[3].split('/')
                load_metrics["running_processes"] = int(procs[0])
                load_metrics["total_processes"] = int(procs[1])
        except Exception as e:
            self.logger.debug(f"Error reading load average: {e}")
        
        return load_metrics
    
    def _get_service_status(self, service_name: str) -> Dict[str, Any]:
        status = {
            "name": service_name,
            "active": False,
            "state": "unknown",
            "sub_state": "unknown",
            "description": "",
            "main_pid": 0,
            "memory_bytes": 0,
            "cpu_percent": 0.0,
            "uptime_seconds": 0,
            "restart_count": 0
        }
        
        try:
            result = subprocess.run(
                ["systemctl", "show", service_name,
                 "--property=ActiveState,SubState,Description,MainPID,MemoryCurrent,CPUUsageNSec,NRestarts,ExecMainStartTimestamp"],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if '=' in line:
                        key, value = line.split('=', 1)
                        if key == "ActiveState":
                            status["state"] = value
                            status["active"] = value == "active"
                        elif key == "SubState":
                            status["sub_state"] = value
                        elif key == "Description":
                            status["description"] = value
                        elif key == "MainPID":
                            status["main_pid"] = int(value) if value.isdigit() else 0
                        elif key == "MemoryCurrent":
                            if value != "[not set]" and value.isdigit():
                                status["memory_bytes"] = int(value)
                        elif key == "NRestarts":
                            status["restart_count"] = int(value) if value.isdigit() else 0
                        elif key == "ExecMainStartTimestamp":
                            if value and value != "n/a":
                                try:
                                    start_time = datetime.strptime(value.split()[0] + " " + value.split()[1], 
                                                                   "%a %Y-%m-%d")
                                except Exception:
                                    pass
        except Exception as e:
            self.logger.debug(f"Error getting service status for {service_name}: {e}")
        
        return status
    
    def _check_disk_health(self, device: str = None) -> Dict[str, Any]:
        health_info = {
            "devices": [],
            "smartctl_available": shutil.which("smartctl") is not None
        }
        
        if not health_info["smartctl_available"]:
            health_info["error"] = "smartctl not installed"
            return health_info
        
        devices_to_check = []
        
        if device:
            devices_to_check = [device]
        else:
            try:
                result = subprocess.run(
                    ["lsblk", "-d", "-o", "NAME,TYPE", "-n"],
                    capture_output=True, text=True, timeout=10
                )
                if result.returncode == 0:
                    for line in result.stdout.strip().split('\n'):
                        parts = line.split()
                        if len(parts) >= 2 and parts[1] == "disk":
                            devices_to_check.append(f"/dev/{parts[0]}")
            except Exception:
                pass
        
        for dev in devices_to_check:
            dev_health = {
                "device": dev,
                "smart_available": False,
                "health_status": "unknown",
                "temperature": None,
                "power_on_hours": None,
                "reallocated_sectors": None,
                "pending_sectors": None,
                "attributes": []
            }
            
            try:
                result = subprocess.run(
                    ["smartctl", "-H", "-A", "-i", dev],
                    capture_output=True, text=True, timeout=30
                )
                
                output = result.stdout
                
                if "SMART support is: Available" in output or "SMART overall-health" in output:
                    dev_health["smart_available"] = True
                
                if "PASSED" in output:
                    dev_health["health_status"] = "healthy"
                elif "FAILED" in output:
                    dev_health["health_status"] = "failing"
                
                for line in output.split('\n'):
                    if "Temperature_Celsius" in line or "Airflow_Temperature" in line:
                        parts = line.split()
                        for i, part in enumerate(parts):
                            if part.isdigit() and i > 5:
                                dev_health["temperature"] = int(part)
                                break
                    elif "Power_On_Hours" in line:
                        parts = line.split()
                        for part in reversed(parts):
                            if part.isdigit():
                                dev_health["power_on_hours"] = int(part)
                                break
                    elif "Reallocated_Sector_Ct" in line:
                        parts = line.split()
                        for part in reversed(parts):
                            if part.isdigit():
                                dev_health["reallocated_sectors"] = int(part)
                                break
                    elif "Current_Pending_Sector" in line:
                        parts = line.split()
                        for part in reversed(parts):
                            if part.isdigit():
                                dev_health["pending_sectors"] = int(part)
                                break
                
            except subprocess.TimeoutExpired:
                dev_health["error"] = "Command timed out"
            except Exception as e:
                dev_health["error"] = str(e)
            
            health_info["devices"].append(dev_health)
        
        return health_info
    
    def _get_network_connections(self) -> Dict[str, Any]:
        connections = {
            "tcp": [],
            "udp": [],
            "listening": [],
            "established": 0,
            "time_wait": 0,
            "close_wait": 0
        }
        
        try:
            result = subprocess.run(
                ["ss", "-tunap"],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')[1:]
                
                for line in lines:
                    parts = line.split()
                    if len(parts) >= 5:
                        proto = parts[0].lower()
                        state = parts[1] if len(parts) > 1 else ""
                        local = parts[4] if len(parts) > 4 else ""
                        remote = parts[5] if len(parts) > 5 else ""
                        process = parts[-1] if "users:" in line else ""
                        
                        conn_info = {
                            "protocol": proto,
                            "state": state,
                            "local_address": local,
                            "remote_address": remote,
                            "process": process
                        }
                        
                        if proto.startswith("tcp"):
                            connections["tcp"].append(conn_info)
                            if state == "LISTEN":
                                connections["listening"].append(conn_info)
                            elif state == "ESTAB":
                                connections["established"] += 1
                            elif state == "TIME-WAIT":
                                connections["time_wait"] += 1
                            elif state == "CLOSE-WAIT":
                                connections["close_wait"] += 1
                        elif proto.startswith("udp"):
                            connections["udp"].append(conn_info)
                            if state == "UNCONN" and "*" not in remote:
                                connections["listening"].append(conn_info)
            
        except FileNotFoundError:
            try:
                result = subprocess.run(
                    ["netstat", "-tunap"],
                    capture_output=True, text=True, timeout=10
                )
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')[2:]
                    
                    for line in lines:
                        parts = line.split()
                        if len(parts) >= 6:
                            proto = parts[0].lower()
                            local = parts[3]
                            remote = parts[4]
                            state = parts[5] if len(parts) > 5 and proto.startswith("tcp") else ""
                            process = parts[-1] if len(parts) > 6 else ""
                            
                            conn_info = {
                                "protocol": proto,
                                "state": state,
                                "local_address": local,
                                "remote_address": remote,
                                "process": process
                            }
                            
                            if proto.startswith("tcp"):
                                connections["tcp"].append(conn_info)
                                if state == "LISTEN":
                                    connections["listening"].append(conn_info)
                                elif state == "ESTABLISHED":
                                    connections["established"] += 1
                                elif state == "TIME_WAIT":
                                    connections["time_wait"] += 1
                                elif state == "CLOSE_WAIT":
                                    connections["close_wait"] += 1
                            elif proto.startswith("udp"):
                                connections["udp"].append(conn_info)
                                
            except Exception as e:
                self.logger.debug(f"Error getting network connections with netstat: {e}")
        except Exception as e:
            self.logger.debug(f"Error getting network connections: {e}")
        
        connections["tcp_count"] = len(connections["tcp"])
        connections["udp_count"] = len(connections["udp"])
        connections["listening_count"] = len(connections["listening"])
        
        return connections
    
    def _alert_on_threshold(self, metrics: Dict[str, Any]) -> List[Dict[str, Any]]:
        alerts = []
        timestamp = datetime.now().isoformat()
        
        if "cpu" in metrics and metrics["cpu"].get("usage_percent", 0) > self.thresholds.get("cpu_percent", 90):
            alert = {
                "timestamp": timestamp,
                "level": "critical",
                "type": "cpu_high",
                "message": f"CPU usage at {metrics['cpu']['usage_percent']}% (threshold: {self.thresholds['cpu_percent']}%)",
                "value": metrics["cpu"]["usage_percent"],
                "threshold": self.thresholds["cpu_percent"]
            }
            alerts.append(alert)
        
        if "memory" in metrics and metrics["memory"].get("usage_percent", 0) > self.thresholds.get("memory_percent", 85):
            alert = {
                "timestamp": timestamp,
                "level": "critical",
                "type": "memory_high",
                "message": f"Memory usage at {metrics['memory']['usage_percent']}% (threshold: {self.thresholds['memory_percent']}%)",
                "value": metrics["memory"]["usage_percent"],
                "threshold": self.thresholds["memory_percent"]
            }
            alerts.append(alert)
        
        if "disk" in metrics:
            for fs in metrics["disk"].get("filesystems", []):
                if fs.get("usage_percent", 0) > self.thresholds.get("disk_percent", 90):
                    alert = {
                        "timestamp": timestamp,
                        "level": "critical",
                        "type": "disk_high",
                        "message": f"Disk usage on {fs['mount_point']} at {fs['usage_percent']}% (threshold: {self.thresholds['disk_percent']}%)",
                        "value": fs["usage_percent"],
                        "threshold": self.thresholds["disk_percent"],
                        "mount_point": fs["mount_point"]
                    }
                    alerts.append(alert)
        
        if "load" in metrics and metrics["load"].get("load_1m", 0) > self.thresholds.get("load_1m", 10):
            alert = {
                "timestamp": timestamp,
                "level": "warning",
                "type": "load_high",
                "message": f"Load average at {metrics['load']['load_1m']} (threshold: {self.thresholds['load_1m']})",
                "value": metrics["load"]["load_1m"],
                "threshold": self.thresholds["load_1m"]
            }
            alerts.append(alert)
        
        if "network" in metrics:
            total_errors = metrics["network"].get("total_rx_errors", 0) + metrics["network"].get("total_tx_errors", 0)
            if total_errors > self.thresholds.get("network_errors", 100):
                alert = {
                    "timestamp": timestamp,
                    "level": "warning",
                    "type": "network_errors",
                    "message": f"Network errors detected: {total_errors} (threshold: {self.thresholds['network_errors']})",
                    "value": total_errors,
                    "threshold": self.thresholds["network_errors"]
                }
                alerts.append(alert)
        
        for alert in alerts:
            self._log_alert(alert)
            for callback in self.alert_callbacks:
                try:
                    callback(alert["type"], alert)
                except Exception as e:
                    self.logger.error(f"Alert callback error: {e}")
        
        return alerts
    
    def _log_alert(self, alert: Dict[str, Any]):
        try:
            alerts_dir = Path(ALERTS_FILE).parent
            alerts_dir.mkdir(parents=True, exist_ok=True)
            
            with open(ALERTS_FILE, "a") as f:
                f.write(json.dumps(alert) + "\n")
        except Exception as e:
            self.logger.error(f"Failed to log alert: {e}")
    
    def register_alert_callback(self, callback: Callable[[str, Dict[str, Any]], None]):
        self.alert_callbacks.append(callback)
    
    def _start_metrics_collector(self, interval: int = None):
        if self.collector_running:
            self.logger.warning("Metrics collector already running")
            return
        
        if interval:
            self.collection_interval = interval
        
        self.collector_running = True
        self.collector_thread = threading.Thread(target=self._collector_loop, daemon=True)
        self.collector_thread.start()
        self.logger.info(f"Started metrics collector with {self.collection_interval}s interval")
    
    def _stop_metrics_collector(self):
        self.collector_running = False
        if self.collector_thread:
            self.collector_thread.join(timeout=5)
            self.collector_thread = None
        self.logger.info("Stopped metrics collector")
    
    def _collector_loop(self):
        while self.collector_running:
            try:
                metrics = self._get_system_metrics()
                
                self.metrics_history.append(metrics)
                if len(self.metrics_history) > self.max_history:
                    self.metrics_history = self.metrics_history[-self.max_history:]
                
                self._alert_on_threshold(metrics)
                
            except Exception as e:
                self.logger.error(f"Error in metrics collection: {e}")
            
            for _ in range(self.collection_interval):
                if not self.collector_running:
                    break
                time.sleep(1)
    
    def get_system_metrics(self) -> Dict[str, Any]:
        metrics = {}
        
        try:
            with open("/proc/loadavg", "r") as f:
                load = f.read().split()
                metrics["load_1m"] = float(load[0])
                metrics["load_5m"] = float(load[1])
                metrics["load_15m"] = float(load[2])
        except Exception:
            pass
        
        try:
            with open("/proc/meminfo", "r") as f:
                for line in f:
                    if line.startswith("MemTotal:"):
                        metrics["mem_total_kb"] = int(line.split()[1])
                    elif line.startswith("MemAvailable:"):
                        metrics["mem_available_kb"] = int(line.split()[1])
        except Exception:
            pass
        
        try:
            result = subprocess.run(["df", "-k", "/"], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                if len(lines) > 1:
                    parts = lines[1].split()
                    metrics["disk_total_kb"] = int(parts[1])
                    metrics["disk_used_kb"] = int(parts[2])
                    metrics["disk_available_kb"] = int(parts[3])
        except Exception:
            pass
        
        return metrics
    
    def get_recent_logs(self, service: str = "syslog", lines: int = 50) -> List[str]:
        try:
            result = subprocess.run(
                ["journalctl", "-u", service, "-n", str(lines), "--no-pager"],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                return result.stdout.strip().split('\n')
        except Exception:
            pass
        return []
    
    def get_status(self) -> Dict[str, Any]:
        return {
            "tools": self.get_tools_status(),
            "metrics": self.get_system_metrics(),
            "tier": self.license_tier,
            "collector_running": self.collector_running,
            "metrics_history_count": len(self.metrics_history)
        }
    
    def run_daemon(self):
        self.daemon_running = True
        self._start_metrics_collector()
        self.logger.info("Starting monitoring daemon")
        try:
            while self.daemon_running:
                time.sleep(60)
        finally:
            self._stop_metrics_collector()
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"{'='*60}\n")
        
        tools = self.get_tools_status()
        print("Monitoring Stack:")
        for tool in tools:
            installed = "✓" if tool["installed"] else "✗"
            running = "Running" if tool["running"] else "Stopped"
            print(f"  {tool['name']}: {installed} ({running}) - Port {tool['port']}")
        
        metrics = self.get_system_metrics()
        print(f"\nSystem Metrics:")
        if "load_1m" in metrics:
            print(f"  Load Average: {metrics['load_1m']:.2f} / {metrics['load_5m']:.2f} / {metrics['load_15m']:.2f}")
        if "mem_total_kb" in metrics:
            used = metrics["mem_total_kb"] - metrics.get("mem_available_kb", 0)
            print(f"  Memory: {used // 1024} MB / {metrics['mem_total_kb'] // 1024} MB")
        if "disk_total_kb" in metrics:
            print(f"  Disk: {metrics['disk_used_kb'] // 1024} MB / {metrics['disk_total_kb'] // 1024} MB")
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            return self.run_cli()
        
        win = Gtk.Window(title=f"{APP_NAME}")
        win.set_default_size(800, 600)
        win.connect("destroy", Gtk.main_quit)
        
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        win.add(vbox)
        
        header = Gtk.Label()
        header.set_markup(f"<big><b>{APP_NAME}</b></big>")
        vbox.pack_start(header, False, False, 20)
        
        for tool in self.get_tools_status():
            label = Gtk.Label(label=f"{'✓' if tool['installed'] else '✗'} {tool['name']} (:{tool['port']})")
            label.set_xalign(0)
            vbox.pack_start(label, False, False, 5)
        
        win.show_all()
        Gtk.main()


def main():
    if not GTK_AVAILABLE:
        print(f"Cannot start {APP_NAME}: GTK3 not available.", file=sys.stderr)
        sys.exit(1)
    
    parser = argparse.ArgumentParser(description=f"{APP_NAME}")
    parser.add_argument("--gui", action="store_true")
    parser.add_argument("--cli", action="store_true")
    parser.add_argument("--daemon", action="store_true")
    parser.add_argument("--metrics", action="store_true", help="Show basic metrics")
    parser.add_argument("--full-metrics", action="store_true", help="Show detailed system metrics")
    parser.add_argument("--status", action="store_true")
    parser.add_argument("--disk-health", action="store_true", help="Check disk health via smartctl")
    parser.add_argument("--connections", action="store_true", help="Show network connections")
    parser.add_argument("--service", type=str, help="Check status of a systemd service")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.daemon:
        app = AegisMonitoring(headless=True)
        app.run_daemon()
    elif args.metrics:
        app = AegisMonitoring(headless=True)
        print(json.dumps(app.get_system_metrics(), indent=2))
    elif args.full_metrics:
        app = AegisMonitoring(headless=True)
        print(json.dumps(app._get_system_metrics(), indent=2))
    elif args.status:
        app = AegisMonitoring(headless=True)
        print(json.dumps(app.get_status(), indent=2))
    elif args.disk_health:
        app = AegisMonitoring(headless=True)
        print(json.dumps(app._check_disk_health(), indent=2))
    elif args.connections:
        app = AegisMonitoring(headless=True)
        print(json.dumps(app._get_network_connections(), indent=2))
    elif args.service:
        app = AegisMonitoring(headless=True)
        print(json.dumps(app._get_service_status(args.service), indent=2))
    elif args.cli or not GTK_AVAILABLE:
        app = AegisMonitoring(headless=False)
        app.run_cli()
    else:
        app = AegisMonitoring(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
