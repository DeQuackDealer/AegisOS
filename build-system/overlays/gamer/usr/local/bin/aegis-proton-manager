#!/usr/bin/env python3
"""
Aegis Proton Manager - Proton/Wine Compatibility Tool Manager
Manage Proton-GE, Wine-GE, and Steam Proton versions for optimal gaming

Features:
- Download and install Proton-GE versions
- Manage Wine-GE installations
- View Steam Proton versions
- Set default Proton per-game
- Clean old versions
- Check for updates
"""

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib, GdkPixbuf
import os
import json
import subprocess
import shutil
import tarfile
import threading
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime

VERSION = "1.0.0"
APP_NAME = "Aegis Proton Manager"

STEAM_COMPAT_PATH = Path.home() / ".steam/steam/compatibilitytools.d"
STEAM_PROTON_PATH = Path.home() / ".steam/steam/steamapps/common"
WINE_PREFIX_PATH = Path.home() / ".local/share/Steam/steamapps/compatdata"
LUTRIS_RUNNERS_PATH = Path.home() / ".local/share/lutris/runners"
CONFIG_DIR = Path.home() / ".config/aegis/proton-manager"

GITHUB_API = "https://api.github.com/repos"
PROTON_GE_REPO = "GloriousEggroll/proton-ge-custom"
WINE_GE_REPO = "GloriousEggroll/wine-ge-custom"


@dataclass
class ProtonVersion:
    name: str
    path: str
    source: str
    version: str = ""
    installed: bool = True
    size_mb: float = 0


class ProtonManagerService:
    def __init__(self):
        self.versions: List[ProtonVersion] = []
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        STEAM_COMPAT_PATH.mkdir(parents=True, exist_ok=True)
    
    def scan_installed(self) -> List[ProtonVersion]:
        self.versions = []
        
        if STEAM_COMPAT_PATH.exists():
            for item in STEAM_COMPAT_PATH.iterdir():
                if item.is_dir():
                    compat_file = item / "compatibilitytool.vdf"
                    if compat_file.exists() or (item / "proton").exists():
                        size = sum(f.stat().st_size for f in item.rglob('*') if f.is_file()) / (1024*1024)
                        name = item.name
                        version = ""
                        if "GE" in name:
                            parts = name.split("-")
                            if len(parts) >= 2:
                                version = "-".join(parts[1:])
                        
                        self.versions.append(ProtonVersion(
                            name=name,
                            path=str(item),
                            source="Proton-GE" if "GE" in name else "Custom",
                            version=version,
                            size_mb=round(size, 1)
                        ))
        
        if STEAM_PROTON_PATH.exists():
            for item in STEAM_PROTON_PATH.iterdir():
                if item.is_dir() and item.name.startswith("Proton"):
                    size = sum(f.stat().st_size for f in item.rglob('*') if f.is_file()) / (1024*1024)
                    self.versions.append(ProtonVersion(
                        name=item.name,
                        path=str(item),
                        source="Steam",
                        version=item.name.replace("Proton ", ""),
                        size_mb=round(size, 1)
                    ))
        
        if LUTRIS_RUNNERS_PATH.exists():
            wine_path = LUTRIS_RUNNERS_PATH / "wine"
            if wine_path.exists():
                for item in wine_path.iterdir():
                    if item.is_dir():
                        size = sum(f.stat().st_size for f in item.rglob('*') if f.is_file()) / (1024*1024)
                        self.versions.append(ProtonVersion(
                            name=item.name,
                            path=str(item),
                            source="Lutris Wine",
                            version=item.name,
                            size_mb=round(size, 1)
                        ))
        
        return self.versions
    
    def get_available_releases(self, repo: str = PROTON_GE_REPO) -> List[Dict]:
        releases = []
        try:
            result = subprocess.run(
                ["curl", "-s", f"{GITHUB_API}/{repo}/releases?per_page=10"],
                capture_output=True, text=True, timeout=30
            )
            if result.returncode == 0:
                data = json.loads(result.stdout)
                for release in data:
                    if isinstance(release, dict):
                        assets = release.get("assets", [])
                        tar_asset = None
                        for asset in assets:
                            if asset.get("name", "").endswith(".tar.gz"):
                                tar_asset = asset
                                break
                        
                        if tar_asset:
                            releases.append({
                                "name": release.get("tag_name", ""),
                                "published": release.get("published_at", "")[:10],
                                "download_url": tar_asset.get("browser_download_url", ""),
                                "size_mb": round(tar_asset.get("size", 0) / (1024*1024), 1),
                                "prerelease": release.get("prerelease", False)
                            })
        except Exception as e:
            pass
        
        return releases
    
    def download_and_install(self, url: str, name: str, progress_callback=None) -> bool:
        try:
            download_path = CONFIG_DIR / f"{name}.tar.gz"
            
            if progress_callback:
                progress_callback(f"Downloading {name}...", 0.1)
            
            result = subprocess.run(
                ["curl", "-L", "-o", str(download_path), url],
                capture_output=True, timeout=600
            )
            
            if result.returncode != 0:
                return False
            
            if progress_callback:
                progress_callback(f"Extracting {name}...", 0.6)
            
            with tarfile.open(download_path, "r:gz") as tar:
                for member in tar.getmembers():
                    member_path = os.path.normpath(os.path.join(STEAM_COMPAT_PATH, member.name))
                    if not member_path.startswith(str(STEAM_COMPAT_PATH)):
                        raise ValueError(f"Unsafe tar member: {member.name}")
                tar.extractall(path=STEAM_COMPAT_PATH)
            
            download_path.unlink()
            
            if progress_callback:
                progress_callback(f"Installed {name}", 1.0)
            
            return True
        except Exception as e:
            return False
    
    def remove_version(self, path: str) -> bool:
        try:
            target = Path(path).resolve()
            compat_path = STEAM_COMPAT_PATH.resolve()
            
            if not target.exists():
                return False
            
            if target.parent == compat_path or compat_path in target.parents:
                shutil.rmtree(target)
                return True
        except Exception:
            pass
        return False
    
    def get_total_size(self) -> float:
        return sum(v.size_mb for v in self.versions)


class AegisProtonManager(Gtk.Window):
    def __init__(self):
        super().__init__(title=f"{APP_NAME} v{VERSION}")
        self.set_default_size(900, 600)
        self.set_position(Gtk.WindowPosition.CENTER)
        
        self.service = ProtonManagerService()
        self.available_releases = []
        
        self._build_ui()
        self._refresh_installed()
    
    def _build_ui(self):
        header = Gtk.HeaderBar()
        header.set_show_close_button(True)
        header.props.title = APP_NAME
        self.set_titlebar(header)
        
        refresh_btn = Gtk.Button.new_from_icon_name("view-refresh-symbolic", Gtk.IconSize.BUTTON)
        refresh_btn.set_tooltip_text("Refresh")
        refresh_btn.connect("clicked", lambda b: self._refresh_installed())
        header.pack_start(refresh_btn)
        
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        main_box.set_margin_top(10)
        main_box.set_margin_bottom(10)
        main_box.set_margin_start(10)
        main_box.set_margin_end(10)
        self.add(main_box)
        
        notebook = Gtk.Notebook()
        main_box.pack_start(notebook, True, True, 0)
        
        installed_page = self._build_installed_page()
        notebook.append_page(installed_page, Gtk.Label(label="Installed"))
        
        download_page = self._build_download_page()
        notebook.append_page(download_page, Gtk.Label(label="Download"))
        
        self.status_label = Gtk.Label(label="Ready")
        self.status_label.set_xalign(0)
        main_box.pack_start(self.status_label, False, False, 0)
    
    def _build_installed_page(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_top(10)
        
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        box.pack_start(scroll, True, True, 0)
        
        self.installed_store = Gtk.ListStore(str, str, str, str, str, str)
        self.installed_tree = Gtk.TreeView(model=self.installed_store)
        
        columns = [("Name", 0), ("Source", 1), ("Version", 2), ("Size", 3), ("Path", 4)]
        for title, idx in columns:
            renderer = Gtk.CellRendererText()
            if idx == 4:
                renderer.set_property("ellipsize", 2)
            column = Gtk.TreeViewColumn(title, renderer, text=idx)
            column.set_resizable(True)
            if idx == 0:
                column.set_min_width(200)
            self.installed_tree.append_column(column)
        
        scroll.add(self.installed_tree)
        
        btn_box = Gtk.Box(spacing=10)
        box.pack_start(btn_box, False, False, 0)
        
        remove_btn = Gtk.Button(label="Remove Selected")
        remove_btn.connect("clicked", self._on_remove)
        btn_box.pack_start(remove_btn, False, False, 0)
        
        open_btn = Gtk.Button(label="Open Folder")
        open_btn.connect("clicked", self._on_open_folder)
        btn_box.pack_start(open_btn, False, False, 0)
        
        self.total_label = Gtk.Label()
        btn_box.pack_end(self.total_label, False, False, 0)
        
        return box
    
    def _build_download_page(self):
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_top(10)
        
        repo_box = Gtk.Box(spacing=10)
        box.pack_start(repo_box, False, False, 0)
        
        repo_box.pack_start(Gtk.Label(label="Repository:"), False, False, 0)
        
        self.repo_combo = Gtk.ComboBoxText()
        self.repo_combo.append_text("Proton-GE")
        self.repo_combo.append_text("Wine-GE")
        self.repo_combo.set_active(0)
        self.repo_combo.connect("changed", self._on_repo_changed)
        repo_box.pack_start(self.repo_combo, False, False, 0)
        
        check_btn = Gtk.Button(label="Check for Updates")
        check_btn.connect("clicked", self._on_check_updates)
        repo_box.pack_start(check_btn, False, False, 0)
        
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        box.pack_start(scroll, True, True, 0)
        
        self.download_store = Gtk.ListStore(str, str, str, str, str)
        self.download_tree = Gtk.TreeView(model=self.download_store)
        
        columns = [("Version", 0), ("Published", 1), ("Size", 2), ("Status", 3)]
        for title, idx in columns:
            column = Gtk.TreeViewColumn(title, Gtk.CellRendererText(), text=idx)
            column.set_resizable(True)
            self.download_tree.append_column(column)
        
        scroll.add(self.download_tree)
        
        btn_box = Gtk.Box(spacing=10)
        box.pack_start(btn_box, False, False, 0)
        
        download_btn = Gtk.Button(label="Download & Install")
        download_btn.connect("clicked", self._on_download)
        btn_box.pack_start(download_btn, False, False, 0)
        
        self.progress = Gtk.ProgressBar()
        self.progress.set_show_text(True)
        box.pack_start(self.progress, False, False, 0)
        
        return box
    
    def _refresh_installed(self):
        self.installed_store.clear()
        versions = self.service.scan_installed()
        
        for v in versions:
            self.installed_store.append([
                v.name,
                v.source,
                v.version,
                f"{v.size_mb:.0f} MB",
                v.path,
                v.path
            ])
        
        total = self.service.get_total_size()
        self.total_label.set_text(f"Total: {total:.0f} MB ({len(versions)} versions)")
        self.status_label.set_text(f"Found {len(versions)} installed versions")
    
    def _on_remove(self, btn):
        selection = self.installed_tree.get_selection()
        model, iter = selection.get_selected()
        if iter:
            name = model[iter][0]
            path = model[iter][5]
            
            dialog = Gtk.MessageDialog(
                transient_for=self,
                message_type=Gtk.MessageType.QUESTION,
                buttons=Gtk.ButtonsType.YES_NO,
                text=f"Remove {name}?"
            )
            dialog.format_secondary_text("This will delete the Proton/Wine version permanently.")
            response = dialog.run()
            dialog.destroy()
            
            if response == Gtk.ResponseType.YES:
                if self.service.remove_version(path):
                    self.status_label.set_text(f"Removed {name}")
                    self._refresh_installed()
                else:
                    self.status_label.set_text(f"Failed to remove {name}")
    
    def _on_open_folder(self, btn):
        selection = self.installed_tree.get_selection()
        model, iter = selection.get_selected()
        if iter:
            path = model[iter][5]
            subprocess.Popen(["xdg-open", path])
    
    def _on_repo_changed(self, combo):
        self.download_store.clear()
    
    def _on_check_updates(self, btn):
        self.status_label.set_text("Checking for updates...")
        self.download_store.clear()
        
        def check():
            repo = PROTON_GE_REPO if self.repo_combo.get_active() == 0 else WINE_GE_REPO
            releases = self.service.get_available_releases(repo)
            
            installed_names = {v.name for v in self.service.versions}
            
            GLib.idle_add(self._update_releases, releases, installed_names)
        
        threading.Thread(target=check, daemon=True).start()
    
    def _update_releases(self, releases, installed_names):
        self.available_releases = releases
        self.download_store.clear()
        
        for r in releases:
            status = "Installed" if r["name"] in installed_names else "Available"
            prerelease = " (Pre-release)" if r.get("prerelease") else ""
            self.download_store.append([
                r["name"] + prerelease,
                r["published"],
                f"{r['size_mb']:.0f} MB",
                status,
                r["download_url"]
            ])
        
        self.status_label.set_text(f"Found {len(releases)} available versions")
    
    def _on_download(self, btn):
        selection = self.download_tree.get_selection()
        model, iter = selection.get_selected()
        if not iter:
            return
        
        name = model[iter][0].split(" (")[0]
        url = model[iter][4]
        
        if model[iter][3] == "Installed":
            self.status_label.set_text(f"{name} is already installed")
            return
        
        self.progress.set_fraction(0)
        self.progress.set_text(f"Starting download of {name}...")
        
        def download():
            def progress_cb(msg, fraction):
                GLib.idle_add(self._update_progress, msg, fraction)
            
            success = self.service.download_and_install(url, name, progress_cb)
            
            GLib.idle_add(self._download_complete, name, success)
        
        threading.Thread(target=download, daemon=True).start()
    
    def _update_progress(self, msg, fraction):
        self.progress.set_fraction(fraction)
        self.progress.set_text(msg)
    
    def _download_complete(self, name, success):
        if success:
            self.status_label.set_text(f"Successfully installed {name}")
            self._refresh_installed()
            self._on_check_updates(None)
        else:
            self.status_label.set_text(f"Failed to install {name}")
        
        self.progress.set_fraction(0)
        self.progress.set_text("")


def main():
    curl_check = subprocess.run(["which", "curl"], capture_output=True)
    if curl_check.returncode != 0:
        print("Error: curl is required but not installed")
        print("Install with: sudo apt install curl")
        return 1
    
    win = AegisProtonManager()
    win.connect("destroy", Gtk.main_quit)
    win.show_all()
    Gtk.main()
    return 0


if __name__ == "__main__":
    exit(main())
