#!/usr/bin/env python3
"""
Aegis Stream Deck - OBS & Streaming Tools Control Center
Unified interface for managing OBS Studio, streaming platforms, and overlays

Features:
- OBS Studio integration via obs-websocket
- Quick scene switching and source control
- Stream/recording start/stop controls
- Audio mixer management
- Streamlink integration for watching streams
- Chat overlay management
- Stream statistics and analytics
- Hotkey configuration
- Multi-platform streaming (Twitch, YouTube, Kick)
- Alert and overlay management

Copyright (c) 2024 Aegis OS Team
License: GPL-3.0
"""

import os
import sys
import json
import subprocess
import argparse
import shutil
import threading
import time
import webbrowser
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field, asdict
from enum import Enum

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, simpledialog
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False
    print("Error: Tkinter is required for the graphical interface.", file=sys.stderr)
    print("Install with: sudo pacman -S tk", file=sys.stderr)

VERSION = "1.0.0"
APP_NAME = "Aegis Stream Deck"
CONFIG_DIR = Path.home() / ".config/aegis/stream-deck"
CONFIG_FILE = CONFIG_DIR / "config.json"
SCENES_FILE = CONFIG_DIR / "scenes.json"
HOTKEYS_FILE = CONFIG_DIR / "hotkeys.json"


class StreamPlatform(Enum):
    TWITCH = "twitch"
    YOUTUBE = "youtube"
    KICK = "kick"
    CUSTOM = "custom"


class StreamStatus(Enum):
    OFFLINE = "offline"
    LIVE = "live"
    RECORDING = "recording"
    BOTH = "both"


@dataclass
class OBSConnection:
    host: str = "localhost"
    port: int = 4455
    password: str = ""
    connected: bool = False


@dataclass
class StreamScene:
    name: str
    hotkey: str = ""
    icon: str = ""
    sources: List[str] = field(default_factory=list)


@dataclass
class StreamConfig:
    obs_connection: OBSConnection = field(default_factory=OBSConnection)
    platform: str = "twitch"
    channel_name: str = ""
    stream_key: str = ""
    auto_start_obs: bool = True
    default_scene: str = ""
    recording_path: str = ""
    overlay_enabled: bool = False
    chat_overlay_url: str = ""
    alerts_enabled: bool = False


class OBSWebSocketClient:
    def __init__(self, host: str = "localhost", port: int = 4455, password: str = ""):
        self.host = host
        self.port = port
        self.password = password
        self.connected = False
        self.ws = None

    def connect(self) -> Tuple[bool, str]:
        try:
            import websocket
            import hashlib
            import base64

            self.ws = websocket.create_connection(f"ws://{self.host}:{self.port}")
            hello = json.loads(self.ws.recv())

            if hello.get("op") == 0:
                auth = hello.get("d", {}).get("authentication")
                if auth and self.password:
                    challenge = auth.get("challenge", "")
                    salt = auth.get("salt", "")
                    secret = base64.b64encode(
                        hashlib.sha256((self.password + salt).encode()).digest()
                    ).decode()
                    auth_response = base64.b64encode(
                        hashlib.sha256((secret + challenge).encode()).digest()
                    ).decode()

                    identify = {
                        "op": 1,
                        "d": {
                            "rpcVersion": 1,
                            "authentication": auth_response
                        }
                    }
                else:
                    identify = {"op": 1, "d": {"rpcVersion": 1}}

                self.ws.send(json.dumps(identify))
                response = json.loads(self.ws.recv())

                if response.get("op") == 2:
                    self.connected = True
                    return True, "Connected to OBS"
                else:
                    return False, "Authentication failed"

            return False, "Invalid OBS response"

        except ImportError:
            return False, "websocket-client not installed"
        except ConnectionRefusedError:
            return False, "OBS not running or WebSocket not enabled"
        except Exception as e:
            return False, str(e)

    def disconnect(self):
        if self.ws:
            try:
                self.ws.close()
            except:
                pass
        self.connected = False

    def send_request(self, request_type: str, request_data: Dict = None) -> Tuple[bool, Any]:
        if not self.connected:
            return False, "Not connected"

        try:
            request = {
                "op": 6,
                "d": {
                    "requestType": request_type,
                    "requestId": str(time.time()),
                    "requestData": request_data or {}
                }
            }
            self.ws.send(json.dumps(request))
            response = json.loads(self.ws.recv())

            if response.get("op") == 7:
                data = response.get("d", {})
                if data.get("requestStatus", {}).get("result"):
                    return True, data.get("responseData", {})
                else:
                    return False, data.get("requestStatus", {}).get("comment", "Unknown error")

            return False, "Invalid response"

        except Exception as e:
            return False, str(e)

    def get_scenes(self) -> List[str]:
        success, data = self.send_request("GetSceneList")
        if success:
            return [s.get("sceneName") for s in data.get("scenes", [])]
        return []

    def get_current_scene(self) -> str:
        success, data = self.send_request("GetCurrentProgramScene")
        if success:
            return data.get("currentProgramSceneName", "")
        return ""

    def set_scene(self, scene_name: str) -> bool:
        success, _ = self.send_request("SetCurrentProgramScene", {"sceneName": scene_name})
        return success

    def get_streaming_status(self) -> Dict:
        success, data = self.send_request("GetStreamStatus")
        if success:
            return {
                "streaming": data.get("outputActive", False),
                "duration": data.get("outputDuration", 0),
                "bytes": data.get("outputBytes", 0)
            }
        return {"streaming": False, "duration": 0, "bytes": 0}

    def get_recording_status(self) -> Dict:
        success, data = self.send_request("GetRecordStatus")
        if success:
            return {
                "recording": data.get("outputActive", False),
                "paused": data.get("outputPaused", False),
                "duration": data.get("outputDuration", 0)
            }
        return {"recording": False, "paused": False, "duration": 0}

    def start_streaming(self) -> bool:
        success, _ = self.send_request("StartStream")
        return success

    def stop_streaming(self) -> bool:
        success, _ = self.send_request("StopStream")
        return success

    def start_recording(self) -> bool:
        success, _ = self.send_request("StartRecord")
        return success

    def stop_recording(self) -> bool:
        success, _ = self.send_request("StopRecord")
        return success

    def toggle_source(self, scene: str, source: str, visible: bool) -> bool:
        success, data = self.send_request("GetSceneItemId", {
            "sceneName": scene,
            "sourceName": source
        })
        if success:
            item_id = data.get("sceneItemId")
            success, _ = self.send_request("SetSceneItemEnabled", {
                "sceneName": scene,
                "sceneItemId": item_id,
                "sceneItemEnabled": visible
            })
            return success
        return False

    def get_audio_sources(self) -> List[Dict]:
        success, data = self.send_request("GetInputList")
        sources = []
        if success:
            for inp in data.get("inputs", []):
                name = inp.get("inputName")
                success, vol_data = self.send_request("GetInputVolume", {"inputName": name})
                if success:
                    sources.append({
                        "name": name,
                        "volume": vol_data.get("inputVolumeDb", 0),
                        "muted": vol_data.get("inputVolumeMul", 1) == 0
                    })
        return sources

    def set_volume(self, source: str, volume_db: float) -> bool:
        success, _ = self.send_request("SetInputVolume", {
            "inputName": source,
            "inputVolumeDb": volume_db
        })
        return success

    def toggle_mute(self, source: str) -> bool:
        success, _ = self.send_request("ToggleInputMute", {"inputName": source})
        return success


class StreamDeckService:
    def __init__(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        self.config = self._load_config()
        self.obs: Optional[OBSWebSocketClient] = None
        self.scenes: List[StreamScene] = []
        self._load_scenes()

    def _load_config(self) -> StreamConfig:
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE) as f:
                    data = json.load(f)
                    obs_data = data.pop("obs_connection", {})
                    config = StreamConfig(**data)
                    config.obs_connection = OBSConnection(**obs_data)
                    return config
            except Exception:
                pass
        return StreamConfig()

    def _save_config(self):
        data = asdict(self.config)
        with open(CONFIG_FILE, 'w') as f:
            json.dump(data, f, indent=2)

    def _load_scenes(self):
        if SCENES_FILE.exists():
            try:
                with open(SCENES_FILE) as f:
                    data = json.load(f)
                    self.scenes = [StreamScene(**s) for s in data]
            except Exception:
                pass

    def _save_scenes(self):
        with open(SCENES_FILE, 'w') as f:
            json.dump([asdict(s) for s in self.scenes], f, indent=2)

    def connect_obs(self) -> Tuple[bool, str]:
        conn = self.config.obs_connection
        self.obs = OBSWebSocketClient(conn.host, conn.port, conn.password)
        success, msg = self.obs.connect()
        if success:
            self.config.obs_connection.connected = True
            scenes = self.obs.get_scenes()
            self.scenes = [StreamScene(name=s) for s in scenes]
            self._save_scenes()
        return success, msg

    def disconnect_obs(self):
        if self.obs:
            self.obs.disconnect()
            self.config.obs_connection.connected = False

    def is_obs_running(self) -> bool:
        try:
            result = subprocess.run(["pgrep", "-x", "obs"], capture_output=True)
            return result.returncode == 0
        except:
            return False

    def start_obs(self) -> bool:
        if self.is_obs_running():
            return True
        try:
            subprocess.Popen(["obs", "--minimize-to-tray"],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            time.sleep(3)
            return self.is_obs_running()
        except Exception:
            return False

    def get_streaming_status(self) -> Dict:
        if self.obs and self.obs.connected:
            stream = self.obs.get_streaming_status()
            record = self.obs.get_recording_status()
            return {
                "connected": True,
                "streaming": stream["streaming"],
                "stream_duration": stream["duration"],
                "recording": record["recording"],
                "record_duration": record["duration"],
                "current_scene": self.obs.get_current_scene()
            }
        return {
            "connected": False,
            "streaming": False,
            "recording": False
        }

    def start_stream(self) -> Tuple[bool, str]:
        if not self.obs or not self.obs.connected:
            return False, "Not connected to OBS"
        if self.obs.start_streaming():
            return True, "Stream started"
        return False, "Failed to start stream"

    def stop_stream(self) -> Tuple[bool, str]:
        if not self.obs or not self.obs.connected:
            return False, "Not connected to OBS"
        if self.obs.stop_streaming():
            return True, "Stream stopped"
        return False, "Failed to stop stream"

    def start_recording(self) -> Tuple[bool, str]:
        if not self.obs or not self.obs.connected:
            return False, "Not connected to OBS"
        if self.obs.start_recording():
            return True, "Recording started"
        return False, "Failed to start recording"

    def stop_recording(self) -> Tuple[bool, str]:
        if not self.obs or not self.obs.connected:
            return False, "Not connected to OBS"
        if self.obs.stop_recording():
            return True, "Recording stopped"
        return False, "Failed to stop recording"

    def switch_scene(self, scene_name: str) -> Tuple[bool, str]:
        if not self.obs or not self.obs.connected:
            return False, "Not connected to OBS"
        if self.obs.set_scene(scene_name):
            return True, f"Switched to {scene_name}"
        return False, "Failed to switch scene"

    def watch_stream(self, channel: str, platform: str = "twitch") -> Tuple[bool, str]:
        if not shutil.which("streamlink"):
            return False, "Streamlink not installed"

        url = ""
        if platform == "twitch":
            url = f"https://twitch.tv/{channel}"
        elif platform == "youtube":
            url = f"https://youtube.com/c/{channel}/live"
        elif platform == "kick":
            url = f"https://kick.com/{channel}"

        try:
            player = "mpv" if shutil.which("mpv") else "vlc"
            subprocess.Popen(
                ["streamlink", url, "best", "--player", player],
                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
            )
            return True, f"Opening {channel} stream"
        except Exception as e:
            return False, str(e)

    def open_chat(self, channel: str, platform: str = "twitch"):
        if platform == "twitch":
            webbrowser.open(f"https://twitch.tv/popout/{channel}/chat")
        elif platform == "youtube":
            webbrowser.open(f"https://youtube.com/live_chat?v={channel}")

    def get_status(self) -> Dict:
        status = self.get_streaming_status()
        return {
            "version": VERSION,
            "obs_running": self.is_obs_running(),
            "obs_connected": status["connected"],
            "streaming": status.get("streaming", False),
            "recording": status.get("recording", False),
            "current_scene": status.get("current_scene", ""),
            "scenes": [s.name for s in self.scenes],
            "platform": self.config.platform,
            "channel": self.config.channel_name
        }


class StreamDeckGUI:
    def __init__(self, service: StreamDeckService):
        self.service = service
        self.root = None
        self.monitoring = False

    def run(self):
        if not TKINTER_AVAILABLE:
            print("Error: Tkinter not available")
            sys.exit(1)

        self.root = tk.Tk()
        self.root.title(f"{APP_NAME} v{VERSION}")
        self.root.geometry("900x650")
        self.root.configure(bg='#18181b')

        style = ttk.Style()
        style.theme_use('clam')
        style.configure('TFrame', background='#18181b')
        style.configure('TLabel', background='#18181b', foreground='#efeff1')
        style.configure('Header.TLabel', font=('Segoe UI', 18, 'bold'), foreground='#9147ff')
        style.configure('Status.TLabel', font=('Segoe UI', 11), foreground='#adadb8')
        style.configure('Live.TLabel', font=('Segoe UI', 12, 'bold'), foreground='#eb0400')
        style.configure('TButton', padding=10, font=('Segoe UI', 10))
        style.configure('Stream.TButton', padding=15, font=('Segoe UI', 12, 'bold'))
        style.configure('Scene.TButton', padding=12, font=('Segoe UI', 11))

        self._create_widgets()
        self._start_monitoring()
        self.root.protocol("WM_DELETE_WINDOW", self._on_close)
        self.root.mainloop()

    def _create_widgets(self):
        main = ttk.Frame(self.root, padding=15)
        main.pack(fill=tk.BOTH, expand=True)

        header = ttk.Frame(main)
        header.pack(fill=tk.X, pady=(0, 15))

        ttk.Label(header, text="üì∫ Aegis Stream Deck", style='Header.TLabel').pack(side=tk.LEFT)

        self.status_label = ttk.Label(header, text="‚óè Offline", style='Status.TLabel')
        self.status_label.pack(side=tk.RIGHT)

        conn_frame = ttk.Frame(main)
        conn_frame.pack(fill=tk.X, pady=(0, 10))

        self.obs_status = ttk.Label(conn_frame, text="OBS: Not connected", style='Status.TLabel')
        self.obs_status.pack(side=tk.LEFT)

        ttk.Button(conn_frame, text="üîå Connect OBS", command=self._connect_obs).pack(side=tk.LEFT, padx=10)
        ttk.Button(conn_frame, text="‚ñ∂ Start OBS", command=self._start_obs).pack(side=tk.LEFT)

        content = ttk.Frame(main)
        content.pack(fill=tk.BOTH, expand=True)

        left_panel = ttk.Frame(content)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))

        controls = ttk.LabelFrame(left_panel, text="Stream Controls", padding=10)
        controls.pack(fill=tk.X, pady=(0, 10))

        btn_row1 = ttk.Frame(controls)
        btn_row1.pack(fill=tk.X, pady=5)

        self.stream_btn = ttk.Button(btn_row1, text="üî¥ GO LIVE", style='Stream.TButton',
                                    command=self._toggle_stream)
        self.stream_btn.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))

        self.record_btn = ttk.Button(btn_row1, text="‚è∫ RECORD", style='Stream.TButton',
                                    command=self._toggle_record)
        self.record_btn.pack(side=tk.LEFT, fill=tk.X, expand=True)

        self.duration_label = ttk.Label(controls, text="Duration: 00:00:00", style='Status.TLabel')
        self.duration_label.pack(pady=5)

        scenes_frame = ttk.LabelFrame(left_panel, text="Scenes", padding=10)
        scenes_frame.pack(fill=tk.BOTH, expand=True)

        self.scenes_container = ttk.Frame(scenes_frame)
        self.scenes_container.pack(fill=tk.BOTH, expand=True)

        self._refresh_scenes()

        right_panel = ttk.Frame(content, width=300)
        right_panel.pack(side=tk.RIGHT, fill=tk.Y)
        right_panel.pack_propagate(False)

        watch_frame = ttk.LabelFrame(right_panel, text="Watch Stream", padding=10)
        watch_frame.pack(fill=tk.X, pady=(0, 10))

        self.watch_channel = ttk.Entry(watch_frame, font=('Segoe UI', 10))
        self.watch_channel.pack(fill=tk.X, pady=(0, 5))
        self.watch_channel.insert(0, "Channel name...")

        self.platform_var = tk.StringVar(value="twitch")
        platform_frame = ttk.Frame(watch_frame)
        platform_frame.pack(fill=tk.X, pady=5)

        for text, val in [("Twitch", "twitch"), ("YouTube", "youtube"), ("Kick", "kick")]:
            ttk.Radiobutton(platform_frame, text=text, value=val, variable=self.platform_var).pack(side=tk.LEFT)

        ttk.Button(watch_frame, text="‚ñ∂ Watch", command=self._watch_stream).pack(fill=tk.X, pady=5)
        ttk.Button(watch_frame, text="üí¨ Open Chat", command=self._open_chat).pack(fill=tk.X)

        quick_frame = ttk.LabelFrame(right_panel, text="Quick Actions", padding=10)
        quick_frame.pack(fill=tk.X, pady=(0, 10))

        actions = [
            ("üîá Mute Mic", self._toggle_mic),
            ("üîä Mute Desktop", self._toggle_desktop),
            ("üì∑ Toggle Camera", self._toggle_camera),
            ("üñº Toggle Overlay", self._toggle_overlay),
        ]

        for text, cmd in actions:
            ttk.Button(quick_frame, text=text, command=cmd).pack(fill=tk.X, pady=2)

        stats_frame = ttk.LabelFrame(right_panel, text="Stream Stats", padding=10)
        stats_frame.pack(fill=tk.X)

        self.viewers_label = ttk.Label(stats_frame, text="Viewers: --", style='Status.TLabel')
        self.viewers_label.pack(anchor=tk.W)

        self.bitrate_label = ttk.Label(stats_frame, text="Bitrate: -- kbps", style='Status.TLabel')
        self.bitrate_label.pack(anchor=tk.W)

        self.fps_label = ttk.Label(stats_frame, text="FPS: --", style='Status.TLabel')
        self.fps_label.pack(anchor=tk.W)

        self.dropped_label = ttk.Label(stats_frame, text="Dropped: 0%", style='Status.TLabel')
        self.dropped_label.pack(anchor=tk.W)

    def _connect_obs(self):
        success, msg = self.service.connect_obs()
        if success:
            self.obs_status.config(text="OBS: ‚úì Connected", foreground='#00ff7f')
            self._refresh_scenes()
            messagebox.showinfo("Connected", "Successfully connected to OBS")
        else:
            self.obs_status.config(text=f"OBS: ‚úó {msg}", foreground='#eb0400')
            messagebox.showerror("Connection Failed", msg)

    def _start_obs(self):
        if self.service.start_obs():
            messagebox.showinfo("OBS", "OBS Studio started")
            self.root.after(3000, self._connect_obs)
        else:
            messagebox.showerror("Error", "Failed to start OBS")

    def _refresh_scenes(self):
        for widget in self.scenes_container.winfo_children():
            widget.destroy()

        for scene in self.service.scenes:
            btn = ttk.Button(self.scenes_container, text=scene.name, style='Scene.TButton',
                           command=lambda s=scene.name: self._switch_scene(s))
            btn.pack(fill=tk.X, pady=2)

    def _switch_scene(self, scene_name: str):
        success, msg = self.service.switch_scene(scene_name)
        if not success:
            messagebox.showerror("Error", msg)

    def _toggle_stream(self):
        status = self.service.get_streaming_status()
        if status.get("streaming"):
            if messagebox.askyesno("Stop Stream", "Are you sure you want to stop streaming?"):
                success, msg = self.service.stop_stream()
                if success:
                    self.stream_btn.config(text="üî¥ GO LIVE")
                    self.status_label.config(text="‚óè Offline", foreground='#adadb8')
        else:
            success, msg = self.service.start_stream()
            if success:
                self.stream_btn.config(text="‚èπ END STREAM")
                self.status_label.config(text="üî¥ LIVE", foreground='#eb0400')

    def _toggle_record(self):
        status = self.service.get_streaming_status()
        if status.get("recording"):
            success, msg = self.service.stop_recording()
            if success:
                self.record_btn.config(text="‚è∫ RECORD")
        else:
            success, msg = self.service.start_recording()
            if success:
                self.record_btn.config(text="‚èπ STOP REC")

    def _watch_stream(self):
        channel = self.watch_channel.get().strip()
        if channel and channel != "Channel name...":
            success, msg = self.service.watch_stream(channel, self.platform_var.get())
            if not success:
                messagebox.showerror("Error", msg)

    def _open_chat(self):
        channel = self.watch_channel.get().strip()
        if channel and channel != "Channel name...":
            self.service.open_chat(channel, self.platform_var.get())

    def _toggle_mic(self):
        if self.service.obs and self.service.obs.connected:
            self.service.obs.toggle_mute("Mic/Aux")

    def _toggle_desktop(self):
        if self.service.obs and self.service.obs.connected:
            self.service.obs.toggle_mute("Desktop Audio")

    def _toggle_camera(self):
        if self.service.obs and self.service.obs.connected:
            scene = self.service.obs.get_current_scene()
            self.service.obs.toggle_source(scene, "Video Capture Device", True)

    def _toggle_overlay(self):
        pass

    def _start_monitoring(self):
        self.monitoring = True
        thread = threading.Thread(target=self._monitor_loop, daemon=True)
        thread.start()

    def _monitor_loop(self):
        while self.monitoring:
            try:
                status = self.service.get_streaming_status()
                self.root.after(0, lambda s=status: self._update_status(s))
            except Exception:
                pass
            time.sleep(2)

    def _update_status(self, status: Dict):
        if status.get("connected"):
            self.obs_status.config(text="OBS: ‚úì Connected", foreground='#00ff7f')
        else:
            self.obs_status.config(text="OBS: Not connected", foreground='#adadb8')

        if status.get("streaming"):
            self.status_label.config(text="üî¥ LIVE", foreground='#eb0400')
            self.stream_btn.config(text="‚èπ END STREAM")
            duration = status.get("stream_duration", 0) // 1000
            h, m, s = duration // 3600, (duration % 3600) // 60, duration % 60
            self.duration_label.config(text=f"Duration: {h:02d}:{m:02d}:{s:02d}")
        else:
            self.status_label.config(text="‚óè Offline", foreground='#adadb8')
            self.stream_btn.config(text="üî¥ GO LIVE")

        if status.get("recording"):
            self.record_btn.config(text="‚èπ STOP REC")
        else:
            self.record_btn.config(text="‚è∫ RECORD")

    def _on_close(self):
        self.monitoring = False
        self.service.disconnect_obs()
        self.root.destroy()


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - OBS & Streaming control center")
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--status', action='store_true', help='Show status as JSON')
    parser.add_argument('--connect', action='store_true', help='Connect to OBS')
    parser.add_argument('--start-stream', action='store_true', help='Start streaming')
    parser.add_argument('--stop-stream', action='store_true', help='Stop streaming')
    parser.add_argument('--start-record', action='store_true', help='Start recording')
    parser.add_argument('--stop-record', action='store_true', help='Stop recording')
    parser.add_argument('--scene', metavar='NAME', help='Switch to scene')
    parser.add_argument('--watch', metavar='CHANNEL', help='Watch a stream')
    parser.add_argument('--platform', default='twitch', help='Streaming platform')
    parser.add_argument('--scenes', action='store_true', help='List available scenes')
    parser.add_argument('--version', action='version', version=f'{APP_NAME} v{VERSION}')

    args = parser.parse_args()
    service = StreamDeckService()

    if args.connect:
        success, msg = service.connect_obs()
        print(msg)
        sys.exit(0 if success else 1)
    elif args.status:
        print(json.dumps(service.get_status(), indent=2))
    elif args.start_stream:
        if not service.obs:
            service.connect_obs()
        success, msg = service.start_stream()
        print(msg)
        sys.exit(0 if success else 1)
    elif args.stop_stream:
        if not service.obs:
            service.connect_obs()
        success, msg = service.stop_stream()
        print(msg)
        sys.exit(0 if success else 1)
    elif args.start_record:
        if not service.obs:
            service.connect_obs()
        success, msg = service.start_recording()
        print(msg)
        sys.exit(0 if success else 1)
    elif args.stop_record:
        if not service.obs:
            service.connect_obs()
        success, msg = service.stop_recording()
        print(msg)
        sys.exit(0 if success else 1)
    elif args.scene:
        if not service.obs:
            service.connect_obs()
        success, msg = service.switch_scene(args.scene)
        print(msg)
        sys.exit(0 if success else 1)
    elif args.scenes:
        if not service.obs:
            service.connect_obs()
        print("Available scenes:")
        for scene in service.scenes:
            print(f"  - {scene.name}")
    elif args.watch:
        success, msg = service.watch_stream(args.watch, args.platform)
        print(msg)
        sys.exit(0 if success else 1)
    elif args.gui or not any([args.connect, args.status, args.start_stream, args.stop_stream,
                               args.start_record, args.stop_record, args.scene, args.scenes, args.watch]):
        if TKINTER_AVAILABLE:
            gui = StreamDeckGUI(service)
            gui.run()
        else:
            print("Cannot start Aegis Stream Deck: Tkinter not available.", file=sys.stderr)
            print("Use --help for CLI options.", file=sys.stderr)
            sys.exit(1)


if __name__ == "__main__":
    main()
