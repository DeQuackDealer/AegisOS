#!/usr/bin/env python3
"""
Aegis Latency FastPath - Kernel-Level Input Optimization

A system service that provides sub-millisecond input latency through:
- IRQ affinity steering for input devices to dedicated CPU cores
- cpuset pinning for gaming processes
- USB polling rate optimization (1000Hz+ for gaming mice)
- Evdev priority boosting for input events
- Network latency optimization (TCP_NODELAY, UDP prioritization)

This is an OS-LEVEL FEATURE running as a systemd service.
"""

import os
import sys
import json
import signal
import logging
import subprocess
import time
from pathlib import Path
from typing import Dict, List, Set, Optional
from dataclasses import dataclass

CONFIG_PATH = Path("/etc/aegis/latency-fastpath.json")
STATE_PATH = Path("/var/lib/aegis/latency-fastpath")
LOG_PATH = Path("/var/log/aegis/latency-fastpath.log")

DEFAULT_CONFIG = {
    "enabled": True,
    "dedicated_input_cores": [0],
    "gaming_cores": [2, 3, 4, 5, 6, 7],
    "usb_polling_rate_hz": 1000,
    "irq_affinity_enabled": True,
    "network_optimization_enabled": True,
    "evdev_priority_boost": True,
    "cpu_governor_gaming": "performance",
    "disable_cpu_powersave_on_game": True,
    "gaming_process_patterns": ["steam", "wine", "proton", "lutris", "heroic", ".exe"],
    "check_interval_seconds": 5
}

@dataclass
class InputDevice:
    name: str
    path: str
    vendor_id: str
    product_id: str
    irq: Optional[int]
    is_gaming: bool

class LatencyFastPath:
    def __init__(self):
        self.config = self._load_config()
        self.running = True
        self.gaming_active = False
        self.input_devices: List[InputDevice] = []
        self.original_cpu_governor = {}
        self._setup_logging()
        self._setup_signal_handlers()
        self._ensure_directories()
    
    def _load_config(self) -> dict:
        if CONFIG_PATH.exists():
            try:
                with open(CONFIG_PATH) as f:
                    return {**DEFAULT_CONFIG, **json.load(f)}
            except Exception:
                pass
        return DEFAULT_CONFIG.copy()
    
    def _setup_logging(self):
        LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [LatencyFastPath] %(levelname)s: %(message)s',
            handlers=[logging.FileHandler(LOG_PATH), logging.StreamHandler()]
        )
        self.logger = logging.getLogger("latency-fastpath")
    
    def _setup_signal_handlers(self):
        signal.signal(signal.SIGTERM, self._handle_shutdown)
        signal.signal(signal.SIGINT, self._handle_shutdown)
    
    def _handle_shutdown(self, signum, frame):
        self.logger.info("Shutting down Latency FastPath...")
        self._restore_settings()
        self.running = False
    
    def _ensure_directories(self):
        STATE_PATH.mkdir(parents=True, exist_ok=True)
    
    def _detect_input_devices(self) -> List[InputDevice]:
        devices = []
        gaming_keywords = ["gaming", "razer", "logitech", "steelseries", "corsair", "hyperx", "zowie", "finalmouse"]
        
        input_path = Path("/sys/class/input")
        for entry in input_path.iterdir():
            if not entry.name.startswith("event"):
                continue
            
            try:
                device_path = entry / "device"
                name = (device_path / "name").read_text().strip() if (device_path / "name").exists() else "unknown"
                
                uevent_path = device_path / "uevent"
                vendor_id = ""
                product_id = ""
                if uevent_path.exists():
                    for line in uevent_path.read_text().split("\n"):
                        if line.startswith("PRODUCT="):
                            parts = line.split("=")[1].split("/")
                            if len(parts) >= 2:
                                vendor_id = parts[0]
                                product_id = parts[1]
                
                irq = None
                irq_path = device_path / "irq"
                if irq_path.exists():
                    try:
                        irq = int(irq_path.read_text().strip())
                    except ValueError:
                        pass
                
                is_gaming = any(kw in name.lower() for kw in gaming_keywords)
                
                devices.append(InputDevice(
                    name=name,
                    path=f"/dev/input/{entry.name}",
                    vendor_id=vendor_id,
                    product_id=product_id,
                    irq=irq,
                    is_gaming=is_gaming
                ))
            except Exception:
                continue
        
        return devices
    
    def _set_irq_affinity(self, irq: int, cpu_mask: str):
        try:
            irq_path = Path(f"/proc/irq/{irq}/smp_affinity")
            if irq_path.exists():
                irq_path.write_text(cpu_mask)
                self.logger.debug(f"Set IRQ {irq} affinity to {cpu_mask}")
        except (PermissionError, OSError) as e:
            self.logger.warning(f"Failed to set IRQ {irq} affinity: {e}")
    
    def _optimize_input_irqs(self):
        if not self.config["irq_affinity_enabled"]:
            return
        
        input_cores = self.config["dedicated_input_cores"]
        if not input_cores:
            return
        
        cpu_mask = hex(sum(1 << c for c in input_cores))[2:]
        
        for device in self.input_devices:
            if device.irq:
                self._set_irq_affinity(device.irq, cpu_mask)
        
        try:
            interrupts = Path("/proc/interrupts").read_text()
            for line in interrupts.split("\n"):
                if "xhci" in line.lower() or "usb" in line.lower():
                    parts = line.split(":")
                    if parts:
                        try:
                            irq = int(parts[0].strip())
                            self._set_irq_affinity(irq, cpu_mask)
                        except ValueError:
                            pass
        except Exception:
            pass
    
    def _set_usb_polling_rate(self):
        target_rate = self.config["usb_polling_rate_hz"]
        interval = 1000 // target_rate
        
        modprobe_conf = Path("/etc/modprobe.d/aegis-usb-polling.conf")
        try:
            modprobe_conf.write_text(f"options usbhid mousepoll={interval}\n")
            self.logger.info(f"Set USB polling interval to {interval}ms ({target_rate}Hz)")
        except PermissionError:
            pass
    
    def _set_cpu_governor(self, governor: str):
        cpu_path = Path("/sys/devices/system/cpu")
        for cpu_dir in cpu_path.iterdir():
            if not cpu_dir.name.startswith("cpu") or not cpu_dir.name[3:].isdigit():
                continue
            
            governor_path = cpu_dir / "cpufreq/scaling_governor"
            if governor_path.exists():
                try:
                    if cpu_dir.name not in self.original_cpu_governor:
                        self.original_cpu_governor[cpu_dir.name] = governor_path.read_text().strip()
                    governor_path.write_text(governor)
                except (PermissionError, OSError):
                    pass
    
    def _restore_cpu_governors(self):
        cpu_path = Path("/sys/devices/system/cpu")
        for cpu_name, original in self.original_cpu_governor.items():
            governor_path = cpu_path / cpu_name / "cpufreq/scaling_governor"
            if governor_path.exists():
                try:
                    governor_path.write_text(original)
                except (PermissionError, OSError):
                    pass
    
    def _optimize_network(self):
        if not self.config["network_optimization_enabled"]:
            return
        
        sysctl_settings = {
            "net.ipv4.tcp_low_latency": "1",
            "net.ipv4.tcp_fastopen": "3",
            "net.core.netdev_budget": "600",
            "net.core.netdev_budget_usecs": "4000",
            "net.ipv4.tcp_congestion_control": "bbr",
        }
        
        for key, value in sysctl_settings.items():
            path = Path("/proc/sys") / key.replace(".", "/")
            try:
                if path.exists():
                    path.write_text(value)
            except (PermissionError, OSError):
                pass
    
    def _detect_gaming_activity(self) -> bool:
        patterns = self.config["gaming_process_patterns"]
        try:
            ps_output = subprocess.run(["ps", "aux"], capture_output=True, text=True)
            for line in ps_output.stdout.split("\n"):
                for pattern in patterns:
                    if pattern.lower() in line.lower():
                        return True
        except Exception:
            pass
        return False
    
    def _pin_gaming_processes(self):
        gaming_cores = self.config["gaming_cores"]
        if not gaming_cores:
            return
        
        cpu_mask = ",".join(map(str, gaming_cores))
        patterns = self.config["gaming_process_patterns"]
        
        try:
            for proc_dir in Path("/proc").iterdir():
                if not proc_dir.name.isdigit():
                    continue
                
                try:
                    comm = (proc_dir / "comm").read_text().strip().lower()
                    cmdline = (proc_dir / "cmdline").read_text().lower()
                    
                    if any(p in comm or p in cmdline for p in patterns):
                        pid = proc_dir.name
                        subprocess.run(
                            ["taskset", "-acp", cpu_mask, pid],
                            capture_output=True
                        )
                except (FileNotFoundError, PermissionError):
                    continue
        except Exception:
            pass
    
    def _write_status(self):
        status = {
            "gaming_active": self.gaming_active,
            "input_devices": len(self.input_devices),
            "gaming_devices": sum(1 for d in self.input_devices if d.is_gaming),
            "irq_affinity_enabled": self.config["irq_affinity_enabled"],
            "network_optimized": self.config["network_optimization_enabled"]
        }
        try:
            with open(STATE_PATH / "status.json", "w") as f:
                json.dump(status, f, indent=2)
        except Exception:
            pass
    
    def _restore_settings(self):
        self._restore_cpu_governors()
    
    def run(self):
        if os.geteuid() != 0:
            print("Latency FastPath requires root privileges", file=sys.stderr)
            sys.exit(1)
        
        self.logger.info("Aegis Latency FastPath started")
        
        self.input_devices = self._detect_input_devices()
        self.logger.info(f"Detected {len(self.input_devices)} input devices")
        
        self._optimize_input_irqs()
        self._set_usb_polling_rate()
        self._optimize_network()
        
        while self.running:
            was_gaming = self.gaming_active
            self.gaming_active = self._detect_gaming_activity()
            
            if self.gaming_active and not was_gaming:
                self.logger.info("Gaming detected, enabling performance mode")
                if self.config["disable_cpu_powersave_on_game"]:
                    self._set_cpu_governor(self.config["cpu_governor_gaming"])
            elif not self.gaming_active and was_gaming:
                self.logger.info("Gaming ended, restoring power settings")
                self._restore_cpu_governors()
            
            if self.gaming_active:
                self._pin_gaming_processes()
            
            self._write_status()
            time.sleep(self.config["check_interval_seconds"])
        
        self.logger.info("Latency FastPath stopped")

def main():
    service = LatencyFastPath()
    service.run()

if __name__ == "__main__":
    main()
