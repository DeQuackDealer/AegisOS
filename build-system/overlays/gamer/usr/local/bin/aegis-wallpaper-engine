#!/usr/bin/env python3
"""
Aegis OS Wallpaper Engine v3.1 - SIGMA Gamer Edition
Advanced animated wallpaper system with MPV rendering, AI preference learning,
Steam Workshop import, multi-monitor support, and auto-updates

Supports:
  Video: MP4, AVI, MKV, WebM, MOV, HEVC, VP9, AV1
  Image: JPG, PNG, GIF, WebP, TIFF, SVG, HEIC
"""

import os
import sys
import json
import subprocess
import threading
import time
import signal
import hashlib
import random
import logging
import argparse
import re
import shutil
from pathlib import Path
from datetime import datetime, timedelta
from collections import defaultdict
from typing import Dict, List, Optional, Any, Tuple

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    TK_AVAILABLE = True
except ImportError:
    TK_AVAILABLE = False

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False

try:
    import urllib.request
    import urllib.error
    URLLIB_AVAILABLE = True
except ImportError:
    URLLIB_AVAILABLE = False

VERSION = "3.1.0"
TIER_LIMIT = "gamer"

SUPPORTED_VIDEO_FORMATS = ['.mp4', '.avi', '.mkv', '.webm', '.mov', '.wmv', '.flv', '.m4v', '.3gp', '.ogv', '.ts', '.mts', '.hevc']
SUPPORTED_IMAGE_FORMATS = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.tif', '.svg', '.heic', '.heif']
SUPPORTED_AUDIO_FORMATS = ['.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a']

CONFIG_DIR = Path.home() / ".config" / "aegis" / "wallpaper-engine"
DATA_DIR = Path.home() / ".local" / "share" / "aegis" / "wallpapers"
CACHE_DIR = Path("/tmp") / "aegis-wallpaper-cache"
LOG_FILE = Path("/var/log/aegis/wallpaper-engine.log")
STEAM_WORKSHOP_DIR = Path.home() / ".steam" / "steam" / "steamapps" / "workshop" / "content" / "431960"

UPDATE_CHECK_URL = "https://wallpapers.aegis-os.com/api/v1"
UPDATE_CHECK_INTERVAL_DAYS = 7

WALLPAPER_CATEGORIES = [
    "Anime", "Nature", "Abstract", "Gaming", "Space", "Urban", "Animals",
    "Technology", "Fantasy", "Minimalist", "Sports", "Art", "Movies", "Music"
]

class Logger:
    """Centralized logging for wallpaper engine"""
    
    def __init__(self):
        self.log_file = self._get_log_file()
        self._setup_logging()
        
    def _get_log_file(self) -> Path:
        primary = Path("/var/log/aegis/wallpaper-engine.log")
        fallback = Path.home() / ".local" / "share" / "aegis" / "logs" / "wallpaper-engine.log"
        
        try:
            primary.parent.mkdir(parents=True, exist_ok=True)
            return primary
        except (PermissionError, OSError):
            try:
                fallback.parent.mkdir(parents=True, exist_ok=True)
                return fallback
            except Exception:
                return fallback
                
    def _setup_logging(self):
        handlers = [logging.StreamHandler()]
        
        try:
            self.log_file.parent.mkdir(parents=True, exist_ok=True)
            handlers.append(logging.FileHandler(str(self.log_file)))
        except (PermissionError, OSError):
            pass
            
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=handlers
        )
        self.logger = logging.getLogger("aegis-wallpaper-engine")
        
    def info(self, msg): self.logger.info(msg)
    def warning(self, msg): self.logger.warning(msg)
    def error(self, msg): self.logger.error(msg)
    def debug(self, msg): self.logger.debug(msg)


logger = Logger()


class TierManager:
    """Manages tier-based feature access"""
    
    TIER_FEATURES = {
        "freemium": {
            "animated_wallpapers": False,
            "video_max_duration": 0,
            "formats_video": [],
            "formats_image": [".jpg", ".jpeg", ".png", ".bmp"],
            "multi_monitor": False,
            "playlists": False,
            "steam_workshop": False,
            "audio_control": False,
            "ai_suggestions": False,
            "gaming_mode": False
        },
        "basic": {
            "animated_wallpapers": True,
            "video_max_duration": 30,
            "formats_video": [".mp4", ".webm"],
            "formats_image": SUPPORTED_IMAGE_FORMATS[:6],
            "multi_monitor": False,
            "playlists": True,
            "steam_workshop": False,
            "audio_control": True,
            "ai_suggestions": False,
            "gaming_mode": True
        },
        "gamer": {
            "animated_wallpapers": True,
            "video_max_duration": -1,
            "formats_video": SUPPORTED_VIDEO_FORMATS,
            "formats_image": SUPPORTED_IMAGE_FORMATS,
            "multi_monitor": True,
            "playlists": True,
            "steam_workshop": True,
            "audio_control": True,
            "ai_suggestions": True,
            "gaming_mode": True
        },
        "gamer-ai": {
            "animated_wallpapers": True,
            "video_max_duration": -1,
            "formats_video": SUPPORTED_VIDEO_FORMATS,
            "formats_image": SUPPORTED_IMAGE_FORMATS,
            "multi_monitor": True,
            "playlists": True,
            "steam_workshop": True,
            "audio_control": True,
            "ai_suggestions": True,
            "gaming_mode": True,
            "ai_generation": True
        }
    }
    
    def __init__(self, tier: str = "gamer"):
        self.tier = tier
        self.features = self.TIER_FEATURES.get(tier, self.TIER_FEATURES["gamer"])
        
    def can_use(self, feature: str) -> bool:
        return self.features.get(feature, False)
        
    def get_video_limit(self) -> int:
        return self.features.get("video_max_duration", -1)
        
    def get_supported_formats(self) -> Dict[str, List[str]]:
        return {
            "video": self.features.get("formats_video", []),
            "image": self.features.get("formats_image", [])
        }


class AudioController:
    """Advanced audio control system with per-application volume"""
    
    def __init__(self):
        self.master_volume = 100
        self.wallpaper_volume = 50
        self.muted = True
        self.audio_ducking = True
        self.ducking_level = 30
        self.equalizer = {'bass': 0, 'mid': 0, 'treble': 0}
        self.sink_input_id = None
        
    def set_master_volume(self, level: int):
        self.master_volume = max(0, min(100, level))
        self._apply_volume()
        
    def set_wallpaper_volume(self, level: int):
        self.wallpaper_volume = max(0, min(100, level))
        self._apply_volume()
        
    def toggle_mute(self) -> bool:
        self.muted = not self.muted
        self._apply_volume()
        return self.muted
        
    def set_audio_ducking(self, enabled: bool, level: int = 30):
        self.audio_ducking = enabled
        self.ducking_level = level
        
    def set_equalizer(self, bass: int = 0, mid: int = 0, treble: int = 0):
        self.equalizer = {
            'bass': max(-10, min(10, bass)),
            'mid': max(-10, min(10, mid)),
            'treble': max(-10, min(10, treble))
        }
        
    def _apply_volume(self):
        if self.muted:
            volume = 0
        else:
            volume = int(self.master_volume * self.wallpaper_volume / 100)
            
        try:
            if self.sink_input_id:
                subprocess.run([
                    'pactl', 'set-sink-input-volume',
                    str(self.sink_input_id), f'{volume}%'
                ], capture_output=True, timeout=2)
            else:
                subprocess.run([
                    'pactl', 'set-sink-volume',
                    '@DEFAULT_SINK@', f'{volume}%'
                ], capture_output=True, timeout=2)
        except Exception as e:
            logger.warning(f"Failed to set audio volume: {e}")
            
    def find_mpv_sink(self):
        try:
            result = subprocess.run(['pactl', 'list', 'sink-inputs'],
                                   capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                current_id = None
                for line in result.stdout.split('\n'):
                    if 'Sink Input #' in line:
                        current_id = line.split('#')[1].strip()
                    if 'mpv' in line.lower() and current_id:
                        self.sink_input_id = current_id
                        return
        except Exception:
            pass


class VideoProcessor:
    """FFmpeg-based video processing for wallpapers"""
    
    def __init__(self):
        self.ffmpeg_available = self._check_ffmpeg()
        self.cache_dir = CACHE_DIR
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
    def _check_ffmpeg(self) -> bool:
        try:
            result = subprocess.run(['ffmpeg', '-version'], capture_output=True, timeout=5)
            return result.returncode == 0
        except Exception:
            return False
            
    def get_video_info(self, video_path: str) -> Optional[Dict]:
        if not self.ffmpeg_available:
            return None
            
        try:
            cmd = [
                'ffprobe', '-v', 'quiet', '-print_format', 'json',
                '-show_format', '-show_streams', str(video_path)
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                return json.loads(result.stdout)
        except Exception as e:
            logger.warning(f"Failed to get video info: {e}")
        return None
        
    def get_video_duration(self, video_path: str) -> float:
        info = self.get_video_info(video_path)
        if info and 'format' in info:
            try:
                return float(info['format'].get('duration', 0))
            except ValueError:
                pass
        return 0
        
    def remove_audio(self, video_path: str, output_path: str = None) -> str:
        if not self.ffmpeg_available:
            return video_path
            
        if output_path is None:
            output_path = self.cache_dir / f"{Path(video_path).stem}_silent.mp4"
            
        if Path(output_path).exists():
            return str(output_path)
            
        try:
            cmd = [
                'ffmpeg', '-y', '-i', str(video_path),
                '-an', '-c:v', 'copy', str(output_path)
            ]
            result = subprocess.run(cmd, capture_output=True, timeout=300)
            if result.returncode == 0:
                return str(output_path)
        except Exception as e:
            logger.warning(f"Failed to remove audio: {e}")
        return video_path
        
    def upscale_video(self, video_path: str, target_resolution: str = '4k') -> str:
        if not self.ffmpeg_available:
            return video_path
            
        resolutions = {
            '1080p': '1920:1080',
            '1440p': '2560:1440',
            '4k': '3840:2160',
            '8k': '7680:4320'
        }
        
        res = resolutions.get(target_resolution, '3840:2160')
        output_path = self.cache_dir / f"{Path(video_path).stem}_{target_resolution}.mp4"
        
        if output_path.exists():
            return str(output_path)
            
        try:
            cmd = [
                'ffmpeg', '-y', '-i', str(video_path),
                '-vf', f'scale={res}:flags=lanczos',
                '-c:v', 'libx264', '-preset', 'slow', '-crf', '18',
                '-c:a', 'copy', str(output_path)
            ]
            result = subprocess.run(cmd, capture_output=True, timeout=1800)
            if result.returncode == 0:
                return str(output_path)
        except Exception as e:
            logger.warning(f"Failed to upscale video: {e}")
        return video_path
        
    def generate_thumbnail(self, video_path: str, time_offset: str = '00:00:01') -> Optional[str]:
        if not self.ffmpeg_available:
            return None
            
        output_path = self.cache_dir / f"{Path(video_path).stem}_thumb.jpg"
        
        if output_path.exists():
            return str(output_path)
            
        try:
            cmd = [
                'ffmpeg', '-y', '-ss', time_offset, '-i', str(video_path),
                '-vframes', '1', '-q:v', '2', str(output_path)
            ]
            result = subprocess.run(cmd, capture_output=True, timeout=30)
            if result.returncode == 0:
                return str(output_path)
        except Exception as e:
            logger.warning(f"Failed to generate thumbnail: {e}")
        return None
        
    def convert_format(self, input_path: str, output_format: str) -> Optional[str]:
        if not self.ffmpeg_available:
            return None
            
        output_path = self.cache_dir / f"{Path(input_path).stem}.{output_format}"
        
        try:
            cmd = ['ffmpeg', '-y', '-i', str(input_path)]
            if output_format in ['mp4', 'webm', 'mkv']:
                cmd.extend(['-c:v', 'libx264', '-crf', '23', '-c:a', 'aac'])
            cmd.append(str(output_path))
            
            result = subprocess.run(cmd, capture_output=True, timeout=600)
            if result.returncode == 0:
                return str(output_path)
        except Exception as e:
            logger.warning(f"Failed to convert format: {e}")
        return None


class MonitorManager:
    """Multi-monitor detection and management"""
    
    def __init__(self):
        self.monitors = []
        self.refresh()
        
    def refresh(self):
        self.monitors = self._detect_monitors()
        
    def _detect_monitors(self) -> List[Dict]:
        monitors = []
        try:
            result = subprocess.run(['xrandr', '--query'],
                                   capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                current_monitor = None
                for line in result.stdout.split('\n'):
                    if ' connected' in line:
                        parts = line.split()
                        name = parts[0]
                        is_primary = 'primary' in line
                        
                        resolution = None
                        offset_x, offset_y = 0, 0
                        for part in parts:
                            match = re.match(r'(\d+)x(\d+)\+(\d+)\+(\d+)', part)
                            if match:
                                resolution = f"{match.group(1)}x{match.group(2)}"
                                offset_x = int(match.group(3))
                                offset_y = int(match.group(4))
                                break
                                
                        if resolution:
                            monitors.append({
                                'name': name,
                                'resolution': resolution,
                                'offset_x': offset_x,
                                'offset_y': offset_y,
                                'primary': is_primary
                            })
        except Exception as e:
            logger.warning(f"Failed to detect monitors: {e}")
            
        if not monitors:
            monitors = [{'name': 'default', 'resolution': '1920x1080',
                        'offset_x': 0, 'offset_y': 0, 'primary': True}]
        return monitors
        
    def get_monitor_count(self) -> int:
        return len(self.monitors)
        
    def get_primary_monitor(self) -> Optional[Dict]:
        for mon in self.monitors:
            if mon.get('primary'):
                return mon
        return self.monitors[0] if self.monitors else None
        
    def get_total_resolution(self) -> str:
        if not self.monitors:
            return "1920x1080"
        max_x = max(m['offset_x'] + int(m['resolution'].split('x')[0]) for m in self.monitors)
        max_y = max(m['offset_y'] + int(m['resolution'].split('x')[1]) for m in self.monitors)
        return f"{max_x}x{max_y}"


class MPVRenderer:
    """MPV-based wallpaper rendering with multi-monitor support"""
    
    def __init__(self, monitor_manager: MonitorManager):
        self.monitor_manager = monitor_manager
        self.mpv_available = self._check_mpv()
        self.xwinwrap_available = self._check_xwinwrap()
        self.processes: Dict[str, subprocess.Popen] = {}
        self.current_wallpaper = None
        
    def _check_mpv(self) -> bool:
        try:
            result = subprocess.run(['mpv', '--version'], capture_output=True, timeout=5)
            return result.returncode == 0
        except Exception:
            return False
            
    def _check_xwinwrap(self) -> bool:
        try:
            result = subprocess.run(['which', 'xwinwrap'], capture_output=True, timeout=5)
            return result.returncode == 0
        except Exception:
            return False
            
    def is_available(self) -> bool:
        return self.mpv_available
        
    def get_root_window_id(self, display: str = ':0') -> Optional[str]:
        try:
            env = os.environ.copy()
            env['DISPLAY'] = display
            
            result = subprocess.run(
                ['xdotool', 'search', '--class', 'Desktop'],
                capture_output=True, text=True, timeout=5, env=env
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip().split('\n')[0]
                
            result = subprocess.run(
                ['xwininfo', '-root'],
                capture_output=True, text=True, timeout=5, env=env
            )
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'Window id:' in line:
                        parts = line.split()
                        for p in parts:
                            if p.startswith('0x'):
                                return p
        except Exception as e:
            logger.warning(f"Failed to get root window ID: {e}")
        return None
        
    def start_video(self, video_path: str, options: Dict = None,
                   monitors: List[str] = None, display: str = ':0') -> bool:
        if not self.mpv_available:
            logger.error("MPV not found. Install with: sudo apt install mpv")
            return False
            
        self.stop()
        options = options or {}
        
        target_monitors = monitors or ['all']
        if 'all' in target_monitors:
            target_monitors = [m['name'] for m in self.monitor_manager.monitors]
            
        env = os.environ.copy()
        env['DISPLAY'] = display
        
        volume = options.get('volume', 0)
        if options.get('muted', True):
            volume = 0
            
        loop_arg = '--loop' if options.get('loop', True) else '--loop=no'
        brightness = options.get('brightness', 0)
        contrast = options.get('contrast', 0)
        saturation = options.get('saturation', 0)
        
        success = False
        
        for monitor_name in target_monitors:
            monitor = next((m for m in self.monitor_manager.monitors 
                          if m['name'] == monitor_name), None)
            if not monitor:
                continue
                
            res = monitor['resolution']
            offset_x = monitor['offset_x']
            offset_y = monitor['offset_y']
            geometry = f"{res}+{offset_x}+{offset_y}"
            
            if self.xwinwrap_available:
                mpv_cmd = (
                    f"mpv --wid WID {loop_arg} "
                    f"{'--no-audio' if options.get('muted', True) else f'--volume={volume}'} "
                    f"--no-osc --no-input-default-bindings --no-border "
                    f"--panscan=1.0 --video-unscaled=downscale-big "
                    f"--brightness={brightness} --contrast={contrast} --saturation={saturation} "
                    f"'{video_path}'"
                )
                
                cmd = [
                    'xwinwrap', '-g', geometry, '-ov', '-ni', '-s', '-nf',
                    '--', 'sh', '-c', mpv_cmd
                ]
            else:
                wid = self.get_root_window_id(display)
                cmd = [
                    'mpv',
                    '--no-audio' if options.get('muted', True) else f'--volume={volume}',
                    loop_arg,
                    '--no-osc',
                    '--no-input-default-bindings',
                    '--no-border',
                    '--panscan=1.0',
                    f'--brightness={brightness}',
                    f'--contrast={contrast}',
                    f'--saturation={saturation}',
                ]
                if wid:
                    cmd.extend(['--wid', wid])
                cmd.append(str(video_path))
                
            try:
                process = subprocess.Popen(
                    cmd,
                    env=env,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
                self.processes[monitor_name] = process
                success = True
                logger.info(f"Started video wallpaper on {monitor_name}")
            except Exception as e:
                logger.error(f"Failed to start MPV on {monitor_name}: {e}")
                
        if success:
            self.current_wallpaper = video_path
            
        return success
        
    def start_image(self, image_path: str, options: Dict = None,
                   monitors: List[str] = None, display: str = ':0') -> bool:
        options = options or {}
        effect = options.get('effect', 'none')
        
        target_monitors = monitors or ['all']
        if 'all' in target_monitors:
            target_monitors = [m['name'] for m in self.monitor_manager.monitors]
            
        if effect != 'none' and self.mpv_available:
            return self._start_animated_image(image_path, effect, target_monitors, display)
        else:
            return self._set_static_image(image_path, target_monitors, display)
            
    def _start_animated_image(self, image_path: str, effect: str,
                              monitors: List[str], display: str) -> bool:
        self.stop()
        
        env = os.environ.copy()
        env['DISPLAY'] = display
        
        vf_filter = ''
        if effect == 'ken-burns':
            vf_filter = "zoompan=z='min(zoom+0.0015,1.5)':d=1:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':s=1920x1080"
        elif effect == 'parallax':
            vf_filter = 'scroll=horizontal=0.01:vertical=0'
        elif effect == 'pulse':
            vf_filter = "eq=brightness='0.1*sin(2*PI*t/4)'"
        elif effect == 'rain':
            vf_filter = "noise=alls=20:allf=t+u"
            
        success = False
        
        for monitor_name in monitors:
            monitor = next((m for m in self.monitor_manager.monitors 
                          if m['name'] == monitor_name), None)
            if not monitor:
                continue
                
            res = monitor['resolution']
            offset_x = monitor['offset_x']
            offset_y = monitor['offset_y']
            geometry = f"{res}+{offset_x}+{offset_y}"
            
            if self.xwinwrap_available:
                mpv_cmd = (
                    f"mpv --wid WID --loop --no-audio --no-osc "
                    f"--no-input-default-bindings --no-border --image-display-duration=inf "
                )
                if vf_filter:
                    mpv_cmd += f"--vf='{vf_filter}' "
                mpv_cmd += f"'{image_path}'"
                
                cmd = [
                    'xwinwrap', '-g', geometry, '-ov', '-ni', '-s', '-nf',
                    '--', 'sh', '-c', mpv_cmd
                ]
            else:
                cmd = [
                    'mpv', '--loop', '--no-audio', '--no-osc',
                    '--no-input-default-bindings', '--no-border',
                    '--image-display-duration=inf',
                ]
                if vf_filter:
                    cmd.append(f'--vf={vf_filter}')
                cmd.append(str(image_path))
                
            try:
                process = subprocess.Popen(
                    cmd, env=env,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
                self.processes[monitor_name] = process
                success = True
            except Exception as e:
                logger.warning(f"Failed animated image on {monitor_name}: {e}")
                
        if success:
            self.current_wallpaper = image_path
        else:
            return self._set_static_image(image_path, monitors, display)
            
        return success
        
    def _set_static_image(self, image_path: str, monitors: List[str], display: str) -> bool:
        env = os.environ.copy()
        env['DISPLAY'] = display
        
        setters = [
            ['xfconf-query', '-c', 'xfce4-desktop', '-p',
             '/backdrop/screen0/monitor0/workspace0/last-image', '-s', str(image_path)],
            ['gsettings', 'set', 'org.gnome.desktop.background',
             'picture-uri', f'file://{image_path}'],
            ['feh', '--bg-fill', str(image_path)],
            ['nitrogen', '--set-scaled', str(image_path)],
            ['pcmanfm', '--set-wallpaper', str(image_path)]
        ]
        
        for cmd in setters:
            try:
                result = subprocess.run(cmd, capture_output=True, timeout=10, env=env)
                if result.returncode == 0:
                    self.current_wallpaper = image_path
                    logger.info(f"Set static wallpaper using {cmd[0]}")
                    return True
            except Exception:
                continue
                
        logger.error("Failed to set static wallpaper with any available method")
        return False
        
    def pause(self):
        for name, proc in self.processes.items():
            try:
                proc.send_signal(signal.SIGSTOP)
                logger.info(f"Paused wallpaper on {name}")
            except Exception as e:
                logger.warning(f"Failed to pause {name}: {e}")
                
    def resume(self):
        for name, proc in self.processes.items():
            try:
                proc.send_signal(signal.SIGCONT)
                logger.info(f"Resumed wallpaper on {name}")
            except Exception as e:
                logger.warning(f"Failed to resume {name}: {e}")
                
    def stop(self):
        for name, proc in list(self.processes.items()):
            try:
                proc.terminate()
                proc.wait(timeout=5)
            except Exception:
                try:
                    proc.kill()
                except Exception:
                    pass
            del self.processes[name]
            
        subprocess.run(['pkill', '-f', 'xwinwrap.*mpv'], capture_output=True)
        subprocess.run(['pkill', '-f', 'mpv.*wallpaper'], capture_output=True)
        self.current_wallpaper = None


class GamingModeMonitor:
    """Detects fullscreen games and auto-pauses wallpaper"""
    
    GAME_PROCESSES = [
        'steam', 'steamwebhelper', 'wine', 'wine64', 'proton',
        'lutris', 'heroic', 'gamescope', 'mangohud',
        'csgo', 'dota2', 'tf2', 'hl2', 'portal',
        'minecraft', 'java'
    ]
    
    def __init__(self, renderer: MPVRenderer):
        self.renderer = renderer
        self.running = False
        self.gaming_active = False
        self.thread = None
        self.check_interval = 5
        
    def start(self):
        if self.running:
            return
        self.running = True
        self.thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.thread.start()
        logger.info("Gaming mode monitor started")
        
    def stop(self):
        self.running = False
        if self.thread:
            self.thread.join(timeout=2)
        logger.info("Gaming mode monitor stopped")
        
    def _monitor_loop(self):
        while self.running:
            is_gaming = self._detect_gaming()
            
            if is_gaming and not self.gaming_active:
                self.gaming_active = True
                self.renderer.pause()
                logger.info("Gaming detected - wallpaper paused")
            elif not is_gaming and self.gaming_active:
                self.gaming_active = False
                self.renderer.resume()
                logger.info("Gaming ended - wallpaper resumed")
                
            time.sleep(self.check_interval)
            
    def _detect_gaming(self) -> bool:
        if self._detect_fullscreen_window():
            return True
            
        if self._detect_game_processes():
            return True
            
        if self._detect_high_gpu_usage():
            return True
            
        return False
        
    def _detect_fullscreen_window(self) -> bool:
        try:
            result = subprocess.run(
                ['xdotool', 'getactivewindow', 'getwindowname'],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode != 0:
                return False
                
            window_name = result.stdout.strip().lower()
            
            game_keywords = ['steam', 'game', 'wine', 'proton', 'lutris']
            if any(kw in window_name for kw in game_keywords):
                result = subprocess.run(
                    ['xdotool', 'getactivewindow', 'getwindowgeometry'],
                    capture_output=True, text=True, timeout=2
                )
                return True
        except Exception:
            pass
        return False
        
    def _detect_game_processes(self) -> bool:
        if not PSUTIL_AVAILABLE:
            return False
            
        try:
            for proc in psutil.process_iter(['name', 'cpu_percent']):
                name = proc.info['name'].lower()
                if any(game in name for game in self.GAME_PROCESSES):
                    if proc.info.get('cpu_percent', 0) > 20:
                        return True
        except Exception:
            pass
        return False
        
    def _detect_high_gpu_usage(self) -> bool:
        try:
            result = subprocess.run(
                ['nvidia-smi', '--query-gpu=utilization.gpu',
                 '--format=csv,noheader,nounits'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                usage = int(result.stdout.strip())
                return usage > 70
        except Exception:
            pass
        return False


class PreferenceLearner:
    """AI-based preference learning for wallpaper suggestions"""
    
    def __init__(self):
        self.config_dir = CONFIG_DIR
        self.preferences_file = self.config_dir / "preferences.json"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.preferences = self._load_preferences()
        
    def _load_preferences(self) -> Dict:
        default = {
            'history': [],
            'time_patterns': {},
            'category_scores': {},
            'settings_history': [],
            'favorite_dirs': [],
            'avg_duration': 0,
            'total_sessions': 0
        }
        
        try:
            if self.preferences_file.exists():
                with open(self.preferences_file, 'r') as f:
                    data = json.load(f)
                    return {**default, **data}
        except (json.JSONDecodeError, Exception) as e:
            logger.warning(f"Failed to load preferences: {e}")
        return default
        
    def _save_preferences(self):
        save_data = {
            'history': self.preferences['history'][-100:],
            'time_patterns': self.preferences['time_patterns'],
            'category_scores': self.preferences['category_scores'],
            'settings_history': self.preferences['settings_history'][-50:],
            'favorite_dirs': self.preferences['favorite_dirs'][:10],
            'avg_duration': self.preferences['avg_duration'],
            'total_sessions': self.preferences['total_sessions']
        }
        
        try:
            with open(self.preferences_file, 'w') as f:
                json.dump(save_data, f, indent=2)
        except Exception as e:
            logger.warning(f"Failed to save preferences: {e}")
            
    def record_wallpaper_set(self, path: str, settings: Dict = None):
        now = datetime.now()
        hour = now.hour
        day_of_week = now.strftime('%A')
        
        time_slot = 'morning' if 5 <= hour < 12 else \
                    'afternoon' if 12 <= hour < 17 else \
                    'evening' if 17 <= hour < 21 else 'night'
        
        category = self._detect_category(path)
        
        entry = {
            'path': str(path),
            'timestamp': now.isoformat(),
            'hour': hour,
            'day': day_of_week,
            'time_slot': time_slot,
            'category': category,
            'settings': settings or {}
        }
        
        self.preferences['history'].append(entry)
        
        if time_slot not in self.preferences['time_patterns']:
            self.preferences['time_patterns'][time_slot] = []
        self.preferences['time_patterns'][time_slot].append(str(path))
        
        if category not in self.preferences['category_scores']:
            self.preferences['category_scores'][category] = 0
        self.preferences['category_scores'][category] += 1.0
        
        self.preferences['total_sessions'] += 1
        
        parent_dir = str(Path(path).parent)
        if parent_dir not in self.preferences['favorite_dirs']:
            self.preferences['favorite_dirs'].insert(0, parent_dir)
            self.preferences['favorite_dirs'] = self.preferences['favorite_dirs'][:10]
            
        self._save_preferences()
        
    def _detect_category(self, path: str) -> str:
        path_lower = str(path).lower()
        
        categories = {
            'nature': ['nature', 'forest', 'mountain', 'ocean', 'sky', 'landscape', 'tree', 'water', 'sunset', 'sunrise', 'beach'],
            'space': ['space', 'galaxy', 'star', 'planet', 'nebula', 'cosmos', 'universe', 'moon', 'aurora', 'solar'],
            'abstract': ['abstract', 'geometric', 'pattern', 'fractal', 'minimal', 'art', 'design', 'gradient'],
            'gaming': ['game', 'gaming', 'cyberpunk', 'neon', 'scifi', 'fantasy', 'rpg', 'fps', 'mmorpg'],
            'anime': ['anime', 'manga', 'waifu', 'otaku', 'kawaii', 'japan', 'weeb'],
            'urban': ['city', 'urban', 'street', 'building', 'architecture', 'night', 'skyline'],
            'animals': ['animal', 'cat', 'dog', 'bird', 'wildlife', 'pet', 'nature'],
            'technology': ['tech', 'code', 'computer', 'circuit', 'digital', 'cyber', 'programming']
        }
        
        for category, keywords in categories.items():
            for keyword in keywords:
                if keyword in path_lower:
                    return category
                    
        return 'general'
        
    def get_suggestions(self, count: int = 5) -> List[str]:
        now = datetime.now()
        hour = now.hour
        time_slot = 'morning' if 5 <= hour < 12 else \
                    'afternoon' if 12 <= hour < 17 else \
                    'evening' if 17 <= hour < 21 else 'night'
        
        suggestions = []
        
        time_based = self.preferences['time_patterns'].get(time_slot, [])
        if time_based:
            time_suggestions = [p for p in time_based if Path(p).exists()][-count:]
            suggestions.extend(time_suggestions)
            
        for dir_path in self.preferences['favorite_dirs'][:3]:
            if Path(dir_path).exists():
                try:
                    files = list(Path(dir_path).glob('*'))
                    for f in files[:2]:
                        ext = f.suffix.lower()
                        if ext in SUPPORTED_VIDEO_FORMATS + SUPPORTED_IMAGE_FORMATS:
                            if str(f) not in suggestions:
                                suggestions.append(str(f))
                except Exception:
                    pass
                    
        seen = set()
        unique_suggestions = []
        for s in suggestions:
            if s not in seen:
                seen.add(s)
                unique_suggestions.append(s)
                
        return unique_suggestions[:count]
        
    def get_stats(self) -> Dict:
        return {
            'total_wallpapers_set': len(self.preferences['history']),
            'total_sessions': self.preferences['total_sessions'],
            'favorite_categories': self.preferences['category_scores'],
            'favorite_dirs': self.preferences['favorite_dirs']
        }


class SteamWorkshopImporter:
    """Import wallpapers from Steam Workshop (Wallpaper Engine)"""
    
    def __init__(self):
        self.workshop_dir = STEAM_WORKSHOP_DIR
        self.imported_dir = DATA_DIR / "steam-workshop"
        self.imported_dir.mkdir(parents=True, exist_ok=True)
        
    def scan_workshop(self) -> List[Dict]:
        wallpapers = []
        
        if not self.workshop_dir.exists():
            logger.info("Steam Workshop directory not found")
            return wallpapers
            
        try:
            for item_dir in self.workshop_dir.iterdir():
                if item_dir.is_dir():
                    project_json = item_dir / "project.json"
                    if project_json.exists():
                        try:
                            with open(project_json, 'r') as f:
                                project = json.load(f)
                                
                            wallpaper = {
                                'id': item_dir.name,
                                'title': project.get('title', 'Unknown'),
                                'type': project.get('type', 'unknown'),
                                'file': project.get('file', ''),
                                'preview': project.get('preview', ''),
                                'path': str(item_dir),
                                'tags': project.get('tags', [])
                            }
                            wallpapers.append(wallpaper)
                        except json.JSONDecodeError:
                            pass
        except Exception as e:
            logger.warning(f"Failed to scan Steam Workshop: {e}")
            
        return wallpapers
        
    def import_wallpaper(self, workshop_id: str) -> Optional[str]:
        source_dir = self.workshop_dir / workshop_id
        if not source_dir.exists():
            logger.error(f"Workshop item {workshop_id} not found")
            return None
            
        project_json = source_dir / "project.json"
        if not project_json.exists():
            logger.error(f"No project.json in {workshop_id}")
            return None
            
        try:
            with open(project_json, 'r') as f:
                project = json.load(f)
                
            file_name = project.get('file', '')
            if not file_name:
                return None
                
            source_file = source_dir / file_name
            if not source_file.exists():
                return None
                
            dest_dir = self.imported_dir / workshop_id
            dest_dir.mkdir(parents=True, exist_ok=True)
            
            dest_file = dest_dir / file_name
            shutil.copy2(source_file, dest_file)
            
            with open(dest_dir / "project.json", 'w') as f:
                json.dump(project, f, indent=2)
                
            logger.info(f"Imported Steam Workshop wallpaper: {project.get('title', workshop_id)}")
            return str(dest_file)
            
        except Exception as e:
            logger.error(f"Failed to import {workshop_id}: {e}")
            return None
            
    def list_imported(self) -> List[Dict]:
        imported = []
        
        if not self.imported_dir.exists():
            return imported
            
        for item_dir in self.imported_dir.iterdir():
            if item_dir.is_dir():
                project_json = item_dir / "project.json"
                if project_json.exists():
                    try:
                        with open(project_json, 'r') as f:
                            project = json.load(f)
                        project['path'] = str(item_dir)
                        imported.append(project)
                    except Exception:
                        pass
                        
        return imported


class Playlist:
    """Wallpaper playlist/rotation manager"""
    
    def __init__(self, engine):
        self.engine = engine
        self.items: List[str] = []
        self.current_index = 0
        self.interval = 300
        self.shuffle = False
        self.running = False
        self.thread = None
        self.config_file = CONFIG_DIR / "playlist.json"
        self._load()
        
    def _load(self):
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    data = json.load(f)
                    self.items = data.get('items', [])
                    self.interval = data.get('interval', 300)
                    self.shuffle = data.get('shuffle', False)
        except Exception as e:
            logger.warning(f"Failed to load playlist: {e}")
            
    def _save(self):
        try:
            with open(self.config_file, 'w') as f:
                json.dump({
                    'items': self.items,
                    'interval': self.interval,
                    'shuffle': self.shuffle
                }, f, indent=2)
        except Exception as e:
            logger.warning(f"Failed to save playlist: {e}")
            
    def add(self, path: str):
        if path not in self.items:
            self.items.append(path)
            self._save()
            
    def remove(self, path: str):
        if path in self.items:
            self.items.remove(path)
            self._save()
            
    def clear(self):
        self.items = []
        self.current_index = 0
        self._save()
        
    def set_interval(self, seconds: int):
        self.interval = max(10, seconds)
        self._save()
        
    def set_shuffle(self, enabled: bool):
        self.shuffle = enabled
        self._save()
        
    def start(self):
        if self.running or not self.items:
            return
        self.running = True
        self.thread = threading.Thread(target=self._rotation_loop, daemon=True)
        self.thread.start()
        logger.info("Playlist rotation started")
        
    def stop(self):
        self.running = False
        if self.thread:
            self.thread.join(timeout=2)
        logger.info("Playlist rotation stopped")
        
    def next(self):
        if not self.items:
            return
            
        if self.shuffle:
            self.current_index = random.randint(0, len(self.items) - 1)
        else:
            self.current_index = (self.current_index + 1) % len(self.items)
            
        path = self.items[self.current_index]
        self.engine.set_wallpaper(path)
        
    def previous(self):
        if not self.items:
            return
            
        self.current_index = (self.current_index - 1) % len(self.items)
        path = self.items[self.current_index]
        self.engine.set_wallpaper(path)
        
    def _rotation_loop(self):
        while self.running:
            time.sleep(self.interval)
            if self.running:
                self.next()


class UpdateChecker:
    """Weekly update checker for wallpaper engine and wallpaper library"""
    
    def __init__(self):
        self.config_dir = CONFIG_DIR
        self.update_file = self.config_dir / "updates.json"
        self.update_data = self._load_update_data()
        
    def _load_update_data(self) -> Dict:
        default = {
            'last_check': None,
            'available_version': None,
            'wallpaper_catalog': [],
            'tips': [
                "Use gaming mode to auto-pause wallpapers during gameplay",
                "Press Ctrl+Shift+W to quickly change wallpapers",
                "Import Steam Workshop wallpapers for more options",
                "Create playlists to rotate wallpapers automatically"
            ]
        }
        
        try:
            if self.update_file.exists():
                with open(self.update_file, 'r') as f:
                    return {**default, **json.load(f)}
        except Exception:
            pass
        return default
        
    def _save_update_data(self):
        try:
            with open(self.update_file, 'w') as f:
                json.dump(self.update_data, f, indent=2)
        except Exception:
            pass
            
    def should_check(self) -> bool:
        last_check = self.update_data.get('last_check')
        if not last_check:
            return True
            
        try:
            last_dt = datetime.fromisoformat(last_check)
            return datetime.now() - last_dt > timedelta(days=UPDATE_CHECK_INTERVAL_DAYS)
        except Exception:
            return True
            
    def check_updates(self) -> Dict:
        if not URLLIB_AVAILABLE:
            return {'error': 'urllib not available'}
            
        result = {
            'update_available': False,
            'current_version': VERSION,
            'new_wallpapers': 0
        }
        
        try:
            req = urllib.request.Request(
                f"{UPDATE_CHECK_URL}/check",
                headers={'User-Agent': f'AegisWallpaperEngine/{VERSION}'}
            )
            
            with urllib.request.urlopen(req, timeout=10) as response:
                data = json.loads(response.read().decode())
                
            result['latest_version'] = data.get('version', VERSION)
            result['update_available'] = data.get('version', VERSION) > VERSION
            result['new_wallpapers'] = data.get('new_wallpapers', 0)
            result['changelog'] = data.get('changelog', '')
            
            self.update_data['last_check'] = datetime.now().isoformat()
            self.update_data['available_version'] = data.get('version')
            self._save_update_data()
            
        except Exception as e:
            result['error'] = str(e)
            
        return result
        
    def download_wallpaper(self, wallpaper_id: str) -> Optional[str]:
        if not URLLIB_AVAILABLE:
            return None
            
        try:
            req = urllib.request.Request(
                f"{UPDATE_CHECK_URL}/wallpapers/{wallpaper_id}/download",
                headers={'User-Agent': f'AegisWallpaperEngine/{VERSION}'}
            )
            
            with urllib.request.urlopen(req, timeout=60) as response:
                meta = json.loads(response.headers.get('X-Wallpaper-Meta', '{}'))
                filename = meta.get('filename', f'{wallpaper_id}.mp4')
                
                download_path = DATA_DIR / "downloads" / filename
                download_path.parent.mkdir(parents=True, exist_ok=True)
                
                with open(download_path, 'wb') as f:
                    f.write(response.read())
                    
            logger.info(f"Downloaded wallpaper: {filename}")
            return str(download_path)
            
        except Exception as e:
            logger.error(f"Failed to download wallpaper {wallpaper_id}: {e}")
            return None
            
    def get_random_tip(self) -> str:
        tips = self.update_data.get('tips', [])
        return random.choice(tips) if tips else "Enjoy your wallpapers!"


class WallpaperLibrary:
    """Manage installed wallpapers"""
    
    def __init__(self):
        self.data_dir = DATA_DIR
        self.data_dir.mkdir(parents=True, exist_ok=True)
        self.catalog_file = self.data_dir / "catalog.json"
        self.catalog = self._load_catalog()
        
    def _load_catalog(self) -> Dict:
        default = {'wallpapers': [], 'categories': WALLPAPER_CATEGORIES}
        
        try:
            if self.catalog_file.exists():
                with open(self.catalog_file, 'r') as f:
                    return {**default, **json.load(f)}
        except Exception:
            pass
        return default
        
    def _save_catalog(self):
        try:
            with open(self.catalog_file, 'w') as f:
                json.dump(self.catalog, f, indent=2)
        except Exception as e:
            logger.warning(f"Failed to save catalog: {e}")
            
    def scan(self) -> List[Dict]:
        wallpapers = []
        
        scan_dirs = [
            self.data_dir,
            Path.home() / "Pictures" / "Wallpapers",
            Path.home() / ".local" / "share" / "wallpapers",
            Path("/usr/share/backgrounds"),
            Path("/usr/share/wallpapers")
        ]
        
        for scan_dir in scan_dirs:
            if scan_dir.exists():
                for ext in SUPPORTED_VIDEO_FORMATS + SUPPORTED_IMAGE_FORMATS:
                    for f in scan_dir.rglob(f"*{ext}"):
                        wallpapers.append({
                            'path': str(f),
                            'name': f.stem,
                            'type': 'video' if ext in SUPPORTED_VIDEO_FORMATS else 'image',
                            'format': ext,
                            'size': f.stat().st_size if f.exists() else 0
                        })
                        
        self.catalog['wallpapers'] = wallpapers
        self._save_catalog()
        
        return wallpapers
        
    def list_all(self) -> List[Dict]:
        if not self.catalog['wallpapers']:
            return self.scan()
        return self.catalog['wallpapers']
        
    def filter_by_category(self, category: str) -> List[Dict]:
        return [w for w in self.list_all() 
                if category.lower() in w.get('path', '').lower()]
                
    def filter_by_type(self, wallpaper_type: str) -> List[Dict]:
        return [w for w in self.list_all() if w.get('type') == wallpaper_type]


class WallpaperEngine:
    """Main Wallpaper Engine controller"""
    
    VERSION = VERSION
    
    def __init__(self):
        self.config_dir = CONFIG_DIR
        self.config_file = self.config_dir / "config.json"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        
        self.tier_manager = TierManager(TIER_LIMIT)
        self.monitor_manager = MonitorManager()
        self.video_processor = VideoProcessor()
        self.audio = AudioController()
        self.renderer = MPVRenderer(self.monitor_manager)
        self.preference_learner = PreferenceLearner()
        self.gaming_monitor = GamingModeMonitor(self.renderer)
        self.steam_importer = SteamWorkshopImporter()
        self.update_checker = UpdateChecker()
        self.library = WallpaperLibrary()
        
        self.load_config()
        
        self.playlist = Playlist(self)
        
        self.current_wallpaper = self.config.get('current_wallpaper')
        self.current_mode = "stopped"
        self.running = True
        self.paused = False
        
        if self.config.get('performance', {}).get('auto_pause_gaming', True):
            if self.tier_manager.can_use('gaming_mode'):
                self.gaming_monitor.start()
                
        if self.config.get('updates', {}).get('auto_check', True):
            if self.update_checker.should_check():
                threading.Thread(target=self.update_checker.check_updates, daemon=True).start()
                
    def load_config(self):
        default_config = {
            "current_wallpaper": None,
            "video_options": {
                "loop": True,
                "muted": True,
                "remove_audio": True,
                "quality": "high"
            },
            "image_options": {
                "effect": "none",
                "transition": 3,
                "slideshow_interval": 300
            },
            "audio": {
                "master_volume": 100,
                "wallpaper_volume": 50,
                "muted": True,
                "ducking": True,
                "ducking_level": 30
            },
            "performance": {
                "auto_pause_gaming": True,
                "gpu_threshold": 70,
                "fps_limit": 30,
                "quality_preset": "high"
            },
            "display": {
                "monitors": "all",
                "resolution": "native",
                "brightness": 0,
                "contrast": 0,
                "saturation": 0
            },
            "ai": {
                "suggestions_enabled": True,
                "learn_preferences": True
            },
            "updates": {
                "auto_check": True,
                "show_notifications": True
            }
        }
        
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    self.config = {**default_config, **json.load(f)}
            else:
                self.config = default_config
                self.save_config()
        except Exception:
            self.config = default_config
            
    def save_config(self):
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
        except Exception as e:
            logger.warning(f"Failed to save config: {e}")
            
    def set_wallpaper(self, path: str, mode: str = None, options: Dict = None) -> bool:
        path = Path(path)
        
        if not path.exists():
            logger.error(f"File not found: {path}")
            return False
            
        ext = path.suffix.lower()
        options = options or {}
        
        merged_options = {
            **self.config.get('video_options', {}),
            **self.config.get('display', {}),
            **options
        }
        
        if ext in SUPPORTED_VIDEO_FORMATS:
            if not self.tier_manager.can_use('animated_wallpapers'):
                logger.warning("Video wallpapers require Gamer edition")
                print(" Video wallpapers require Gamer edition. Upgrade to unlock!")
                return False
                
            video_limit = self.tier_manager.get_video_limit()
            if video_limit > 0:
                duration = self.video_processor.get_video_duration(str(path))
                if duration > video_limit:
                    logger.warning(f"Video duration {duration}s exceeds tier limit {video_limit}s")
                    print(f" Video exceeds {video_limit}s limit for your tier")
                    return False
                    
            success = self._set_video_wallpaper(str(path), merged_options)
        elif ext in SUPPORTED_IMAGE_FORMATS:
            success = self._set_image_wallpaper(str(path), merged_options)
        else:
            logger.error(f"Unsupported format: {ext}")
            return False
            
        if success:
            self.current_wallpaper = str(path)
            self.config['current_wallpaper'] = str(path)
            self.save_config()
            
            if self.config['ai']['learn_preferences']:
                settings = {
                    'brightness': merged_options.get('brightness', 0),
                    'contrast': merged_options.get('contrast', 0),
                    'saturation': merged_options.get('saturation', 0),
                    'volume': merged_options.get('volume', 50),
                    'effect': merged_options.get('effect', 'none')
                }
                self.preference_learner.record_wallpaper_set(str(path), settings)
                
        return success
        
    def _set_video_wallpaper(self, video_path: str, options: Dict) -> bool:
        if options.get('remove_audio', True):
            video_path = self.video_processor.remove_audio(video_path)
            
        if options.get('quality') == 'ultra':
            video_path = self.video_processor.upscale_video(video_path, '4k')
            
        monitors = options.get('monitors', 'all')
        if monitors == 'all':
            monitor_list = None
        else:
            monitor_list = [monitors] if isinstance(monitors, str) else monitors
            
        success = self.renderer.start_video(video_path, options, monitor_list)
        
        if success:
            self.current_mode = "video"
            self.audio.find_mpv_sink()
            
        return success
        
    def _set_image_wallpaper(self, image_path: str, options: Dict) -> bool:
        monitors = options.get('monitors', 'all')
        if monitors == 'all':
            monitor_list = None
        else:
            monitor_list = [monitors] if isinstance(monitors, str) else monitors
            
        success = self.renderer.start_image(image_path, options, monitor_list)
        
        if success:
            self.current_mode = "static"
            
        return success
        
    def pause(self):
        self.renderer.pause()
        self.paused = True
        logger.info("Wallpaper paused")
        
    def resume(self):
        self.renderer.resume()
        self.paused = False
        logger.info("Wallpaper resumed")
        
    def set_volume(self, level: int):
        self.audio.set_wallpaper_volume(level)
        self.config['audio']['wallpaper_volume'] = level
        self.save_config()
        
    def toggle_mute(self) -> bool:
        muted = self.audio.toggle_mute()
        self.config['audio']['muted'] = muted
        self.save_config()
        return muted
        
    def get_suggestions(self, count: int = 5) -> List[str]:
        if not self.tier_manager.can_use('ai_suggestions'):
            return []
        return self.preference_learner.get_suggestions(count)
        
    def get_status(self) -> Dict:
        return {
            'version': self.VERSION,
            'tier': TIER_LIMIT,
            'current_wallpaper': self.current_wallpaper,
            'mode': self.current_mode,
            'paused': self.paused,
            'renderer': 'mpv' if self.renderer.is_available() else 'fallback',
            'ffmpeg': self.video_processor.ffmpeg_available,
            'xwinwrap': self.renderer.xwinwrap_available,
            'monitors': self.monitor_manager.get_monitor_count(),
            'gaming_mode': self.gaming_monitor.gaming_active,
            'audio': {
                'volume': self.audio.wallpaper_volume,
                'muted': self.audio.muted
            },
            'playlist': {
                'items': len(self.playlist.items),
                'running': self.playlist.running
            }
        }
        
    def list_wallpapers(self) -> List[Dict]:
        return self.library.list_all()
        
    def download_wallpaper(self, wallpaper_id: str) -> Optional[str]:
        return self.update_checker.download_wallpaper(wallpaper_id)
        
    def stop(self):
        self.running = False
        self.gaming_monitor.stop()
        self.playlist.stop()
        self.renderer.stop()
        logger.info("Wallpaper engine stopped")


class WallpaperEngineGUI:
    """Modern GUI for Aegis Wallpaper Engine v3.1"""
    
    def __init__(self, engine: WallpaperEngine):
        self.engine = engine
        self.root = tk.Tk()
        self.root.title(f"Aegis Wallpaper Engine v{VERSION} - SIGMA Gamer Edition")
        self.root.geometry("900x750")
        self.root.configure(bg='#0d1117')
        
        self.setup_styles()
        self.create_widgets()
        
    def setup_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
        
        style.configure('Dark.TFrame', background='#0d1117')
        style.configure('Dark.TLabel', background='#0d1117', foreground='#e6edf3', font=('Segoe UI', 10))
        style.configure('Title.TLabel', background='#0d1117', foreground='#58a6ff', font=('Segoe UI', 16, 'bold'))
        style.configure('Dark.TNotebook', background='#0d1117')
        style.configure('Dark.TNotebook.Tab', background='#21262d', foreground='#e6edf3', padding=[10, 5])
        
    def create_widgets(self):
        main_frame = ttk.Frame(self.root, style='Dark.TFrame', padding=20)
        main_frame.pack(fill='both', expand=True)
        
        header_frame = ttk.Frame(main_frame, style='Dark.TFrame')
        header_frame.pack(fill='x', pady=(0, 20))
        
        title = ttk.Label(header_frame, text="AEGIS WALLPAPER ENGINE", style='Title.TLabel')
        title.pack(side='left')
        
        version = ttk.Label(header_frame, text=f"v{VERSION} SIGMA GAMER",
                           foreground='#8b949e', background='#0d1117')
        version.pack(side='left', padx=10)
        
        tier_label = ttk.Label(header_frame, text=f"[{TIER_LIMIT.upper()}]",
                              foreground='#3fb950', background='#0d1117', font=('Segoe UI', 10, 'bold'))
        tier_label.pack(side='left', padx=5)
        
        mpv_status = "MPV Ready" if self.engine.renderer.is_available() else "MPV Not Found"
        status_color = '#3fb950' if self.engine.renderer.is_available() else '#f85149'
        status = ttk.Label(header_frame, text=f"Renderer: {mpv_status}",
                          foreground=status_color, background='#0d1117')
        status.pack(side='right')
        
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill='both', expand=True)
        
        self.create_wallpaper_tab(notebook)
        self.create_audio_tab(notebook)
        self.create_playlist_tab(notebook)
        self.create_steam_tab(notebook)
        self.create_ai_tab(notebook)
        self.create_settings_tab(notebook)
        
    def create_wallpaper_tab(self, notebook):
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Wallpaper")
        
        preview_frame = tk.Frame(frame, bg='#161b22', width=400, height=225)
        preview_frame.pack(pady=10)
        preview_frame.pack_propagate(False)
        
        self.preview_label = tk.Label(preview_frame, text="No wallpaper selected",
                                      bg='#161b22', fg='#8b949e')
        self.preview_label.pack(expand=True)
        
        btn_frame = ttk.Frame(frame, style='Dark.TFrame')
        btn_frame.pack(fill='x', pady=10)
        
        select_btn = tk.Button(btn_frame, text="Select File", bg='#238636', fg='white',
                              font=('Segoe UI', 10, 'bold'), border=0, padx=20, pady=8,
                              command=self.select_wallpaper)
        select_btn.pack(side='left', padx=5)
        
        apply_btn = tk.Button(btn_frame, text="Apply", bg='#1f6feb', fg='white',
                             font=('Segoe UI', 10, 'bold'), border=0, padx=20, pady=8,
                             command=self.apply_wallpaper)
        apply_btn.pack(side='left', padx=5)
        
        pause_btn = tk.Button(btn_frame, text="Pause/Resume", bg='#a371f7', fg='white',
                             font=('Segoe UI', 10, 'bold'), border=0, padx=20, pady=8,
                             command=self.toggle_pause)
        pause_btn.pack(side='left', padx=5)
        
        stop_btn = tk.Button(btn_frame, text="Stop", bg='#da3633', fg='white',
                            font=('Segoe UI', 10, 'bold'), border=0, padx=20, pady=8,
                            command=self.stop_wallpaper)
        stop_btn.pack(side='left', padx=5)
        
        formats_label = ttk.Label(frame, 
            text="Supported: MP4, AVI, MKV, WebM, MOV, GIF, JPG, PNG, HEVC, VP9, AV1, WebP, HEIC",
            foreground='#8b949e', background='#0d1117', font=('Segoe UI', 9))
        formats_label.pack(pady=5)
        
        current_frame = ttk.Frame(frame, style='Dark.TFrame')
        current_frame.pack(fill='x', pady=10)
        
        current_label = ttk.Label(current_frame, text="Current:", style='Dark.TLabel')
        current_label.pack(side='left')
        
        current_path = self.engine.current_wallpaper or "None"
        if len(current_path) > 50:
            current_path = "..." + current_path[-47:]
        self.current_path_label = ttk.Label(current_frame, text=current_path,
                                           foreground='#58a6ff', background='#0d1117')
        self.current_path_label.pack(side='left', padx=5)
        
        monitor_frame = ttk.Frame(frame, style='Dark.TFrame')
        monitor_frame.pack(fill='x', pady=10)
        
        tk.Label(monitor_frame, text="Monitor:", bg='#0d1117', fg='#e6edf3').pack(side='left')
        
        monitors = ['all'] + [m['name'] for m in self.engine.monitor_manager.monitors]
        self.monitor_var = tk.StringVar(value='all')
        monitor_combo = ttk.Combobox(monitor_frame, textvariable=self.monitor_var,
                                    values=monitors, width=20, state='readonly')
        monitor_combo.pack(side='left', padx=10)
        
        self.selected_path = None
        
    def create_audio_tab(self, notebook):
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Audio")
        
        vol_frame = tk.Frame(frame, bg='#0d1117')
        vol_frame.pack(fill='x', pady=10)
        
        vol_label = tk.Label(vol_frame, text="Wallpaper Volume", bg='#0d1117', fg='#e6edf3',
                            font=('Segoe UI', 11, 'bold'))
        vol_label.pack(anchor='w')
        
        self.volume_var = tk.IntVar(value=self.engine.audio.wallpaper_volume)
        volume_scale = tk.Scale(vol_frame, from_=0, to=100, orient='horizontal',
                               variable=self.volume_var, bg='#161b22', fg='#e6edf3',
                               highlightthickness=0, troughcolor='#21262d',
                               activebackground='#58a6ff', length=400,
                               command=self.on_volume_change)
        volume_scale.pack(fill='x', pady=5)
        
        self.mute_var = tk.BooleanVar(value=self.engine.audio.muted)
        mute_check = tk.Checkbutton(frame, text="Mute Audio", variable=self.mute_var,
                                   bg='#0d1117', fg='#e6edf3', selectcolor='#21262d',
                                   command=self.on_mute_toggle)
        mute_check.pack(anchor='w', pady=5)
        
        self.remove_audio_var = tk.BooleanVar(value=True)
        remove_check = tk.Checkbutton(frame, text="Remove audio from video wallpapers",
                                     variable=self.remove_audio_var, bg='#0d1117', fg='#e6edf3',
                                     selectcolor='#21262d')
        remove_check.pack(anchor='w', pady=5)
        
        self.ducking_var = tk.BooleanVar(value=self.engine.audio.audio_ducking)
        duck_check = tk.Checkbutton(frame, text="Audio ducking (lower volume when other apps play)",
                                   variable=self.ducking_var, bg='#0d1117', fg='#e6edf3',
                                   selectcolor='#21262d')
        duck_check.pack(anchor='w', pady=5)
        
    def create_playlist_tab(self, notebook):
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Playlist")
        
        list_frame = tk.Frame(frame, bg='#161b22')
        list_frame.pack(fill='both', expand=True, pady=10)
        
        self.playlist_listbox = tk.Listbox(list_frame, bg='#161b22', fg='#e6edf3',
                                           selectbackground='#58a6ff', selectforeground='white',
                                           font=('Segoe UI', 10), height=10)
        self.playlist_listbox.pack(fill='both', expand=True, side='left')
        
        scrollbar = tk.Scrollbar(list_frame, command=self.playlist_listbox.yview)
        scrollbar.pack(side='right', fill='y')
        self.playlist_listbox.config(yscrollcommand=scrollbar.set)
        
        self._refresh_playlist()
        
        btn_frame = ttk.Frame(frame, style='Dark.TFrame')
        btn_frame.pack(fill='x', pady=10)
        
        add_btn = tk.Button(btn_frame, text="Add", bg='#238636', fg='white',
                           font=('Segoe UI', 9), border=0, padx=15, pady=5,
                           command=self.playlist_add)
        add_btn.pack(side='left', padx=3)
        
        remove_btn = tk.Button(btn_frame, text="Remove", bg='#da3633', fg='white',
                              font=('Segoe UI', 9), border=0, padx=15, pady=5,
                              command=self.playlist_remove)
        remove_btn.pack(side='left', padx=3)
        
        play_btn = tk.Button(btn_frame, text="Start Rotation", bg='#1f6feb', fg='white',
                            font=('Segoe UI', 9), border=0, padx=15, pady=5,
                            command=self.playlist_start)
        play_btn.pack(side='left', padx=3)
        
        stop_btn = tk.Button(btn_frame, text="Stop Rotation", bg='#a371f7', fg='white',
                            font=('Segoe UI', 9), border=0, padx=15, pady=5,
                            command=self.playlist_stop)
        stop_btn.pack(side='left', padx=3)
        
        settings_frame = ttk.Frame(frame, style='Dark.TFrame')
        settings_frame.pack(fill='x', pady=10)
        
        tk.Label(settings_frame, text="Interval (seconds):", bg='#0d1117', fg='#e6edf3').pack(side='left')
        self.interval_var = tk.IntVar(value=self.engine.playlist.interval)
        interval_spin = tk.Spinbox(settings_frame, from_=10, to=3600, textvariable=self.interval_var,
                                  width=8, bg='#161b22', fg='#e6edf3')
        interval_spin.pack(side='left', padx=5)
        
        self.shuffle_var = tk.BooleanVar(value=self.engine.playlist.shuffle)
        shuffle_check = tk.Checkbutton(settings_frame, text="Shuffle", variable=self.shuffle_var,
                                      bg='#0d1117', fg='#e6edf3', selectcolor='#21262d',
                                      command=self.on_shuffle_toggle)
        shuffle_check.pack(side='left', padx=10)
        
    def create_steam_tab(self, notebook):
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Steam Workshop")
        
        header = tk.Label(frame, text="Steam Workshop Wallpapers", bg='#0d1117', fg='#e6edf3',
                         font=('Segoe UI', 11, 'bold'))
        header.pack(anchor='w', pady=(0, 10))
        
        desc = tk.Label(frame, text="Import wallpapers from Steam Workshop (Wallpaper Engine)",
                       bg='#0d1117', fg='#8b949e', font=('Segoe UI', 9))
        desc.pack(anchor='w', pady=(0, 15))
        
        list_frame = tk.Frame(frame, bg='#161b22')
        list_frame.pack(fill='both', expand=True, pady=10)
        
        self.steam_listbox = tk.Listbox(list_frame, bg='#161b22', fg='#e6edf3',
                                        selectbackground='#58a6ff', selectforeground='white',
                                        font=('Segoe UI', 10), height=8)
        self.steam_listbox.pack(fill='both', expand=True, side='left')
        
        scrollbar = tk.Scrollbar(list_frame, command=self.steam_listbox.yview)
        scrollbar.pack(side='right', fill='y')
        self.steam_listbox.config(yscrollcommand=scrollbar.set)
        
        btn_frame = ttk.Frame(frame, style='Dark.TFrame')
        btn_frame.pack(fill='x', pady=10)
        
        scan_btn = tk.Button(btn_frame, text="Scan Workshop", bg='#238636', fg='white',
                            font=('Segoe UI', 9), border=0, padx=15, pady=5,
                            command=self.scan_steam_workshop)
        scan_btn.pack(side='left', padx=3)
        
        import_btn = tk.Button(btn_frame, text="Import Selected", bg='#1f6feb', fg='white',
                              font=('Segoe UI', 9), border=0, padx=15, pady=5,
                              command=self.import_steam_wallpaper)
        import_btn.pack(side='left', padx=3)
        
        use_btn = tk.Button(btn_frame, text="Use Selected", bg='#a371f7', fg='white',
                           font=('Segoe UI', 9), border=0, padx=15, pady=5,
                           command=self.use_steam_wallpaper)
        use_btn.pack(side='left', padx=3)
        
    def create_ai_tab(self, notebook):
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="AI Suggestions")
        
        header = tk.Label(frame, text="AI Preference Learning", bg='#0d1117', fg='#e6edf3',
                         font=('Segoe UI', 11, 'bold'))
        header.pack(anchor='w', pady=(0, 10))
        
        desc = tk.Label(frame, 
            text="The AI learns your wallpaper preferences based on time of day, categories, and usage patterns.",
            bg='#0d1117', fg='#8b949e', font=('Segoe UI', 9), wraplength=500, justify='left')
        desc.pack(anchor='w', pady=(0, 15))
        
        self.ai_enabled_var = tk.BooleanVar(value=self.engine.config['ai']['suggestions_enabled'])
        ai_check = tk.Checkbutton(frame, text="Enable AI suggestions", variable=self.ai_enabled_var,
                                 bg='#0d1117', fg='#e6edf3', selectcolor='#21262d')
        ai_check.pack(anchor='w', pady=5)
        
        self.learn_var = tk.BooleanVar(value=self.engine.config['ai']['learn_preferences'])
        learn_check = tk.Checkbutton(frame, text="Learn from my preferences", variable=self.learn_var,
                                    bg='#0d1117', fg='#e6edf3', selectcolor='#21262d')
        learn_check.pack(anchor='w', pady=5)
        
        stats_frame = tk.LabelFrame(frame, text="Usage Statistics", bg='#161b22', fg='#e6edf3',
                                   font=('Segoe UI', 10, 'bold'))
        stats_frame.pack(fill='x', pady=15)
        
        stats = self.engine.preference_learner.get_stats()
        stats_text = f"Total wallpapers set: {stats['total_wallpapers_set']}\n"
        stats_text += f"Sessions: {stats['total_sessions']}\n"
        if stats['favorite_categories']:
            top_cats = sorted(stats['favorite_categories'].items(), key=lambda x: x[1], reverse=True)[:3]
            stats_text += f"Favorite categories: {', '.join([c[0] for c in top_cats])}"
            
        stats_label = tk.Label(stats_frame, text=stats_text, bg='#161b22', fg='#8b949e',
                              font=('Segoe UI', 9), justify='left')
        stats_label.pack(anchor='w', padx=10, pady=10)
        
        suggest_frame = tk.LabelFrame(frame, text="Suggestions For You", bg='#161b22', fg='#e6edf3',
                                     font=('Segoe UI', 10, 'bold'))
        suggest_frame.pack(fill='both', expand=True, pady=10)
        
        self.suggestions_frame = suggest_frame
        self._refresh_suggestions()
        
    def create_settings_tab(self, notebook):
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Settings")
        
        perf_label = tk.Label(frame, text="Performance", bg='#0d1117', fg='#e6edf3',
                             font=('Segoe UI', 11, 'bold'))
        perf_label.pack(anchor='w')
        
        self.gaming_var = tk.BooleanVar(value=self.engine.config['performance']['auto_pause_gaming'])
        gaming_check = tk.Checkbutton(frame, text="Auto-pause during gaming (Steam/Lutris/Wine)",
                                     variable=self.gaming_var, bg='#0d1117', fg='#e6edf3',
                                     selectcolor='#21262d')
        gaming_check.pack(anchor='w', pady=3)
        
        fps_frame = tk.Frame(frame, bg='#0d1117')
        fps_frame.pack(fill='x', pady=10)
        
        tk.Label(fps_frame, text="FPS Limit:", bg='#0d1117', fg='#e6edf3').pack(side='left')
        self.fps_var = tk.IntVar(value=30)
        fps_combo = ttk.Combobox(fps_frame, textvariable=self.fps_var, values=[15, 24, 30, 60],
                                width=10, state='readonly')
        fps_combo.pack(side='left', padx=10)
        
        update_label = tk.Label(frame, text="Updates", bg='#0d1117', fg='#e6edf3',
                               font=('Segoe UI', 11, 'bold'))
        update_label.pack(anchor='w', pady=(15, 5))
        
        self.auto_update_var = tk.BooleanVar(value=self.engine.config['updates']['auto_check'])
        update_check = tk.Checkbutton(frame, text="Automatically check for updates weekly",
                                     variable=self.auto_update_var, bg='#0d1117', fg='#e6edf3',
                                     selectcolor='#21262d')
        update_check.pack(anchor='w', pady=3)
        
        check_now_btn = tk.Button(frame, text="Check Now", bg='#21262d', fg='#e6edf3',
                                 font=('Segoe UI', 9), border=0, padx=15, pady=5,
                                 command=self.check_updates)
        check_now_btn.pack(anchor='w', pady=5)
        
        status_frame = tk.Frame(frame, bg='#0d1117')
        status_frame.pack(fill='x', pady=15)
        
        tk.Label(status_frame, text="System Status:", bg='#0d1117', fg='#e6edf3',
                font=('Segoe UI', 11, 'bold')).pack(anchor='w')
        
        status = self.engine.get_status()
        for key, value in [
            ('MPV', 'Available' if status['renderer'] == 'mpv' else 'Not Found'),
            ('FFmpeg', 'Available' if status['ffmpeg'] else 'Not Found'),
            ('xwinwrap', 'Available' if status['xwinwrap'] else 'Not Found'),
            ('Monitors', status['monitors'])
        ]:
            color = '#3fb950' if value in ['Available', 'mpv'] else '#f85149'
            if isinstance(value, int):
                color = '#58a6ff'
            tk.Label(status_frame, text=f"  {key}: {value}", bg='#0d1117', fg=color).pack(anchor='w')
            
    def select_wallpaper(self):
        filetypes = [
            ('Video files', ' '.join(f'*{ext}' for ext in SUPPORTED_VIDEO_FORMATS)),
            ('Image files', ' '.join(f'*{ext}' for ext in SUPPORTED_IMAGE_FORMATS)),
            ('All supported', ' '.join(f'*{ext}' for ext in SUPPORTED_VIDEO_FORMATS + SUPPORTED_IMAGE_FORMATS))
        ]
        
        path = filedialog.askopenfilename(
            title="Select Wallpaper",
            filetypes=filetypes
        )
        
        if path:
            self.selected_path = path
            display_path = path if len(path) < 50 else "..." + path[-47:]
            self.preview_label.config(text=display_path)
            
    def apply_wallpaper(self):
        if not self.selected_path:
            messagebox.showwarning("No Selection", "Please select a wallpaper first")
            return
            
        options = {
            'monitors': self.monitor_var.get(),
            'muted': self.mute_var.get(),
            'remove_audio': self.remove_audio_var.get()
        }
        
        if self.engine.set_wallpaper(self.selected_path, options=options):
            self.current_path_label.config(text=Path(self.selected_path).name)
            messagebox.showinfo("Success", "Wallpaper applied!")
        else:
            messagebox.showerror("Error", "Failed to apply wallpaper")
            
    def toggle_pause(self):
        if self.engine.paused:
            self.engine.resume()
        else:
            self.engine.pause()
            
    def stop_wallpaper(self):
        self.engine.renderer.stop()
        self.current_path_label.config(text="None")
        
    def on_volume_change(self, value):
        self.engine.set_volume(int(float(value)))
        
    def on_mute_toggle(self):
        self.engine.audio.muted = self.mute_var.get()
        self.engine.audio._apply_volume()
        
    def on_shuffle_toggle(self):
        self.engine.playlist.set_shuffle(self.shuffle_var.get())
        
    def _refresh_playlist(self):
        self.playlist_listbox.delete(0, tk.END)
        for item in self.engine.playlist.items:
            self.playlist_listbox.insert(tk.END, Path(item).name)
            
    def playlist_add(self):
        path = filedialog.askopenfilename(
            title="Add to Playlist",
            filetypes=[('All supported', ' '.join(f'*{ext}' for ext in SUPPORTED_VIDEO_FORMATS + SUPPORTED_IMAGE_FORMATS))]
        )
        if path:
            self.engine.playlist.add(path)
            self._refresh_playlist()
            
    def playlist_remove(self):
        selection = self.playlist_listbox.curselection()
        if selection:
            idx = selection[0]
            if idx < len(self.engine.playlist.items):
                self.engine.playlist.remove(self.engine.playlist.items[idx])
                self._refresh_playlist()
                
    def playlist_start(self):
        self.engine.playlist.set_interval(self.interval_var.get())
        self.engine.playlist.start()
        messagebox.showinfo("Playlist", "Rotation started!")
        
    def playlist_stop(self):
        self.engine.playlist.stop()
        
    def scan_steam_workshop(self):
        self.steam_listbox.delete(0, tk.END)
        wallpapers = self.engine.steam_importer.scan_workshop()
        for wp in wallpapers:
            self.steam_listbox.insert(tk.END, f"{wp['title']} ({wp['type']})")
        if not wallpapers:
            self.steam_listbox.insert(tk.END, "No Steam Workshop wallpapers found")
            
    def import_steam_wallpaper(self):
        selection = self.steam_listbox.curselection()
        if selection:
            wallpapers = self.engine.steam_importer.scan_workshop()
            if selection[0] < len(wallpapers):
                wp = wallpapers[selection[0]]
                result = self.engine.steam_importer.import_wallpaper(wp['id'])
                if result:
                    messagebox.showinfo("Import", f"Imported: {wp['title']}")
                else:
                    messagebox.showerror("Error", "Failed to import wallpaper")
                    
    def use_steam_wallpaper(self):
        selection = self.steam_listbox.curselection()
        if selection:
            wallpapers = self.engine.steam_importer.scan_workshop()
            if selection[0] < len(wallpapers):
                wp = wallpapers[selection[0]]
                file_path = Path(wp['path']) / wp['file']
                if file_path.exists():
                    self.engine.set_wallpaper(str(file_path))
                    messagebox.showinfo("Success", "Wallpaper applied!")
                    
    def _refresh_suggestions(self):
        for widget in self.suggestions_frame.winfo_children():
            widget.destroy()
            
        suggestions = self.engine.get_suggestions(5)
        
        if suggestions:
            for path in suggestions:
                btn = tk.Button(self.suggestions_frame, text=f" {Path(path).name}",
                               bg='#21262d', fg='#e6edf3', anchor='w',
                               border=0, padx=10, pady=5,
                               command=lambda p=path: self.apply_suggestion(p))
                btn.pack(fill='x', padx=5, pady=2)
        else:
            lbl = tk.Label(self.suggestions_frame, text="Set more wallpapers to get personalized suggestions!",
                          bg='#161b22', fg='#8b949e', font=('Segoe UI', 9))
            lbl.pack(anchor='w', padx=10, pady=10)
            
    def apply_suggestion(self, path):
        if self.engine.set_wallpaper(path):
            self.current_path_label.config(text=Path(path).name)
            
    def check_updates(self):
        result = self.engine.update_checker.check_updates()
        if result.get('update_available'):
            messagebox.showinfo("Update Available",
                              f"New version {result.get('latest_version')} is available!")
        elif result.get('error'):
            messagebox.showwarning("Update Check", f"Failed to check: {result.get('error')}")
        else:
            messagebox.showinfo("Up to Date", "You have the latest version!")
            
    def run(self):
        self.root.mainloop()


def main():
    parser = argparse.ArgumentParser(
        description=f'Aegis Wallpaper Engine v{VERSION} - SIGMA Gamer Edition',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  aegis-wallpaper-engine --gui                    Launch GUI
  aegis-wallpaper-engine --set /path/to/video.mp4 Set video wallpaper
  aegis-wallpaper-engine --set /path/to/image.jpg Set image wallpaper
  aegis-wallpaper-engine --pause                  Pause current wallpaper
  aegis-wallpaper-engine --resume                 Resume paused wallpaper
  aegis-wallpaper-engine --list                   List installed wallpapers
  aegis-wallpaper-engine --download ID            Download wallpaper from server
  aegis-wallpaper-engine --status                 Show current status
        '''
    )
    
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--set', metavar='PATH', help='Set wallpaper from file')
    parser.add_argument('--pause', action='store_true', help='Pause current wallpaper')
    parser.add_argument('--resume', action='store_true', help='Resume paused wallpaper')
    parser.add_argument('--stop', action='store_true', help='Stop wallpaper engine')
    parser.add_argument('--list', action='store_true', help='List installed wallpapers')
    parser.add_argument('--download', metavar='ID', help='Download wallpaper from Aegis servers')
    parser.add_argument('--status', action='store_true', help='Show current status')
    parser.add_argument('--volume', type=int, metavar='LEVEL', help='Set volume (0-100)')
    parser.add_argument('--mute', action='store_true', help='Mute audio')
    parser.add_argument('--unmute', action='store_true', help='Unmute audio')
    parser.add_argument('--monitor', default='all', help='Target monitor (default: all)')
    parser.add_argument('--loop', action='store_true', default=True, help='Loop video (default)')
    parser.add_argument('--no-loop', action='store_true', help='Do not loop video')
    parser.add_argument('--effect', choices=['none', 'ken-burns', 'parallax', 'pulse', 'rain'],
                       default='none', help='Image animation effect')
    parser.add_argument('--playlist-start', action='store_true', help='Start playlist rotation')
    parser.add_argument('--playlist-stop', action='store_true', help='Stop playlist rotation')
    parser.add_argument('--playlist-next', action='store_true', help='Next wallpaper in playlist')
    parser.add_argument('--playlist-prev', action='store_true', help='Previous wallpaper in playlist')
    parser.add_argument('--steam-scan', action='store_true', help='Scan Steam Workshop for wallpapers')
    parser.add_argument('--steam-import', metavar='ID', help='Import Steam Workshop wallpaper')
    parser.add_argument('--suggestions', action='store_true', help='Get AI wallpaper suggestions')
    parser.add_argument('--check-updates', action='store_true', help='Check for updates')
    parser.add_argument('--version', action='store_true', help='Show version info')
    parser.add_argument('--daemon', action='store_true', help='Run as background daemon')
    
    args = parser.parse_args()
    
    if args.version:
        print(f"Aegis Wallpaper Engine v{VERSION}")
        print(f"Tier: {TIER_LIMIT}")
        print(f"Supported video formats: {', '.join(SUPPORTED_VIDEO_FORMATS)}")
        print(f"Supported image formats: {', '.join(SUPPORTED_IMAGE_FORMATS)}")
        return 0
        
    engine = WallpaperEngine()
    
    if args.gui or len(sys.argv) == 1:
        if not TK_AVAILABLE:
            print("Error: tkinter not available. Install with: sudo apt install python3-tk")
            return 1
        gui = WallpaperEngineGUI(engine)
        gui.run()
        return 0
        
    if args.set:
        options = {
            'monitors': args.monitor,
            'loop': not args.no_loop,
            'effect': args.effect
        }
        if engine.set_wallpaper(args.set, options=options):
            print(f" Wallpaper set: {args.set}")
        else:
            print(f" Failed to set wallpaper: {args.set}")
            return 1
            
    elif args.pause:
        engine.pause()
        print(" Wallpaper paused")
        
    elif args.resume:
        engine.resume()
        print(" Wallpaper resumed")
        
    elif args.stop:
        engine.stop()
        print(" Wallpaper engine stopped")
        
    elif args.list:
        wallpapers = engine.list_wallpapers()
        print(f"Found {len(wallpapers)} wallpapers:\n")
        for wp in wallpapers[:50]:
            print(f"  [{wp['type']:5}] {wp['name']}")
            print(f"         {wp['path']}")
        if len(wallpapers) > 50:
            print(f"\n  ... and {len(wallpapers) - 50} more")
            
    elif args.download:
        result = engine.download_wallpaper(args.download)
        if result:
            print(f" Downloaded: {result}")
        else:
            print(f" Failed to download wallpaper {args.download}")
            return 1
            
    elif args.status:
        status = engine.get_status()
        print(f"\nAegis Wallpaper Engine v{status['version']}")
        print(f"{'=' * 40}")
        print(f"Tier:            {status['tier']}")
        print(f"Current:         {status['current_wallpaper'] or 'None'}")
        print(f"Mode:            {status['mode']}")
        print(f"Paused:          {status['paused']}")
        print(f"Renderer:        {status['renderer']}")
        print(f"FFmpeg:          {'Available' if status['ffmpeg'] else 'Not Found'}")
        print(f"xwinwrap:        {'Available' if status['xwinwrap'] else 'Not Found'}")
        print(f"Monitors:        {status['monitors']}")
        print(f"Gaming Mode:     {status['gaming_mode']}")
        print(f"Audio Volume:    {status['audio']['volume']}%")
        print(f"Audio Muted:     {status['audio']['muted']}")
        print(f"Playlist Items:  {status['playlist']['items']}")
        print(f"Playlist Active: {status['playlist']['running']}")
        
    elif args.volume is not None:
        engine.set_volume(args.volume)
        print(f" Volume set to {args.volume}%")
        
    elif args.mute:
        engine.audio.muted = True
        engine.audio._apply_volume()
        print(" Audio muted")
        
    elif args.unmute:
        engine.audio.muted = False
        engine.audio._apply_volume()
        print(" Audio unmuted")
        
    elif args.playlist_start:
        engine.playlist.start()
        print(" Playlist rotation started")
        
    elif args.playlist_stop:
        engine.playlist.stop()
        print(" Playlist rotation stopped")
        
    elif args.playlist_next:
        engine.playlist.next()
        print(" Next wallpaper")
        
    elif args.playlist_prev:
        engine.playlist.previous()
        print(" Previous wallpaper")
        
    elif args.steam_scan:
        wallpapers = engine.steam_importer.scan_workshop()
        print(f"Found {len(wallpapers)} Steam Workshop wallpapers:\n")
        for wp in wallpapers:
            print(f"  [{wp['id']}] {wp['title']} ({wp['type']})")
            
    elif args.steam_import:
        result = engine.steam_importer.import_wallpaper(args.steam_import)
        if result:
            print(f" Imported: {result}")
        else:
            print(f" Failed to import {args.steam_import}")
            return 1
            
    elif args.suggestions:
        suggestions = engine.get_suggestions(5)
        if suggestions:
            print("AI Suggestions based on your preferences:\n")
            for i, path in enumerate(suggestions, 1):
                print(f"  {i}. {Path(path).name}")
                print(f"     {path}")
        else:
            print("No suggestions yet. Set more wallpapers to train the AI!")
            
    elif args.check_updates:
        print("Checking for updates...")
        result = engine.update_checker.check_updates()
        if result.get('error'):
            print(f" Update check failed: {result['error']}")
        elif result.get('update_available'):
            print(f" Update available: v{result['latest_version']}")
            print(f"  Changelog: {result.get('changelog', 'No changelog')}")
        else:
            print(" You have the latest version")
            
    elif args.daemon:
        print(f"Aegis Wallpaper Engine v{VERSION} running as daemon...")
        try:
            while engine.running:
                time.sleep(1)
        except KeyboardInterrupt:
            engine.stop()
            print("\nDaemon stopped")
            
    else:
        parser.print_help()
        
    return 0


if __name__ == "__main__":
    sys.exit(main())
