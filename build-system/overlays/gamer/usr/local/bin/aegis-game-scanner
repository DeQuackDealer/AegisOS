#!/usr/bin/env python3
"""
Aegis Game Scanner - Detect installed games from Steam, Lutris, Heroic, and native sources
"""

import sys

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, GLib, GdkPixbuf
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False
    print("Error: GTK3 is required for the graphical interface.", file=sys.stderr)
    print("Install with: sudo pacman -S gtk3 python-gobject", file=sys.stderr)

import os
import subprocess
import json
import re
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass

try:
    import vdf
    HAS_VDF = True
except ImportError:
    HAS_VDF = False

try:
    import sqlite3
    HAS_SQLITE = True
except ImportError:
    HAS_SQLITE = False

@dataclass
class Game:
    name: str
    source: str
    app_id: str
    install_path: str
    executable: str = ""
    size_mb: int = 0
    icon_path: str = ""
    proton_version: str = ""
    last_played: str = ""

class SteamLibrary:
    @staticmethod
    def find_libraries() -> List[Path]:
        libraries = []
        steam_path = Path.home() / ".steam/steam"
        
        if not steam_path.exists():
            steam_path = Path.home() / ".local/share/Steam"
        
        if steam_path.exists():
            libraries.append(steam_path / "steamapps")
            
            libraryfolders = steam_path / "steamapps/libraryfolders.vdf"
            if libraryfolders.exists():
                try:
                    with open(libraryfolders) as f:
                        if HAS_VDF:
                            data = vdf.load(f)
                        else:
                            content = f.read()
                            data = {"libraryfolders": {}}
                            pattern = r'"path"\s+"([^"]+)"'
                            for i, match in enumerate(re.finditer(pattern, content)):
                                data["libraryfolders"][str(i)] = {"path": match.group(1)}
                        
                        for key, value in data.get("libraryfolders", {}).items():
                            if isinstance(value, dict) and "path" in value:
                                lib_path = Path(value["path"]) / "steamapps"
                                if lib_path.exists() and lib_path not in libraries:
                                    libraries.append(lib_path)
                except:
                    pass
        
        return libraries
    
    @staticmethod
    def scan_games() -> List[Game]:
        games = []
        
        for library in SteamLibrary.find_libraries():
            for acf in library.glob("appmanifest_*.acf"):
                try:
                    with open(acf) as f:
                        content = f.read()
                    
                    app_id_match = re.search(r'"appid"\s+"(\d+)"', content)
                    name_match = re.search(r'"name"\s+"([^"]+)"', content)
                    installdir_match = re.search(r'"installdir"\s+"([^"]+)"', content)
                    size_match = re.search(r'"SizeOnDisk"\s+"(\d+)"', content)
                    
                    if app_id_match and name_match and installdir_match:
                        app_id = app_id_match.group(1)
                        name = name_match.group(1)
                        installdir = installdir_match.group(1)
                        size = int(size_match.group(1)) // (1024 * 1024) if size_match else 0
                        
                        install_path = library / "common" / installdir
                        
                        proton = ""
                        compat_data = library / "compatdata" / app_id
                        if compat_data.exists():
                            proton = "Proton"
                        
                        games.append(Game(
                            name=name,
                            source="Steam",
                            app_id=app_id,
                            install_path=str(install_path),
                            size_mb=size,
                            proton_version=proton
                        ))
                except Exception as e:
                    pass
        
        return games

class LutrisLibrary:
    @staticmethod
    def scan_games() -> List[Game]:
        games = []
        
        if not HAS_SQLITE:
            return games
        
        db_path = Path.home() / ".local/share/lutris/pga.db"
        if db_path.exists():
            try:
                conn = sqlite3.connect(str(db_path))
                cursor = conn.execute("SELECT slug, name, directory, runner FROM games WHERE installed = 1")
                for row in cursor:
                    slug, name, directory, runner = row
                    games.append(Game(
                        name=name or slug,
                        source="Lutris",
                        app_id=slug,
                        install_path=directory or "",
                        proton_version=runner or ""
                    ))
                conn.close()
            except Exception:
                pass
        
        return games

class HeroicLibrary:
    @staticmethod
    def scan_games() -> List[Game]:
        games = []
        
        for store in ["legendary", "gog"]:
            config_path = Path.home() / f".config/heroic/{store}GamesConfig"
            installed_path = Path.home() / f".config/heroic/{store}Installed.json"
            
            if installed_path.exists():
                try:
                    with open(installed_path) as f:
                        data = json.load(f)
                    
                    for app_id, info in data.get("installed", {}).items():
                        if isinstance(info, dict):
                            games.append(Game(
                                name=info.get("title", app_id),
                                source="Heroic (Epic)" if store == "legendary" else "Heroic (GOG)",
                                app_id=app_id,
                                install_path=info.get("install_path", ""),
                                executable=info.get("executable", ""),
                                size_mb=info.get("install_size", 0) // (1024 * 1024)
                            ))
                except Exception as e:
                    pass
        
        return games

class NativeGames:
    COMMON_PATHS = [
        "/usr/games",
        "/usr/local/games",
        Path.home() / "Games",
        Path.home() / ".local/share/applications"
    ]
    
    KNOWN_GAMES = {
        "supertuxkart": "SuperTuxKart",
        "0ad": "0 A.D.",
        "openarena": "OpenArena",
        "xonotic": "Xonotic",
        "minetest": "Minetest",
        "hedgewars": "Hedgewars",
        "warzone2100": "Warzone 2100",
        "wesnoth": "Battle for Wesnoth",
        "freeciv": "FreeCiv",
    }
    
    @staticmethod
    def scan_games() -> List[Game]:
        games = []
        
        for game_cmd, game_name in NativeGames.KNOWN_GAMES.items():
            try:
                result = subprocess.run(["which", game_cmd], capture_output=True)
                if result.returncode == 0:
                    games.append(Game(
                        name=game_name,
                        source="Native",
                        app_id=game_cmd,
                        install_path=result.stdout.decode().strip(),
                        executable=game_cmd
                    ))
            except:
                pass
        
        desktop_path = Path.home() / ".local/share/applications"
        if desktop_path.exists():
            for desktop_file in desktop_path.glob("*.desktop"):
                try:
                    content = desktop_file.read_text()
                    if "Categories" in content and ("Game" in content or "game" in content.lower()):
                        name_match = re.search(r'^Name=(.+)$', content, re.MULTILINE)
                        exec_match = re.search(r'^Exec=(.+)$', content, re.MULTILINE)
                        if name_match and exec_match:
                            name = name_match.group(1)
                            if not any(g.name == name for g in games):
                                games.append(Game(
                                    name=name,
                                    source="Native",
                                    app_id=desktop_file.stem,
                                    install_path=str(desktop_file),
                                    executable=exec_match.group(1).split()[0]
                                ))
                except:
                    pass
        
        return games

class AegisGameScanner(Gtk.Window):
    CSS = """
    window { background: #1a1a2e; }
    .header { background: rgba(0,0,0,0.6); padding: 20px; }
    .title { color: #00b4d8; font-size: 28px; font-weight: bold; }
    .card { background: rgba(255,255,255,0.08); border-radius: 12px; padding: 16px; margin: 8px; }
    .card-title { color: #fff; font-size: 18px; font-weight: bold; }
    .info-label { color: #888; font-size: 13px; }
    .game-row { background: rgba(255,255,255,0.05); border-radius: 8px; padding: 12px; margin: 4px 0; }
    .game-name { color: #fff; font-size: 14px; font-weight: bold; }
    .game-info { color: #888; font-size: 12px; }
    .source-steam { color: #1b2838; background: #66c0f4; padding: 2px 8px; border-radius: 4px; font-size: 11px; }
    .source-lutris { color: #fff; background: #ff9800; padding: 2px 8px; border-radius: 4px; font-size: 11px; }
    .source-heroic { color: #fff; background: #7b1fa2; padding: 2px 8px; border-radius: 4px; font-size: 11px; }
    .source-native { color: #fff; background: #4caf50; padding: 2px 8px; border-radius: 4px; font-size: 11px; }
    .scan-btn { background: #00b4d8; color: #fff; font-weight: bold; padding: 12px 32px; border-radius: 8px; }
    .export-btn { background: rgba(255,255,255,0.1); color: #fff; padding: 8px 20px; border-radius: 8px; }
    .stat-box { background: rgba(0,180,216,0.2); border-radius: 8px; padding: 16px; text-align: center; }
    .stat-value { color: #00b4d8; font-size: 32px; font-weight: bold; }
    .stat-label { color: #aaa; font-size: 12px; }
    """
    
    def __init__(self):
        super().__init__(title="Aegis Game Scanner")
        self.set_default_size(1000, 800)
        
        self.games: List[Game] = []
        self.scanning = False
        
        css = Gtk.CssProvider()
        css.load_from_data(self.CSS.encode())
        Gtk.StyleContext.add_provider_for_screen(self.get_screen(), css, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
        
        self._create_ui()
        GLib.idle_add(self._scan_games)
    
    def _create_ui(self):
        main = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.add(main)
        
        header = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        header.get_style_context().add_class("header")
        
        title_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        title = Gtk.Label(label="Aegis Game Scanner")
        title.get_style_context().add_class("title")
        title.set_halign(Gtk.Align.START)
        title_box.pack_start(title, False, False, 0)
        
        self.subtitle = Gtk.Label(label="Scanning for installed games...")
        self.subtitle.get_style_context().add_class("info-label")
        self.subtitle.set_halign(Gtk.Align.START)
        title_box.pack_start(self.subtitle, False, False, 4)
        
        header.pack_start(title_box, True, True, 0)
        
        btn_box = Gtk.Box(spacing=8)
        
        self.scan_btn = Gtk.Button(label="Rescan")
        self.scan_btn.get_style_context().add_class("scan-btn")
        self.scan_btn.connect("clicked", self._scan_games)
        btn_box.pack_start(self.scan_btn, False, False, 0)
        
        export_btn = Gtk.Button(label="Export List")
        export_btn.get_style_context().add_class("export-btn")
        export_btn.connect("clicked", self._export_games)
        btn_box.pack_start(export_btn, False, False, 0)
        
        header.pack_end(btn_box, False, False, 0)
        main.pack_start(header, False, False, 0)
        
        stats_box = Gtk.Box(spacing=16)
        stats_box.set_margin_start(20); stats_box.set_margin_end(20)
        stats_box.set_margin_top(16)
        
        self.stat_labels = {}
        for stat_id, stat_name in [("total", "Total Games"), ("steam", "Steam"), 
                                    ("lutris", "Lutris"), ("heroic", "Heroic"), ("native", "Native")]:
            stat = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
            stat.get_style_context().add_class("stat-box")
            stat.set_size_request(120, 80)
            
            val = Gtk.Label(label="0")
            val.get_style_context().add_class("stat-value")
            stat.pack_start(val, True, True, 0)
            self.stat_labels[stat_id] = val
            
            name = Gtk.Label(label=stat_name)
            name.get_style_context().add_class("stat-label")
            stat.pack_start(name, False, False, 0)
            
            stats_box.pack_start(stat, True, True, 0)
        
        main.pack_start(stats_box, False, False, 0)
        
        filter_box = Gtk.Box(spacing=12)
        filter_box.set_margin_start(20); filter_box.set_margin_end(20)
        filter_box.set_margin_top(16)
        
        search_entry = Gtk.SearchEntry()
        search_entry.set_placeholder_text("Search games...")
        search_entry.connect("search-changed", self._filter_games)
        self.search_entry = search_entry
        filter_box.pack_start(search_entry, True, True, 0)
        
        self.source_filter = Gtk.ComboBoxText()
        self.source_filter.append_text("All Sources")
        self.source_filter.append_text("Steam")
        self.source_filter.append_text("Lutris")
        self.source_filter.append_text("Heroic")
        self.source_filter.append_text("Native")
        self.source_filter.set_active(0)
        self.source_filter.connect("changed", self._filter_games)
        filter_box.pack_start(self.source_filter, False, False, 0)
        
        main.pack_start(filter_box, False, False, 0)
        
        scroll = Gtk.ScrolledWindow()
        scroll.set_margin_start(20); scroll.set_margin_end(20)
        scroll.set_margin_top(8); scroll.set_margin_bottom(20)
        main.pack_start(scroll, True, True, 0)
        
        self.games_list = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        scroll.add(self.games_list)
    
    def _scan_games(self, btn=None):
        if self.scanning:
            return
        
        self.scanning = True
        self.scan_btn.set_sensitive(False)
        self.subtitle.set_text("Scanning for installed games...")
        
        for child in self.games_list.get_children():
            self.games_list.remove(child)
        
        spinner = Gtk.Spinner()
        spinner.start()
        self.games_list.pack_start(spinner, True, True, 50)
        self.games_list.show_all()
        
        def do_scan():
            games = []
            
            try:
                games.extend(SteamLibrary.scan_games())
            except Exception as e:
                print(f"Steam scan error: {e}")
            
            try:
                games.extend(LutrisLibrary.scan_games())
            except Exception as e:
                print(f"Lutris scan error: {e}")
            
            try:
                games.extend(HeroicLibrary.scan_games())
            except Exception as e:
                print(f"Heroic scan error: {e}")
            
            try:
                games.extend(NativeGames.scan_games())
            except Exception as e:
                print(f"Native scan error: {e}")
            
            GLib.idle_add(self._scan_complete, games)
        
        import threading
        threading.Thread(target=do_scan, daemon=True).start()
    
    def _scan_complete(self, games: List[Game]):
        self.games = games
        self.scanning = False
        self.scan_btn.set_sensitive(True)
        
        for child in self.games_list.get_children():
            self.games_list.remove(child)
        
        steam_count = sum(1 for g in games if g.source == "Steam")
        lutris_count = sum(1 for g in games if g.source == "Lutris")
        heroic_count = sum(1 for g in games if "Heroic" in g.source)
        native_count = sum(1 for g in games if g.source == "Native")
        
        self.stat_labels["total"].set_text(str(len(games)))
        self.stat_labels["steam"].set_text(str(steam_count))
        self.stat_labels["lutris"].set_text(str(lutris_count))
        self.stat_labels["heroic"].set_text(str(heroic_count))
        self.stat_labels["native"].set_text(str(native_count))
        
        self.subtitle.set_text(f"Found {len(games)} games")
        
        self._display_games(games)
    
    def _display_games(self, games: List[Game]):
        for child in self.games_list.get_children():
            self.games_list.remove(child)
        
        for game in sorted(games, key=lambda g: g.name.lower()):
            row = Gtk.Box(spacing=12)
            row.get_style_context().add_class("game-row")
            
            info_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
            
            header = Gtk.Box(spacing=8)
            name = Gtk.Label(label=game.name)
            name.get_style_context().add_class("game-name")
            name.set_halign(Gtk.Align.START)
            name.set_ellipsize(True)
            header.pack_start(name, False, False, 0)
            
            source_class = f"source-{game.source.lower().split()[0]}"
            source = Gtk.Label(label=game.source)
            source.get_style_context().add_class(source_class)
            header.pack_start(source, False, False, 0)
            
            info_box.pack_start(header, False, False, 0)
            
            details = []
            if game.size_mb > 0:
                if game.size_mb > 1024:
                    details.append(f"{game.size_mb / 1024:.1f} GB")
                else:
                    details.append(f"{game.size_mb} MB")
            if game.proton_version:
                details.append(game.proton_version)
            
            if details:
                info = Gtk.Label(label=" â€¢ ".join(details))
                info.get_style_context().add_class("game-info")
                info.set_halign(Gtk.Align.START)
                info_box.pack_start(info, False, False, 0)
            
            row.pack_start(info_box, True, True, 0)
            
            launch_btn = Gtk.Button(label="Launch")
            launch_btn.connect("clicked", self._launch_game, game)
            row.pack_end(launch_btn, False, False, 0)
            
            folder_btn = Gtk.Button(label="Open Folder")
            folder_btn.connect("clicked", self._open_folder, game)
            row.pack_end(folder_btn, False, False, 0)
            
            self.games_list.pack_start(row, False, False, 0)
        
        self.games_list.show_all()
    
    def _filter_games(self, widget):
        search = self.search_entry.get_text().lower()
        source_filter = self.source_filter.get_active_text()
        
        filtered = self.games
        
        if search:
            filtered = [g for g in filtered if search in g.name.lower()]
        
        if source_filter and source_filter != "All Sources":
            filtered = [g for g in filtered if source_filter.lower() in g.source.lower()]
        
        self._display_games(filtered)
    
    def _launch_game(self, btn, game: Game):
        try:
            if game.source == "Steam":
                subprocess.Popen(["steam", f"steam://run/{game.app_id}"], start_new_session=True)
            elif game.source == "Lutris":
                subprocess.Popen(["lutris", f"lutris:rungame/{game.app_id}"], start_new_session=True)
            elif "Heroic" in game.source:
                subprocess.Popen(["heroic", game.app_id], start_new_session=True)
            elif game.executable:
                subprocess.Popen([game.executable], start_new_session=True)
        except Exception as e:
            dialog = Gtk.MessageDialog(transient_for=self, message_type=Gtk.MessageType.ERROR,
                                       buttons=Gtk.ButtonsType.OK, text="Launch Failed")
            dialog.format_secondary_text(str(e))
            dialog.run(); dialog.destroy()
    
    def _open_folder(self, btn, game: Game):
        path = game.install_path
        if path and Path(path).exists():
            subprocess.Popen(["xdg-open", path], start_new_session=True)
        else:
            dialog = Gtk.MessageDialog(transient_for=self, message_type=Gtk.MessageType.WARNING,
                                       buttons=Gtk.ButtonsType.OK, text="Folder Not Found")
            dialog.format_secondary_text(f"Install path not available:\n{path}")
            dialog.run(); dialog.destroy()
    
    def _export_games(self, btn):
        export_data = []
        for game in self.games:
            export_data.append({
                "name": game.name,
                "source": game.source,
                "app_id": game.app_id,
                "install_path": game.install_path,
                "size_mb": game.size_mb,
                "proton": game.proton_version
            })
        
        export_path = Path.home() / ".config/aegis/games-library.json"
        export_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(export_path, "w") as f:
            json.dump(export_data, f, indent=2)
        
        dialog = Gtk.MessageDialog(transient_for=self, message_type=Gtk.MessageType.INFO,
                                   buttons=Gtk.ButtonsType.OK, text="Games Exported")
        dialog.format_secondary_text(f"Game library exported to:\n{export_path}\n\n{len(self.games)} games saved.")
        dialog.run(); dialog.destroy()


def main():
    if not GTK_AVAILABLE:
        print("Cannot start Aegis Game Scanner: GTK3 not available.", file=sys.stderr)
        sys.exit(1)
    win = AegisGameScanner()
    win.connect("destroy", Gtk.main_quit)
    win.show_all()
    Gtk.main()

if __name__ == "__main__":
    main()
