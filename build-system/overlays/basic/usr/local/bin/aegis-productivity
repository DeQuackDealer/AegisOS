#!/usr/bin/env python3
"""
Aegis Productivity - Productivity enhancement tools for Basic edition
Features: Clipboard manager, window tiling, quick launcher

Provides GUI (tkinter) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import threading
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any
from collections import deque

TIER_LIMIT = "basic"
VERSION = "1.5.0"
APP_NAME = "Aegis Productivity"

CONFIG_FILE = "/etc/aegis/basic-config.json"
LOG_FILE = "/var/log/aegis/productivity.log"
DATA_DIR = "/var/lib/aegis/productivity"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, Gdk, GLib
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False
    print("Error: GTK3 is required. Install with: sudo pacman -S gtk3 python-gobject", file=sys.stderr)


class LicenseTier:
    FREEMIUM = 1
    BASIC = 2
    GAMER = 3
    GAMER_AI = 4
    SERVER = 5


TILING_LAYOUTS = {
    "left_half": {"x": 0, "y": 0, "width": 0.5, "height": 1.0, "shortcut": "Super+Left"},
    "right_half": {"x": 0.5, "y": 0, "width": 0.5, "height": 1.0, "shortcut": "Super+Right"},
    "top_half": {"x": 0, "y": 0, "width": 1.0, "height": 0.5, "shortcut": "Super+Up"},
    "bottom_half": {"x": 0, "y": 0.5, "width": 1.0, "height": 0.5, "shortcut": "Super+Down"},
    "top_left": {"x": 0, "y": 0, "width": 0.5, "height": 0.5, "shortcut": "Super+U"},
    "top_right": {"x": 0.5, "y": 0, "width": 0.5, "height": 0.5, "shortcut": "Super+I"},
    "bottom_left": {"x": 0, "y": 0.5, "width": 0.5, "height": 0.5, "shortcut": "Super+J"},
    "bottom_right": {"x": 0.5, "y": 0.5, "width": 0.5, "height": 0.5, "shortcut": "Super+K"},
    "center": {"x": 0.15, "y": 0.15, "width": 0.7, "height": 0.7, "shortcut": "Super+C"},
    "maximize": {"x": 0, "y": 0, "width": 1.0, "height": 1.0, "shortcut": "Super+M"}
}

QUICK_LAUNCHER_APPS = [
    {"name": "Files", "command": "thunar", "icon": "system-file-manager"},
    {"name": "Terminal", "command": "xfce4-terminal", "icon": "utilities-terminal"},
    {"name": "Browser", "command": "firefox", "icon": "web-browser"},
    {"name": "Text Editor", "command": "mousepad", "icon": "accessories-text-editor"},
    {"name": "Calculator", "command": "galculator", "icon": "accessories-calculator"},
    {"name": "Settings", "command": "xfce4-settings-manager", "icon": "preferences-system"},
    {"name": "System Monitor", "command": "aegis-system-monitor", "icon": "utilities-system-monitor"},
    {"name": "App Store", "command": "aegis-app-store", "icon": "system-software-install"}
]


class ClipboardManager:
    def __init__(self, max_history: int = 100):
        self.max_history = max_history
        self.history = deque(maxlen=max_history)
        self.history_file = Path.home() / ".config" / "aegis" / "clipboard_history.json"
        self.running = False
        self.monitor_thread = None
        
        self.load_history()
    
    def load_history(self):
        try:
            if self.history_file.exists():
                with open(self.history_file, 'r') as f:
                    data = json.load(f)
                    for item in data.get("history", []):
                        self.history.append(item)
        except Exception:
            pass
    
    def save_history(self):
        try:
            self.history_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.history_file, 'w') as f:
                json.dump({"history": list(self.history)}, f)
        except Exception:
            pass
    
    def add_entry(self, content: str, content_type: str = "text"):
        entry = {
            "content": content[:1000],
            "type": content_type,
            "timestamp": datetime.now().isoformat()
        }
        
        if self.history and self.history[-1]["content"] == content:
            return
        
        self.history.append(entry)
        self.save_history()
    
    def get_history(self) -> List[Dict[str, Any]]:
        return list(self.history)
    
    def clear_history(self):
        self.history.clear()
        self.save_history()
    
    def get_current_clipboard(self) -> Optional[str]:
        try:
            result = subprocess.run(["xclip", "-selection", "clipboard", "-o"],
                                   capture_output=True, text=True, timeout=1)
            if result.returncode == 0:
                return result.stdout
        except Exception:
            pass
        return None
    
    def set_clipboard(self, content: str) -> bool:
        try:
            process = subprocess.Popen(["xclip", "-selection", "clipboard"],
                                       stdin=subprocess.PIPE)
            process.communicate(input=content.encode())
            return process.returncode == 0
        except Exception:
            return False
    
    def start_monitoring(self):
        if self.running:
            return
        
        self.running = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
    
    def stop_monitoring(self):
        self.running = False
    
    def _monitor_loop(self):
        last_content = None
        while self.running:
            try:
                current = self.get_current_clipboard()
                if current and current != last_content:
                    self.add_entry(current)
                    last_content = current
            except Exception:
                pass
            time.sleep(0.5)


class WindowTiler:
    def __init__(self):
        self.layouts = TILING_LAYOUTS
    
    def get_screen_geometry(self) -> Dict[str, int]:
        try:
            result = subprocess.run(["xdpyinfo"], capture_output=True, text=True)
            for line in result.stdout.split('\n'):
                if "dimensions:" in line:
                    parts = line.split()[1].split('x')
                    return {"width": int(parts[0]), "height": int(parts[1])}
        except Exception:
            pass
        return {"width": 1920, "height": 1080}
    
    def get_active_window(self) -> Optional[str]:
        try:
            result = subprocess.run(["xdotool", "getactivewindow"], capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip()
        except Exception:
            pass
        return None
    
    def tile_window(self, window_id: str, layout: str) -> bool:
        if layout not in self.layouts:
            return False
        
        screen = self.get_screen_geometry()
        layout_config = self.layouts[layout]
        
        x = int(screen["width"] * layout_config["x"])
        y = int(screen["height"] * layout_config["y"])
        width = int(screen["width"] * layout_config["width"])
        height = int(screen["height"] * layout_config["height"])
        
        try:
            subprocess.run([
                "xdotool", "windowmove", window_id, str(x), str(y)
            ], check=True)
            subprocess.run([
                "xdotool", "windowsize", window_id, str(width), str(height)
            ], check=True)
            return True
        except Exception:
            return False
    
    def tile_active_window(self, layout: str) -> bool:
        window_id = self.get_active_window()
        if window_id:
            return self.tile_window(window_id, layout)
        return False


class QuickLauncher:
    def __init__(self):
        self.apps = QUICK_LAUNCHER_APPS
        self.recent_apps = []
        self.recent_file = Path.home() / ".config" / "aegis" / "recent_apps.json"
        
        self.load_recent()
    
    def load_recent(self):
        try:
            if self.recent_file.exists():
                with open(self.recent_file, 'r') as f:
                    self.recent_apps = json.load(f).get("recent", [])
        except Exception:
            pass
    
    def save_recent(self):
        try:
            self.recent_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.recent_file, 'w') as f:
                json.dump({"recent": self.recent_apps[:10]}, f)
        except Exception:
            pass
    
    def search_apps(self, query: str) -> List[Dict[str, str]]:
        query_lower = query.lower()
        results = []
        
        for app in self.apps:
            if query_lower in app["name"].lower():
                results.append(app)
        
        applications_dir = Path("/usr/share/applications")
        if applications_dir.exists():
            for desktop_file in applications_dir.glob("*.desktop"):
                try:
                    with open(desktop_file, 'r') as f:
                        content = f.read()
                        name = None
                        command = None
                        for line in content.split('\n'):
                            if line.startswith("Name="):
                                name = line.split("=", 1)[1]
                            elif line.startswith("Exec="):
                                command = line.split("=", 1)[1].split()[0]
                        
                        if name and command and query_lower in name.lower():
                            results.append({
                                "name": name,
                                "command": command,
                                "icon": "application-x-executable"
                            })
                except Exception:
                    pass
        
        return results[:10]
    
    def launch_app(self, command: str) -> bool:
        try:
            subprocess.Popen(command.split(), start_new_session=True)
            
            if command not in self.recent_apps:
                self.recent_apps.insert(0, command)
                self.recent_apps = self.recent_apps[:10]
                self.save_recent()
            
            return True
        except Exception:
            return False


class AegisProductivity:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.config = {}
        self.license_tier = LicenseTier.FREEMIUM
        
        self.clipboard = ClipboardManager()
        self.tiler = WindowTiler()
        self.launcher = QuickLauncher()
        
        self.setup_logging()
        self.load_license_tier()
        self.load_config()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            pass
        
        try:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[
                    logging.FileHandler(LOG_FILE) if os.access(str(log_dir), os.W_OK) else logging.NullHandler(),
                    logging.StreamHandler() if not self.headless else logging.NullHandler()
                ]
            )
        except Exception:
            logging.basicConfig(level=logging.INFO, handlers=[logging.StreamHandler()])
        
        self.logger = logging.getLogger("AegisProductivity")
        self.logger.info(f"Starting {APP_NAME} v{VERSION}")
    
    def load_license_tier(self):
        license_file = Path("/etc/aegis/license.json")
        try:
            if license_file.exists():
                with open(license_file, 'r') as f:
                    license_data = json.load(f)
                edition = license_data.get('edition', 'freemium').lower()
                tier_map = {
                    'freemium': LicenseTier.FREEMIUM,
                    'basic': LicenseTier.BASIC,
                    'gamer': LicenseTier.GAMER,
                    'gamer-ai': LicenseTier.GAMER_AI,
                    'server': LicenseTier.SERVER
                }
                self.license_tier = tier_map.get(edition, LicenseTier.FREEMIUM)
            else:
                if Path("/etc/aegis-basic-marker").exists():
                    self.license_tier = LicenseTier.BASIC
        except Exception as e:
            self.logger.warning(f"Failed to load license tier: {e}")
    
    def is_feature_available(self, feature: str) -> bool:
        basic_features = ["clipboard_manager", "window_tiling", "quick_launcher"]
        if feature in basic_features:
            return self.license_tier >= LicenseTier.BASIC
        return False
    
    def load_config(self):
        default_config = {
            "clipboard_manager": True,
            "clipboard_history_size": 100,
            "window_tiling": True,
            "quick_launcher": True,
            "quick_launcher_shortcut": "Super+Space"
        }
        
        try:
            if Path(CONFIG_FILE).exists():
                with open(CONFIG_FILE, 'r') as f:
                    file_config = json.load(f)
                    if "features" in file_config and "productivity" in file_config["features"]:
                        self.config = {**default_config, **file_config["features"]["productivity"]}
                    else:
                        self.config = default_config
            else:
                self.config = default_config
        except Exception as e:
            self.logger.error(f"Error loading config: {e}")
            self.config = default_config
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            print("GTK not available. Use --cli mode.")
            return self.run_cli()
        
        win = ProductivityWindow(self)
        win.connect("destroy", Gtk.main_quit)
        win.show_all()
        Gtk.main()
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"  License Tier: {'BASIC+' if self.license_tier >= LicenseTier.BASIC else 'FREEMIUM (Limited)'}")
        print(f"{'='*60}\n")
        
        print("Available Features:")
        print(f"  Clipboard Manager: {'✓' if self.is_feature_available('clipboard_manager') else '✗'}")
        print(f"  Window Tiling: {'✓' if self.is_feature_available('window_tiling') else '✗'}")
        print(f"  Quick Launcher: {'✓' if self.is_feature_available('quick_launcher') else '✗'}")
        
        print(f"\nClipboard History: {len(self.clipboard.get_history())} items")
        print(f"Tiling Layouts: {len(TILING_LAYOUTS)} available")
        print(f"Quick Launch Apps: {len(QUICK_LAUNCHER_APPS)} configured")
        
        if self.license_tier < LicenseTier.BASIC:
            print("\n⚠ Upgrade to Basic edition for productivity features")
            print("  Visit: https://aegis-os.com/pricing")


if GTK_AVAILABLE:
    class ProductivityWindow(Gtk.Window):
        def __init__(self, app: AegisProductivity):
            super().__init__(title=f"{APP_NAME} v{VERSION}")
            self.app = app
            self.set_default_size(800, 600)
            self.set_border_width(10)
            self.setup_ui()
        
        def setup_ui(self):
            vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            self.add(vbox)
            
            header = Gtk.Label()
            header.set_markup(f"<big><b>{APP_NAME}</b></big>")
            vbox.pack_start(header, False, False, 10)
            
            if self.app.license_tier < LicenseTier.BASIC:
                warning = Gtk.Label()
                warning.set_markup("<span foreground='orange'>⚠ Limited features - Upgrade to Basic for full access</span>")
                vbox.pack_start(warning, False, False, 5)
            
            notebook = Gtk.Notebook()
            vbox.pack_start(notebook, True, True, 0)
            
            notebook.append_page(self.create_clipboard_tab(), Gtk.Label(label="Clipboard"))
            notebook.append_page(self.create_tiling_tab(), Gtk.Label(label="Window Tiling"))
            notebook.append_page(self.create_launcher_tab(), Gtk.Label(label="Quick Launcher"))
        
        def create_clipboard_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            scrolled = Gtk.ScrolledWindow()
            scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
            
            listbox = Gtk.ListBox()
            
            history = self.app.clipboard.get_history()
            for entry in reversed(history[-20:]):
                row = Gtk.ListBoxRow()
                label = Gtk.Label(label=entry["content"][:80] + "..." if len(entry["content"]) > 80 else entry["content"])
                label.set_xalign(0)
                label.set_line_wrap(True)
                row.add(label)
                listbox.add(row)
            
            scrolled.add(listbox)
            box.pack_start(scrolled, True, True, 0)
            
            clear_btn = Gtk.Button(label="Clear History")
            clear_btn.connect("clicked", self.on_clear_clipboard)
            clear_btn.set_sensitive(self.app.license_tier >= LicenseTier.BASIC)
            box.pack_start(clear_btn, False, False, 10)
            
            return box
        
        def create_tiling_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            grid = Gtk.Grid()
            grid.set_column_spacing(10)
            grid.set_row_spacing(10)
            
            layouts_grid = [
                [("top_left", "↖"), ("top_half", "↑"), ("top_right", "↗")],
                [("left_half", "←"), ("center", "○"), ("right_half", "→")],
                [("bottom_left", "↙"), ("bottom_half", "↓"), ("bottom_right", "↘")]
            ]
            
            for row_idx, row in enumerate(layouts_grid):
                for col_idx, (layout, symbol) in enumerate(row):
                    btn = Gtk.Button(label=symbol)
                    btn.set_size_request(80, 60)
                    btn.connect("clicked", self.on_tile_window, layout)
                    btn.set_sensitive(self.app.license_tier >= LicenseTier.BASIC)
                    btn.set_tooltip_text(f"{layout.replace('_', ' ').title()}\n{TILING_LAYOUTS[layout]['shortcut']}")
                    grid.attach(btn, col_idx, row_idx, 1, 1)
            
            box.pack_start(grid, False, False, 20)
            
            max_btn = Gtk.Button(label="Maximize")
            max_btn.connect("clicked", self.on_tile_window, "maximize")
            max_btn.set_sensitive(self.app.license_tier >= LicenseTier.BASIC)
            box.pack_start(max_btn, False, False, 10)
            
            return box
        
        def create_launcher_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            search_entry = Gtk.Entry()
            search_entry.set_placeholder_text("Search applications...")
            search_entry.connect("changed", self.on_search_changed)
            box.pack_start(search_entry, False, False, 0)
            
            scrolled = Gtk.ScrolledWindow()
            scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
            
            self.apps_listbox = Gtk.ListBox()
            
            for app in QUICK_LAUNCHER_APPS:
                row = Gtk.ListBoxRow()
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
                
                label = Gtk.Label(label=app["name"])
                label.set_xalign(0)
                hbox.pack_start(label, True, True, 10)
                
                launch_btn = Gtk.Button(label="Launch")
                launch_btn.connect("clicked", self.on_launch_app, app["command"])
                launch_btn.set_sensitive(self.app.license_tier >= LicenseTier.BASIC)
                hbox.pack_end(launch_btn, False, False, 10)
                
                row.add(hbox)
                self.apps_listbox.add(row)
            
            scrolled.add(self.apps_listbox)
            box.pack_start(scrolled, True, True, 0)
            
            return box
        
        def on_clear_clipboard(self, button):
            self.app.clipboard.clear_history()
        
        def on_tile_window(self, button, layout):
            self.app.tiler.tile_active_window(layout)
        
        def on_search_changed(self, entry):
            pass
        
        def on_launch_app(self, button, command):
            self.app.launcher.launch_app(command)


def main():
    if not GTK_AVAILABLE:
        print(f"Cannot start {APP_NAME}: GTK3 not available.", file=sys.stderr)
        sys.exit(1)
    
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - Productivity enhancement tool")
    parser.add_argument("--gui", action="store_true", help="Launch GUI mode")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode")
    parser.add_argument("--clipboard-history", action="store_true", help="Show clipboard history")
    parser.add_argument("--tile", metavar="LAYOUT", help="Tile active window")
    parser.add_argument("--launch", metavar="APP", help="Quick launch application")
    parser.add_argument("--list-layouts", action="store_true", help="List tiling layouts")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.clipboard_history:
        app = AegisProductivity(headless=True)
        history = app.clipboard.get_history()
        for entry in history:
            print(f"[{entry['timestamp']}] {entry['content'][:50]}...")
    elif args.tile:
        app = AegisProductivity(headless=True)
        result = app.tiler.tile_active_window(args.tile)
        print("Window tiled" if result else "Failed to tile window")
    elif args.launch:
        app = AegisProductivity(headless=True)
        result = app.launcher.launch_app(args.launch)
        print("App launched" if result else "Failed to launch app")
    elif args.list_layouts:
        for layout_id, layout in TILING_LAYOUTS.items():
            print(f"{layout_id}: {layout['shortcut']}")
    elif args.cli or not GTK_AVAILABLE:
        app = AegisProductivity(headless=False)
        app.run_cli()
    else:
        app = AegisProductivity(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
