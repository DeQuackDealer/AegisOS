#!/usr/bin/env python3
"""
Aegis Security Suite - Comprehensive security management for Basic edition
Features: ClamAV integration, UFW firewall, Fail2ban, encrypted folders

Provides GUI (tkinter) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import threading
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any

TIER_LIMIT = "basic"
VERSION = "1.5.0"
APP_NAME = "Aegis Security Suite"

CONFIG_FILE = "/etc/aegis/basic-config.json"
LOG_FILE = "/var/log/aegis/security-suite.log"
DATA_DIR = "/var/lib/aegis/security"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, Gdk, GLib, Pango
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False


class LicenseTier:
    FREEMIUM = 1
    BASIC = 2
    GAMER = 3
    GAMER_AI = 4
    SERVER = 5


class AegisSecuritySuite:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.config = {}
        self.license_tier = LicenseTier.FREEMIUM
        self.daemon_mode = False
        self.running = True
        
        self.setup_logging()
        self.load_license_tier()
        self.load_config()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            pass
        
        try:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[
                    logging.FileHandler(LOG_FILE) if os.access(str(log_dir), os.W_OK) else logging.NullHandler(),
                    logging.StreamHandler() if not self.headless else logging.NullHandler()
                ]
            )
        except Exception:
            logging.basicConfig(level=logging.INFO, handlers=[logging.StreamHandler()])
        
        self.logger = logging.getLogger("AegisSecuritySuite")
        self.logger.info(f"Starting {APP_NAME} v{VERSION}")
    
    def load_license_tier(self):
        license_file = Path("/etc/aegis/license.json")
        try:
            if license_file.exists():
                with open(license_file, 'r') as f:
                    license_data = json.load(f)
                edition = license_data.get('edition', 'freemium').lower()
                tier_map = {
                    'freemium': LicenseTier.FREEMIUM,
                    'basic': LicenseTier.BASIC,
                    'gamer': LicenseTier.GAMER,
                    'gamer-ai': LicenseTier.GAMER_AI,
                    'server': LicenseTier.SERVER
                }
                self.license_tier = tier_map.get(edition, LicenseTier.FREEMIUM)
            else:
                markers = [
                    (Path("/etc/aegis-server-marker"), LicenseTier.SERVER),
                    (Path("/etc/aegis-gamer-ai-marker"), LicenseTier.GAMER_AI),
                    (Path("/etc/aegis-gamer-marker"), LicenseTier.GAMER),
                    (Path("/etc/aegis-basic-marker"), LicenseTier.BASIC),
                ]
                for marker, tier in markers:
                    if marker.exists():
                        self.license_tier = tier
                        break
        except Exception as e:
            self.logger.warning(f"Failed to load license tier: {e}")
        
        self.logger.info(f"License tier: {self.license_tier}")
    
    def is_feature_available(self, feature: str) -> bool:
        basic_features = ["clamav", "ufw", "fail2ban", "encrypted_folders", "scan_on_demand"]
        if feature in basic_features:
            return self.license_tier >= LicenseTier.BASIC
        return False
    
    def load_config(self):
        default_config = {
            "clamav_enabled": True,
            "clamav_realtime_scan": False,
            "ufw_enabled": True,
            "fail2ban_enabled": True,
            "encrypted_folders_enabled": True,
            "scan_schedule": "daily"
        }
        
        try:
            if Path(CONFIG_FILE).exists():
                with open(CONFIG_FILE, 'r') as f:
                    file_config = json.load(f)
                    if "features" in file_config and "security_suite" in file_config["features"]:
                        self.config = {**default_config, **file_config["features"]["security_suite"]}
                    else:
                        self.config = default_config
            else:
                self.config = default_config
        except Exception as e:
            self.logger.error(f"Error loading config: {e}")
            self.config = default_config
    
    def check_clamav_status(self) -> Dict[str, Any]:
        status = {"installed": False, "running": False, "definitions_date": None}
        try:
            result = subprocess.run(["which", "clamscan"], capture_output=True)
            status["installed"] = result.returncode == 0
            
            if status["installed"]:
                result = subprocess.run(["systemctl", "is-active", "clamav-freshclam"], capture_output=True, text=True)
                status["running"] = result.stdout.strip() == "active"
                
                freshclam_log = Path("/var/log/clamav/freshclam.log")
                if freshclam_log.exists():
                    stat = freshclam_log.stat()
                    status["definitions_date"] = datetime.fromtimestamp(stat.st_mtime).isoformat()
        except Exception as e:
            self.logger.error(f"ClamAV status check failed: {e}")
        return status
    
    def run_clamav_scan(self, path: str = "/home") -> Dict[str, Any]:
        if not self.is_feature_available("clamav"):
            return {"error": "ClamAV requires Basic edition or higher"}
        
        result = {"scanned": 0, "infected": 0, "errors": [], "duration": 0}
        start_time = time.time()
        
        try:
            proc = subprocess.run(
                ["clamscan", "-r", "--quiet", "--infected", path],
                capture_output=True, text=True, timeout=3600
            )
            result["duration"] = time.time() - start_time
            
            for line in proc.stdout.split('\n'):
                if "Scanned files:" in line:
                    result["scanned"] = int(line.split(':')[1].strip())
                elif "Infected files:" in line:
                    result["infected"] = int(line.split(':')[1].strip())
        except subprocess.TimeoutExpired:
            result["errors"].append("Scan timed out")
        except Exception as e:
            result["errors"].append(str(e))
        
        self.logger.info(f"ClamAV scan complete: {result}")
        return result
    
    def check_ufw_status(self) -> Dict[str, Any]:
        status = {"installed": False, "active": False, "rules": []}
        try:
            result = subprocess.run(["which", "ufw"], capture_output=True)
            status["installed"] = result.returncode == 0
            
            if status["installed"]:
                result = subprocess.run(["ufw", "status"], capture_output=True, text=True)
                status["active"] = "Status: active" in result.stdout
                
                for line in result.stdout.split('\n')[4:]:
                    if line.strip():
                        status["rules"].append(line.strip())
        except Exception as e:
            self.logger.error(f"UFW status check failed: {e}")
        return status
    
    def enable_ufw(self, enable: bool = True) -> bool:
        if not self.is_feature_available("ufw"):
            return False
        
        try:
            cmd = ["ufw", "--force", "enable" if enable else "disable"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            self.logger.error(f"UFW toggle failed: {e}")
            return False
    
    def add_ufw_rule(self, rule_type: str, port: int, protocol: str = "tcp") -> bool:
        if not self.is_feature_available("ufw"):
            return False
        
        try:
            cmd = ["ufw", rule_type, f"{port}/{protocol}"]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            self.logger.error(f"UFW rule add failed: {e}")
            return False
    
    def check_fail2ban_status(self) -> Dict[str, Any]:
        status = {"installed": False, "running": False, "jails": []}
        try:
            result = subprocess.run(["which", "fail2ban-client"], capture_output=True)
            status["installed"] = result.returncode == 0
            
            if status["installed"]:
                result = subprocess.run(["systemctl", "is-active", "fail2ban"], capture_output=True, text=True)
                status["running"] = result.stdout.strip() == "active"
                
                if status["running"]:
                    result = subprocess.run(["fail2ban-client", "status"], capture_output=True, text=True)
                    for line in result.stdout.split('\n'):
                        if "Jail list:" in line:
                            jails = line.split(':')[1].strip().split(',')
                            status["jails"] = [j.strip() for j in jails if j.strip()]
        except Exception as e:
            self.logger.error(f"Fail2ban status check failed: {e}")
        return status
    
    def create_encrypted_folder(self, folder_name: str = "Private") -> bool:
        if not self.is_feature_available("encrypted_folders"):
            return False
        
        home = Path.home()
        private_dir = home / folder_name
        
        try:
            private_dir.mkdir(exist_ok=True)
            
            result = subprocess.run(["which", "ecryptfs-setup-private"], capture_output=True)
            if result.returncode == 0:
                self.logger.info(f"Encrypted folder setup at {private_dir}")
                return True
            else:
                self.logger.warning("ecryptfs not available, folder created without encryption")
                return True
        except Exception as e:
            self.logger.error(f"Encrypted folder creation failed: {e}")
            return False
    
    def get_security_summary(self) -> Dict[str, Any]:
        return {
            "clamav": self.check_clamav_status(),
            "ufw": self.check_ufw_status(),
            "fail2ban": self.check_fail2ban_status(),
            "tier": self.license_tier,
            "features_available": self.license_tier >= LicenseTier.BASIC
        }
    
    def daemon_loop(self):
        self.logger.info("Starting security daemon loop")
        scan_interval = 86400
        last_scan = 0
        
        while self.running:
            current_time = time.time()
            
            if self.config.get("clamav_enabled") and (current_time - last_scan) > scan_interval:
                self.logger.info("Running scheduled ClamAV scan")
                self.run_clamav_scan("/home")
                last_scan = current_time
            
            time.sleep(60)
    
    def run_daemon(self):
        self.daemon_mode = True
        self.daemon_loop()
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            print("GTK not available. Use --cli mode.")
            return self.run_cli()
        
        win = SecuritySuiteWindow(self)
        win.connect("destroy", Gtk.main_quit)
        win.show_all()
        Gtk.main()
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"  License Tier: {'BASIC+' if self.license_tier >= LicenseTier.BASIC else 'FREEMIUM (Limited)'}")
        print(f"{'='*60}\n")
        
        summary = self.get_security_summary()
        
        print("Security Status:")
        print(f"  ClamAV: {'Installed' if summary['clamav']['installed'] else 'Not installed'}")
        print(f"  UFW Firewall: {'Active' if summary['ufw']['active'] else 'Inactive'}")
        print(f"  Fail2ban: {'Running' if summary['fail2ban']['running'] else 'Not running'}")
        
        if not summary['features_available']:
            print("\n⚠ Upgrade to Basic edition for full security features")
            print("  Visit: https://aegis-os.com/pricing")


if GTK_AVAILABLE:
    class SecuritySuiteWindow(Gtk.Window):
        def __init__(self, app: AegisSecuritySuite):
            super().__init__(title=f"{APP_NAME} v{VERSION}")
            self.app = app
            self.set_default_size(800, 600)
            self.set_border_width(10)
            
            self.setup_ui()
        
        def setup_ui(self):
            vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            self.add(vbox)
            
            header = Gtk.Label()
            header.set_markup(f"<big><b>{APP_NAME}</b></big>")
            vbox.pack_start(header, False, False, 10)
            
            if self.app.license_tier < LicenseTier.BASIC:
                warning = Gtk.Label()
                warning.set_markup("<span foreground='orange'>⚠ Limited features - Upgrade to Basic for full access</span>")
                vbox.pack_start(warning, False, False, 5)
            
            notebook = Gtk.Notebook()
            vbox.pack_start(notebook, True, True, 0)
            
            notebook.append_page(self.create_overview_tab(), Gtk.Label(label="Overview"))
            notebook.append_page(self.create_antivirus_tab(), Gtk.Label(label="Antivirus"))
            notebook.append_page(self.create_firewall_tab(), Gtk.Label(label="Firewall"))
            notebook.append_page(self.create_intrusion_tab(), Gtk.Label(label="Intrusion Prevention"))
        
        def create_overview_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            summary = self.app.get_security_summary()
            
            for name, data in [("ClamAV", summary["clamav"]), ("UFW", summary["ufw"]), ("Fail2ban", summary["fail2ban"])]:
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
                label = Gtk.Label(label=f"{name}:")
                label.set_width_chars(15)
                label.set_xalign(0)
                hbox.pack_start(label, False, False, 0)
                
                if isinstance(data, dict):
                    status = "✓ Active" if data.get("running") or data.get("active") else "✗ Inactive"
                else:
                    status = str(data)
                
                status_label = Gtk.Label(label=status)
                hbox.pack_start(status_label, False, False, 0)
                box.pack_start(hbox, False, False, 5)
            
            return box
        
        def create_antivirus_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            scan_btn = Gtk.Button(label="Run Full Scan")
            scan_btn.connect("clicked", self.on_scan_clicked)
            scan_btn.set_sensitive(self.app.license_tier >= LicenseTier.BASIC)
            box.pack_start(scan_btn, False, False, 10)
            
            self.scan_result = Gtk.Label(label="Click 'Run Full Scan' to start")
            box.pack_start(self.scan_result, False, False, 5)
            
            return box
        
        def create_firewall_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            status = self.app.check_ufw_status()
            
            toggle_btn = Gtk.Switch()
            toggle_btn.set_active(status["active"])
            toggle_btn.connect("notify::active", self.on_firewall_toggle)
            toggle_btn.set_sensitive(self.app.license_tier >= LicenseTier.BASIC)
            
            hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            hbox.pack_start(Gtk.Label(label="Firewall Enabled:"), False, False, 0)
            hbox.pack_start(toggle_btn, False, False, 0)
            box.pack_start(hbox, False, False, 10)
            
            return box
        
        def create_intrusion_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            status = self.app.check_fail2ban_status()
            
            label = Gtk.Label()
            label.set_markup(f"<b>Fail2ban Status:</b> {'Running' if status['running'] else 'Stopped'}")
            box.pack_start(label, False, False, 10)
            
            if status["jails"]:
                jails_label = Gtk.Label(label=f"Active Jails: {', '.join(status['jails'])}")
                box.pack_start(jails_label, False, False, 5)
            
            return box
        
        def on_scan_clicked(self, button):
            self.scan_result.set_text("Scanning... Please wait.")
            threading.Thread(target=self._run_scan, daemon=True).start()
        
        def _run_scan(self):
            result = self.app.run_clamav_scan("/home")
            GLib.idle_add(self._update_scan_result, result)
        
        def _update_scan_result(self, result):
            if "error" in result:
                self.scan_result.set_text(f"Error: {result['error']}")
            else:
                self.scan_result.set_text(
                    f"Scanned: {result['scanned']} files, "
                    f"Infected: {result['infected']}, "
                    f"Duration: {result['duration']:.1f}s"
                )
        
        def on_firewall_toggle(self, switch, gparam):
            self.app.enable_ufw(switch.get_active())


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - Security management tool")
    parser.add_argument("--gui", action="store_true", help="Launch GUI mode")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode")
    parser.add_argument("--daemon", action="store_true", help="Run as daemon")
    parser.add_argument("--status", action="store_true", help="Show security status")
    parser.add_argument("--scan", metavar="PATH", help="Run ClamAV scan on path")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.daemon:
        app = AegisSecuritySuite(headless=True)
        app.run_daemon()
    elif args.status:
        app = AegisSecuritySuite(headless=True)
        summary = app.get_security_summary()
        print(json.dumps(summary, indent=2, default=str))
    elif args.scan:
        app = AegisSecuritySuite(headless=True)
        result = app.run_clamav_scan(args.scan)
        print(json.dumps(result, indent=2))
    elif args.cli or not GTK_AVAILABLE:
        app = AegisSecuritySuite(headless=False)
        app.run_cli()
    else:
        app = AegisSecuritySuite(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
