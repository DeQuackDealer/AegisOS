#!/usr/bin/env python3
"""
Aegis Media Suite - Media management and creation tools for Basic edition
Features: VLC config, Handbrake presets, screen recorder, podcast manager

Provides GUI (tkinter) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import threading
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any

TIER_LIMIT = "basic"
VERSION = "1.5.0"
APP_NAME = "Aegis Media Suite"

CONFIG_FILE = "/etc/aegis/basic-config.json"
LOG_FILE = "/var/log/aegis/media-suite.log"
DATA_DIR = "/var/lib/aegis/media"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, Gdk, GLib
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False


class LicenseTier:
    FREEMIUM = 1
    BASIC = 2
    GAMER = 3
    GAMER_AI = 4
    SERVER = 5


HANDBRAKE_PRESETS = {
    "fast_1080p": {
        "name": "Fast 1080p",
        "video_codec": "x264",
        "video_quality": 22,
        "audio_codec": "aac",
        "audio_bitrate": 160,
        "preset": "veryfast",
        "resolution": "1920x1080"
    },
    "quality_1080p": {
        "name": "Quality 1080p",
        "video_codec": "x264",
        "video_quality": 18,
        "audio_codec": "aac",
        "audio_bitrate": 256,
        "preset": "slow",
        "resolution": "1920x1080"
    },
    "4k_hevc": {
        "name": "4K HEVC",
        "video_codec": "x265",
        "video_quality": 20,
        "audio_codec": "aac",
        "audio_bitrate": 320,
        "preset": "medium",
        "resolution": "3840x2160"
    },
    "web_optimized": {
        "name": "Web Optimized",
        "video_codec": "x264",
        "video_quality": 23,
        "audio_codec": "aac",
        "audio_bitrate": 128,
        "preset": "fast",
        "resolution": "1280x720",
        "web_optimize": True
    }
}


class AegisMediaSuite:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.config = {}
        self.license_tier = LicenseTier.FREEMIUM
        self.recording = False
        self.record_process = None
        
        self.setup_logging()
        self.load_license_tier()
        self.load_config()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            pass
        
        try:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[
                    logging.FileHandler(LOG_FILE) if os.access(str(log_dir), os.W_OK) else logging.NullHandler(),
                    logging.StreamHandler() if not self.headless else logging.NullHandler()
                ]
            )
        except Exception:
            logging.basicConfig(level=logging.INFO, handlers=[logging.StreamHandler()])
        
        self.logger = logging.getLogger("AegisMediaSuite")
        self.logger.info(f"Starting {APP_NAME} v{VERSION}")
    
    def load_license_tier(self):
        license_file = Path("/etc/aegis/license.json")
        try:
            if license_file.exists():
                with open(license_file, 'r') as f:
                    license_data = json.load(f)
                edition = license_data.get('edition', 'freemium').lower()
                tier_map = {
                    'freemium': LicenseTier.FREEMIUM,
                    'basic': LicenseTier.BASIC,
                    'gamer': LicenseTier.GAMER,
                    'gamer-ai': LicenseTier.GAMER_AI,
                    'server': LicenseTier.SERVER
                }
                self.license_tier = tier_map.get(edition, LicenseTier.FREEMIUM)
            else:
                if Path("/etc/aegis-basic-marker").exists():
                    self.license_tier = LicenseTier.BASIC
        except Exception as e:
            self.logger.warning(f"Failed to load license tier: {e}")
    
    def is_feature_available(self, feature: str) -> bool:
        basic_features = ["vlc_config", "handbrake_presets", "screen_recorder", "podcast_manager"]
        if feature in basic_features:
            return self.license_tier >= LicenseTier.BASIC
        return False
    
    def load_config(self):
        default_config = {
            "vlc_custom_config": True,
            "handbrake_presets": True,
            "screen_recorder_enabled": True,
            "podcast_manager": True,
            "recording_format": "mp4",
            "recording_quality": "high",
            "output_directory": str(Path.home() / "Videos" / "Recordings")
        }
        
        try:
            if Path(CONFIG_FILE).exists():
                with open(CONFIG_FILE, 'r') as f:
                    file_config = json.load(f)
                    if "features" in file_config and "media_suite" in file_config["features"]:
                        self.config = {**default_config, **file_config["features"]["media_suite"]}
                    else:
                        self.config = default_config
            else:
                self.config = default_config
        except Exception as e:
            self.logger.error(f"Error loading config: {e}")
            self.config = default_config
    
    def get_vlc_config(self) -> Dict[str, Any]:
        return {
            "hardware_acceleration": True,
            "subtitle_autoload": True,
            "audio_normalization": True,
            "resume_playback": True,
            "dark_theme": True,
            "keyboard_shortcuts": {
                "play_pause": "Space",
                "fullscreen": "F",
                "volume_up": "Up",
                "volume_down": "Down",
                "seek_forward": "Right",
                "seek_backward": "Left"
            }
        }
    
    def apply_vlc_config(self) -> bool:
        if not self.is_feature_available("vlc_config"):
            return False
        
        vlc_config_dir = Path.home() / ".config" / "vlc"
        vlc_config_dir.mkdir(parents=True, exist_ok=True)
        
        vlcrc = vlc_config_dir / "vlcrc"
        config_content = """
[qt]
qt-privacy-ask=0
qt-updates-notif=0
qt-video-autoload=1

[core]
audio-replay-gain-mode=norm
hardware-decoding=any

[subs]
sub-auto=any
"""
        try:
            with open(vlcrc, 'w') as f:
                f.write(config_content)
            self.logger.info("VLC configuration applied")
            return True
        except Exception as e:
            self.logger.error(f"Failed to apply VLC config: {e}")
            return False
    
    def get_handbrake_presets(self) -> Dict[str, Any]:
        return HANDBRAKE_PRESETS
    
    def export_handbrake_preset(self, preset_name: str) -> Optional[str]:
        if not self.is_feature_available("handbrake_presets"):
            return None
        
        if preset_name not in HANDBRAKE_PRESETS:
            return None
        
        preset = HANDBRAKE_PRESETS[preset_name]
        handbrake_preset = {
            "PresetList": [{
                "PresetName": preset["name"],
                "VideoEncoder": preset["video_codec"],
                "VideoQualityType": 2,
                "VideoQualitySlider": preset["video_quality"],
                "AudioEncoderFallback": preset["audio_codec"],
                "AudioBitrate": preset["audio_bitrate"],
                "x264Preset": preset.get("preset", "medium")
            }]
        }
        
        return json.dumps(handbrake_preset, indent=2)
    
    def start_screen_recording(self, output_file: Optional[str] = None) -> Dict[str, Any]:
        if not self.is_feature_available("screen_recorder"):
            return {"success": False, "error": "Screen recorder requires Basic edition"}
        
        if self.recording:
            return {"success": False, "error": "Recording already in progress"}
        
        output_dir = Path(self.config.get("output_directory", str(Path.home() / "Videos" / "Recordings")))
        output_dir.mkdir(parents=True, exist_ok=True)
        
        if not output_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = str(output_dir / f"recording_{timestamp}.mp4")
        
        try:
            result = subprocess.run(["which", "ffmpeg"], capture_output=True)
            if result.returncode != 0:
                return {"success": False, "error": "FFmpeg not installed"}
            
            quality_settings = {
                "high": "-crf 18 -preset slow",
                "medium": "-crf 23 -preset medium",
                "low": "-crf 28 -preset fast"
            }
            quality = self.config.get("recording_quality", "high")
            
            display = os.environ.get("DISPLAY", ":0")
            
            cmd = f"ffmpeg -f x11grab -i {display} {quality_settings.get(quality, quality_settings['high'])} -y {output_file}"
            
            self.record_process = subprocess.Popen(
                cmd.split(),
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            self.recording = True
            
            self.logger.info(f"Screen recording started: {output_file}")
            return {"success": True, "output_file": output_file, "pid": self.record_process.pid}
            
        except Exception as e:
            self.logger.error(f"Failed to start recording: {e}")
            return {"success": False, "error": str(e)}
    
    def stop_screen_recording(self) -> Dict[str, Any]:
        if not self.recording or not self.record_process:
            return {"success": False, "error": "No recording in progress"}
        
        try:
            self.record_process.terminate()
            self.record_process.wait(timeout=5)
            self.recording = False
            self.logger.info("Screen recording stopped")
            return {"success": True}
        except Exception as e:
            self.logger.error(f"Failed to stop recording: {e}")
            return {"success": False, "error": str(e)}
    
    def list_recordings(self) -> List[Dict[str, Any]]:
        output_dir = Path(self.config.get("output_directory", str(Path.home() / "Videos" / "Recordings")))
        recordings = []
        
        if output_dir.exists():
            for file in output_dir.glob("*.mp4"):
                stat = file.stat()
                recordings.append({
                    "name": file.name,
                    "path": str(file),
                    "size_bytes": stat.st_size,
                    "created": datetime.fromtimestamp(stat.st_ctime).isoformat()
                })
        
        return sorted(recordings, key=lambda x: x["created"], reverse=True)
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            print("GTK not available. Use --cli mode.")
            return self.run_cli()
        
        win = MediaSuiteWindow(self)
        win.connect("destroy", Gtk.main_quit)
        win.show_all()
        Gtk.main()
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"  License Tier: {'BASIC+' if self.license_tier >= LicenseTier.BASIC else 'FREEMIUM (Limited)'}")
        print(f"{'='*60}\n")
        
        print("Available Features:")
        print(f"  VLC Custom Config: {'✓' if self.is_feature_available('vlc_config') else '✗'}")
        print(f"  Handbrake Presets: {'✓' if self.is_feature_available('handbrake_presets') else '✗'}")
        print(f"  Screen Recorder: {'✓' if self.is_feature_available('screen_recorder') else '✗'}")
        print(f"  Podcast Manager: {'✓' if self.is_feature_available('podcast_manager') else '✗'}")
        
        print("\nHandbrake Presets Available:")
        for name, preset in HANDBRAKE_PRESETS.items():
            print(f"  - {preset['name']}: {preset['video_codec']} @ {preset['resolution']}")
        
        if self.license_tier < LicenseTier.BASIC:
            print("\n⚠ Upgrade to Basic edition for full media features")
            print("  Visit: https://aegis-os.com/pricing")


if GTK_AVAILABLE:
    class MediaSuiteWindow(Gtk.Window):
        def __init__(self, app: AegisMediaSuite):
            super().__init__(title=f"{APP_NAME} v{VERSION}")
            self.app = app
            self.set_default_size(800, 600)
            self.set_border_width(10)
            self.setup_ui()
        
        def setup_ui(self):
            vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            self.add(vbox)
            
            header = Gtk.Label()
            header.set_markup(f"<big><b>{APP_NAME}</b></big>")
            vbox.pack_start(header, False, False, 10)
            
            if self.app.license_tier < LicenseTier.BASIC:
                warning = Gtk.Label()
                warning.set_markup("<span foreground='orange'>⚠ Limited features - Upgrade to Basic for full access</span>")
                vbox.pack_start(warning, False, False, 5)
            
            notebook = Gtk.Notebook()
            vbox.pack_start(notebook, True, True, 0)
            
            notebook.append_page(self.create_recorder_tab(), Gtk.Label(label="Screen Recorder"))
            notebook.append_page(self.create_presets_tab(), Gtk.Label(label="Handbrake Presets"))
            notebook.append_page(self.create_vlc_tab(), Gtk.Label(label="VLC Config"))
        
        def create_recorder_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            self.record_btn = Gtk.Button(label="Start Recording")
            self.record_btn.connect("clicked", self.on_record_clicked)
            self.record_btn.set_sensitive(self.app.license_tier >= LicenseTier.BASIC)
            box.pack_start(self.record_btn, False, False, 10)
            
            self.record_status = Gtk.Label(label="Ready to record")
            box.pack_start(self.record_status, False, False, 5)
            
            return box
        
        def create_presets_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            for name, preset in HANDBRAKE_PRESETS.items():
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
                label = Gtk.Label(label=f"{preset['name']}: {preset['video_codec']} @ Q{preset['video_quality']}")
                label.set_xalign(0)
                hbox.pack_start(label, True, True, 0)
                box.pack_start(hbox, False, False, 5)
            
            return box
        
        def create_vlc_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            apply_btn = Gtk.Button(label="Apply VLC Configuration")
            apply_btn.connect("clicked", self.on_apply_vlc)
            apply_btn.set_sensitive(self.app.license_tier >= LicenseTier.BASIC)
            box.pack_start(apply_btn, False, False, 10)
            
            return box
        
        def on_record_clicked(self, button):
            if not self.app.recording:
                result = self.app.start_screen_recording()
                if result["success"]:
                    self.record_btn.set_label("Stop Recording")
                    self.record_status.set_text(f"Recording: {result['output_file']}")
                else:
                    self.record_status.set_text(f"Error: {result.get('error')}")
            else:
                result = self.app.stop_screen_recording()
                self.record_btn.set_label("Start Recording")
                self.record_status.set_text("Recording stopped")
        
        def on_apply_vlc(self, button):
            if self.app.apply_vlc_config():
                dialog = Gtk.MessageDialog(
                    parent=self,
                    message_type=Gtk.MessageType.INFO,
                    buttons=Gtk.ButtonsType.OK,
                    text="VLC configuration applied successfully"
                )
                dialog.run()
                dialog.destroy()


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - Media management tool")
    parser.add_argument("--gui", action="store_true", help="Launch GUI mode")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode")
    parser.add_argument("--record-start", action="store_true", help="Start screen recording")
    parser.add_argument("--record-stop", action="store_true", help="Stop screen recording")
    parser.add_argument("--list-recordings", action="store_true", help="List recordings")
    parser.add_argument("--apply-vlc-config", action="store_true", help="Apply VLC configuration")
    parser.add_argument("--list-presets", action="store_true", help="List Handbrake presets")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.record_start:
        app = AegisMediaSuite(headless=True)
        result = app.start_screen_recording()
        print(json.dumps(result, indent=2))
    elif args.record_stop:
        app = AegisMediaSuite(headless=True)
        result = app.stop_screen_recording()
        print(json.dumps(result, indent=2))
    elif args.list_recordings:
        app = AegisMediaSuite(headless=True)
        recordings = app.list_recordings()
        print(json.dumps(recordings, indent=2))
    elif args.apply_vlc_config:
        app = AegisMediaSuite(headless=True)
        result = app.apply_vlc_config()
        print("VLC config applied" if result else "Failed to apply VLC config")
    elif args.list_presets:
        for name, preset in HANDBRAKE_PRESETS.items():
            print(f"{name}: {preset['name']}")
    elif args.cli or not GTK_AVAILABLE:
        app = AegisMediaSuite(headless=False)
        app.run_cli()
    else:
        app = AegisMediaSuite(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
