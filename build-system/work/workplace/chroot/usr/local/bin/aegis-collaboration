#!/usr/bin/env python3
"""
Aegis Collaboration - Screen sharing and video conferencing tools for Workplace edition
Features: Screen sharing, video conferencing launchers, team chat, whiteboard

Provides GUI (GTK) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import webbrowser
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any

TIER_LIMIT = "workplace"
VERSION = "1.5.0"
APP_NAME = "Aegis Collaboration"

CONFIG_FILE = "/etc/aegis/workplace-config.json"
LOG_FILE = "/var/log/aegis/collaboration.log"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, GLib
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False


class LicenseTier:
    FREEMIUM = 1
    BASIC = 2
    WORKPLACE = 3
    GAMER = 4
    SERVER = 5


CONFERENCING_APPS = {
    "zoom": {"name": "Zoom", "command": "zoom", "web_url": "https://zoom.us/join", "icon": "camera-video"},
    "teams": {"name": "Microsoft Teams", "command": "teams", "web_url": "https://teams.microsoft.com", "icon": "user-available"},
    "meet": {"name": "Google Meet", "command": None, "web_url": "https://meet.google.com", "icon": "camera-video"},
    "webex": {"name": "Cisco Webex", "command": "webex", "web_url": "https://www.webex.com", "icon": "camera-video"},
    "slack": {"name": "Slack", "command": "slack", "web_url": "https://slack.com", "icon": "user-available"},
    "discord": {"name": "Discord", "command": "discord", "web_url": "https://discord.com/app", "icon": "user-available"}
}

SCREEN_SHARE_TOOLS = {
    "x11vnc": {"name": "X11VNC", "command": "x11vnc", "description": "VNC server for X11"},
    "wayvnc": {"name": "WayVNC", "command": "wayvnc", "description": "VNC server for Wayland"},
    "rustdesk": {"name": "RustDesk", "command": "rustdesk", "description": "Open source remote desktop"}
}


class AegisCollaboration:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.config = {}
        self.license_tier = LicenseTier.FREEMIUM
        self.screen_sharing_active = False
        self.share_process = None
        
        self.setup_logging()
        self.load_license_tier()
        self.load_config()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            pass
        
        try:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[
                    logging.FileHandler(LOG_FILE) if os.access(str(log_dir), os.W_OK) else logging.NullHandler(),
                    logging.StreamHandler() if not self.headless else logging.NullHandler()
                ]
            )
        except Exception:
            logging.basicConfig(level=logging.INFO, handlers=[logging.StreamHandler()])
        
        self.logger = logging.getLogger("AegisCollaboration")
        self.logger.info(f"Starting {APP_NAME} v{VERSION}")
    
    def load_license_tier(self):
        license_file = Path("/etc/aegis/license.json")
        try:
            if license_file.exists():
                with open(license_file, 'r') as f:
                    license_data = json.load(f)
                edition = license_data.get('edition', 'freemium').lower()
                tier_map = {
                    'freemium': LicenseTier.FREEMIUM,
                    'basic': LicenseTier.BASIC,
                    'workplace': LicenseTier.WORKPLACE,
                    'gamer': LicenseTier.GAMER,
                    'server': LicenseTier.SERVER
                }
                self.license_tier = tier_map.get(edition, LicenseTier.FREEMIUM)
            else:
                if Path("/etc/aegis-workplace-marker").exists():
                    self.license_tier = LicenseTier.WORKPLACE
        except Exception as e:
            self.logger.warning(f"Failed to load license tier: {e}")
    
    def is_feature_available(self, feature: str) -> bool:
        workplace_features = ["screen_sharing", "video_conferencing", "team_chat"]
        if feature in workplace_features:
            return self.license_tier >= LicenseTier.WORKPLACE
        return False
    
    def load_config(self):
        default_config = {
            "screen_sharing": True,
            "video_conferencing": True,
            "default_conferencing_app": "teams",
            "screen_share_tool": "x11vnc"
        }
        
        try:
            if Path(CONFIG_FILE).exists():
                with open(CONFIG_FILE, 'r') as f:
                    file_config = json.load(f)
                    if "features" in file_config and "collaboration" in file_config["features"]:
                        self.config = {**default_config, **file_config["features"]["collaboration"]}
                    else:
                        self.config = default_config
            else:
                self.config = default_config
        except Exception as e:
            self.logger.error(f"Error loading config: {e}")
            self.config = default_config
    
    def check_app_installed(self, command: str) -> bool:
        try:
            result = subprocess.run(["which", command], capture_output=True)
            return result.returncode == 0
        except Exception:
            return False
    
    def launch_conferencing_app(self, app_id: str, use_web: bool = False) -> bool:
        if not self.is_feature_available("video_conferencing"):
            return False
        
        if app_id not in CONFERENCING_APPS:
            return False
        
        app = CONFERENCING_APPS[app_id]
        
        if not use_web and app["command"] and self.check_app_installed(app["command"]):
            try:
                subprocess.Popen([app["command"]], start_new_session=True)
                self.logger.info(f"Launched {app['name']} (native)")
                return True
            except Exception as e:
                self.logger.error(f"Failed to launch native app: {e}")
        
        try:
            webbrowser.open(app["web_url"])
            self.logger.info(f"Launched {app['name']} (web)")
            return True
        except Exception as e:
            self.logger.error(f"Failed to launch web app: {e}")
            return False
    
    def start_screen_sharing(self, tool: str = "x11vnc", port: int = 5900) -> Dict[str, Any]:
        if not self.is_feature_available("screen_sharing"):
            return {"success": False, "error": "Screen sharing requires Workplace edition"}
        
        if self.screen_sharing_active:
            return {"success": False, "error": "Screen sharing already active"}
        
        if tool not in SCREEN_SHARE_TOOLS:
            return {"success": False, "error": f"Unknown tool: {tool}"}
        
        tool_info = SCREEN_SHARE_TOOLS[tool]
        
        if not self.check_app_installed(tool_info["command"]):
            return {"success": False, "error": f"{tool_info['name']} not installed"}
        
        try:
            if tool == "x11vnc":
                cmd = ["x11vnc", "-display", os.environ.get("DISPLAY", ":0"), 
                       "-rfbport", str(port), "-forever", "-shared"]
            elif tool == "wayvnc":
                cmd = ["wayvnc", "0.0.0.0", str(port)]
            else:
                cmd = [tool_info["command"]]
            
            self.share_process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.screen_sharing_active = True
            
            self.logger.info(f"Screen sharing started on port {port}")
            return {"success": True, "port": port, "tool": tool}
            
        except Exception as e:
            self.logger.error(f"Failed to start screen sharing: {e}")
            return {"success": False, "error": str(e)}
    
    def stop_screen_sharing(self) -> bool:
        if not self.screen_sharing_active or not self.share_process:
            return False
        
        try:
            self.share_process.terminate()
            self.share_process.wait(timeout=5)
            self.screen_sharing_active = False
            self.logger.info("Screen sharing stopped")
            return True
        except Exception as e:
            self.logger.error(f"Failed to stop screen sharing: {e}")
            return False
    
    def get_available_apps(self) -> Dict[str, List[Dict[str, Any]]]:
        conferencing = []
        for app_id, app_info in CONFERENCING_APPS.items():
            installed = app_info["command"] and self.check_app_installed(app_info["command"])
            conferencing.append({
                "id": app_id,
                "name": app_info["name"],
                "installed": installed,
                "has_web": True
            })
        
        return {"conferencing": conferencing, "screen_share": list(SCREEN_SHARE_TOOLS.keys())}
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            print("GTK not available. Use --cli mode.")
            return self.run_cli()
        
        win = CollaborationWindow(self)
        win.connect("destroy", Gtk.main_quit)
        win.show_all()
        Gtk.main()
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"  License Tier: {'WORKPLACE+' if self.license_tier >= LicenseTier.WORKPLACE else 'LIMITED'}")
        print(f"{'='*60}\n")
        
        print("Video Conferencing Apps:")
        for app_id, app_info in CONFERENCING_APPS.items():
            installed = "✓" if app_info["command"] and self.check_app_installed(app_info["command"]) else "Web only"
            print(f"  {app_info['name']}: {installed}")
        
        print("\nScreen Sharing Tools:")
        for tool_id, tool_info in SCREEN_SHARE_TOOLS.items():
            installed = "✓" if self.check_app_installed(tool_info["command"]) else "✗"
            print(f"  {tool_info['name']}: {installed}")
        
        if self.license_tier < LicenseTier.WORKPLACE:
            print("\n⚠ Upgrade to Workplace edition for collaboration features")


if GTK_AVAILABLE:
    class CollaborationWindow(Gtk.Window):
        def __init__(self, app: AegisCollaboration):
            super().__init__(title=f"{APP_NAME} v{VERSION}")
            self.app = app
            self.set_default_size(800, 600)
            self.set_border_width(10)
            self.setup_ui()
        
        def setup_ui(self):
            vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            self.add(vbox)
            
            header = Gtk.Label()
            header.set_markup(f"<big><b>{APP_NAME}</b></big>")
            vbox.pack_start(header, False, False, 10)
            
            notebook = Gtk.Notebook()
            vbox.pack_start(notebook, True, True, 0)
            
            notebook.append_page(self.create_conferencing_tab(), Gtk.Label(label="Video Conferencing"))
            notebook.append_page(self.create_screenshare_tab(), Gtk.Label(label="Screen Sharing"))
        
        def create_conferencing_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            for app_id, app_info in CONFERENCING_APPS.items():
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
                label = Gtk.Label(label=app_info["name"])
                label.set_xalign(0)
                hbox.pack_start(label, True, True, 10)
                
                btn = Gtk.Button(label="Launch")
                btn.connect("clicked", self.on_launch_app, app_id)
                btn.set_sensitive(self.app.license_tier >= LicenseTier.WORKPLACE)
                hbox.pack_end(btn, False, False, 10)
                
                box.pack_start(hbox, False, False, 5)
            
            return box
        
        def create_screenshare_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(20)
            box.set_margin_start(20)
            
            self.share_btn = Gtk.Button(label="Start Screen Sharing")
            self.share_btn.connect("clicked", self.on_toggle_share)
            self.share_btn.set_sensitive(self.app.license_tier >= LicenseTier.WORKPLACE)
            box.pack_start(self.share_btn, False, False, 20)
            
            self.share_status = Gtk.Label(label="Screen sharing inactive")
            box.pack_start(self.share_status, False, False, 10)
            
            return box
        
        def on_launch_app(self, button, app_id):
            self.app.launch_conferencing_app(app_id)
        
        def on_toggle_share(self, button):
            if not self.app.screen_sharing_active:
                result = self.app.start_screen_sharing()
                if result["success"]:
                    self.share_btn.set_label("Stop Screen Sharing")
                    self.share_status.set_text(f"Sharing on port {result['port']}")
                else:
                    self.share_status.set_text(f"Error: {result.get('error')}")
            else:
                self.app.stop_screen_sharing()
                self.share_btn.set_label("Start Screen Sharing")
                self.share_status.set_text("Screen sharing stopped")


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME}")
    parser.add_argument("--gui", action="store_true", help="Launch GUI mode")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode")
    parser.add_argument("--launch", metavar="APP", help="Launch conferencing app")
    parser.add_argument("--start-share", action="store_true", help="Start screen sharing")
    parser.add_argument("--stop-share", action="store_true", help="Stop screen sharing")
    parser.add_argument("--list-apps", action="store_true", help="List available apps")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.launch:
        app = AegisCollaboration(headless=True)
        app.launch_conferencing_app(args.launch)
    elif args.start_share:
        app = AegisCollaboration(headless=True)
        result = app.start_screen_sharing()
        print(json.dumps(result, indent=2))
    elif args.stop_share:
        app = AegisCollaboration(headless=True)
        result = app.stop_screen_sharing()
        print("Stopped" if result else "Failed")
    elif args.list_apps:
        app = AegisCollaboration(headless=True)
        print(json.dumps(app.get_available_apps(), indent=2))
    elif args.cli or not GTK_AVAILABLE:
        app = AegisCollaboration(headless=False)
        app.run_cli()
    else:
        app = AegisCollaboration(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
