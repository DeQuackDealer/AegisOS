#!/usr/bin/env python3
"""
Aegis OS Wine Optimizer - Comprehensive Wine/Proton Configuration Tool
Auto-detects Wine versions, configures optimal prefixes, and installs dependencies

Features:
- Auto-detect installed Wine versions (Wine, Wine-GE, Proton, GE-Proton)
- Configure optimal Wine prefixes for different use cases
- Install common dependencies (vcrun, dotnet, directx, etc.)
- CLI and GUI (tkinter) modes
- Tier-gated features (GAMER/GAMER_AI/SERVER get full features)
- Winetricks integration for common fixes
- Benchmark Windows application performance
"""

import os
import sys
import json
import subprocess
import shutil
import logging
import argparse
import threading
import time
import re
import tempfile
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
import urllib.request
import hashlib

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
    from tkinter.scrolledtext import ScrolledText
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False


class LicenseTier(Enum):
    FREEMIUM = 1
    BASIC = 2
    GAMER = 3
    GAMER_AI = 4
    SERVER = 5


@dataclass
class WineVersion:
    name: str
    path: str
    version: str
    type: str
    arch: str
    features: List[str] = field(default_factory=list)


@dataclass
class WinePrefix:
    name: str
    path: str
    arch: str
    windows_version: str
    created: str
    last_used: str
    dependencies: List[str] = field(default_factory=list)
    apps: List[str] = field(default_factory=list)


@dataclass
class BenchmarkResult:
    app_name: str
    timestamp: str
    fps_avg: float
    fps_min: float
    fps_max: float
    frame_time_avg: float
    cpu_usage: float
    gpu_usage: float
    memory_usage: float
    score: float


class AegisWineOptimizer:
    """Main Wine optimizer class"""
    
    VERSION = "1.5.0"
    APP_NAME = "Aegis Wine Optimizer"
    
    FULL_FEATURE_TIERS = [LicenseTier.GAMER, LicenseTier.GAMER_AI, LicenseTier.SERVER]
    
    COMMON_DEPENDENCIES = {
        "vcrun2019": {"name": "Visual C++ 2015-2022 Redistributable", "critical": True},
        "vcrun2017": {"name": "Visual C++ 2017 Redistributable", "critical": True},
        "vcrun2015": {"name": "Visual C++ 2015 Redistributable", "critical": True},
        "vcrun2013": {"name": "Visual C++ 2013 Redistributable", "critical": False},
        "vcrun2012": {"name": "Visual C++ 2012 Redistributable", "critical": False},
        "vcrun2010": {"name": "Visual C++ 2010 Redistributable", "critical": False},
        "vcrun2008": {"name": "Visual C++ 2008 Redistributable", "critical": False},
        "vcrun6": {"name": "Visual C++ 6 Redistributable", "critical": False},
        "dotnet48": {"name": ".NET Framework 4.8", "critical": True},
        "dotnet472": {"name": ".NET Framework 4.7.2", "critical": False},
        "dotnet462": {"name": ".NET Framework 4.6.2", "critical": False},
        "dotnet40": {"name": ".NET Framework 4.0", "critical": False},
        "dotnet35": {"name": ".NET Framework 3.5", "critical": False},
        "dotnet20": {"name": ".NET Framework 2.0", "critical": False},
        "dotnetcore3": {"name": ".NET Core 3.1", "critical": False},
        "dotnetdesktop6": {"name": ".NET Desktop Runtime 6.0", "critical": False},
        "dxvk": {"name": "DXVK (Vulkan-based D3D9/10/11)", "critical": True},
        "d3dx9": {"name": "DirectX 9 (d3dx9)", "critical": True},
        "d3dx10": {"name": "DirectX 10", "critical": False},
        "d3dx11_43": {"name": "DirectX 11", "critical": False},
        "d3dcompiler_47": {"name": "D3D Compiler", "critical": True},
        "physx": {"name": "NVIDIA PhysX", "critical": False},
        "xna40": {"name": "XNA Framework 4.0", "critical": False},
        "xact": {"name": "DirectX Audio (XACT)", "critical": False},
        "xinput": {"name": "XInput (Controller Support)", "critical": True},
        "faudio": {"name": "FAudio", "critical": True},
        "mf": {"name": "Media Foundation", "critical": False},
        "quartz": {"name": "DirectShow (Quartz)", "critical": False},
        "corefonts": {"name": "Microsoft Core Fonts", "critical": True},
        "tahoma": {"name": "Tahoma Font", "critical": False},
        "arial": {"name": "Arial Font", "critical": False},
        "times": {"name": "Times New Roman Font", "critical": False},
        "allfonts": {"name": "All Common Fonts", "critical": False}
    }
    
    WINDOWS_VERSIONS = {
        "win11": "Windows 11",
        "win10": "Windows 10",
        "win81": "Windows 8.1",
        "win8": "Windows 8",
        "win7": "Windows 7",
        "vista": "Windows Vista",
        "winxp64": "Windows XP (64-bit)",
        "winxp": "Windows XP (32-bit)",
        "win2k": "Windows 2000",
        "win98": "Windows 98"
    }
    
    PREFIX_TEMPLATES = {
        "gaming": {
            "name": "Gaming",
            "description": "Optimized for games with DXVK and gaming dependencies",
            "arch": "win64",
            "windows_version": "win10",
            "dependencies": ["vcrun2019", "dxvk", "d3dx9", "d3dcompiler_47", "xinput", "faudio", "physx", "corefonts"]
        },
        "productivity": {
            "name": "Productivity",
            "description": "For Office, Adobe, and productivity applications",
            "arch": "win64",
            "windows_version": "win10",
            "dependencies": ["vcrun2019", "dotnet48", "corefonts", "allfonts", "mf", "quartz"]
        },
        "development": {
            "name": "Development",
            "description": "For Visual Studio and development tools",
            "arch": "win64",
            "windows_version": "win10",
            "dependencies": ["vcrun2019", "dotnet48", "dotnetcore3", "dotnetdesktop6", "corefonts"]
        },
        "legacy_gaming": {
            "name": "Legacy Gaming",
            "description": "For older games (DirectX 9 era)",
            "arch": "win32",
            "windows_version": "winxp",
            "dependencies": ["vcrun2010", "vcrun2008", "vcrun6", "d3dx9", "physx", "xna40"]
        },
        "minimal": {
            "name": "Minimal",
            "description": "Bare minimum prefix for testing",
            "arch": "win64",
            "windows_version": "win10",
            "dependencies": ["corefonts"]
        },
        "retro": {
            "name": "Retro",
            "description": "For Windows 98/2000 era applications",
            "arch": "win32",
            "windows_version": "win98",
            "dependencies": ["vcrun6", "corefonts"]
        }
    }
    
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = self.VERSION
        
        self.config_dir = Path("/etc/aegis")
        self.data_dir = Path("/var/lib/aegis/wine")
        self.log_dir = Path("/var/log/aegis")
        self.cache_dir = Path.home() / ".cache" / "aegis" / "wine"
        
        self.config_file = self.config_dir / "wine-optimizer.json"
        self.prefixes_file = self.data_dir / "prefixes.json"
        self.license_file = self.config_dir / "license.json"
        self.wine_config_file = self.config_dir / "wine-optimization.conf"
        
        self.home_dir = Path.home()
        self.user_prefixes_dir = self.home_dir / ".local" / "share" / "aegis" / "wine-prefixes"
        
        self.wine_versions: Dict[str, WineVersion] = {}
        self.prefixes: Dict[str, WinePrefix] = {}
        self.license_tier = LicenseTier.FREEMIUM
        
        self.winetricks_available = False
        self.cabextract_available = False
        
        self.ensure_directories()
        self.setup_logging()
        self.check_system_capabilities()
        self.load_license_tier()
        self.load_config()
        self.detect_wine_versions()
        self.load_prefixes()
        
    def ensure_directories(self):
        """Create required directories"""
        dirs = [
            self.data_dir, self.log_dir, self.cache_dir, self.user_prefixes_dir
        ]
        for directory in dirs:
            try:
                directory.mkdir(parents=True, exist_ok=True)
            except PermissionError:
                pass
    
    def setup_logging(self):
        """Configure logging"""
        log_file = self.log_dir / "wine-optimizer.log"
        try:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[
                    logging.FileHandler(log_file),
                    logging.StreamHandler() if not self.headless else logging.NullHandler()
                ]
            )
        except PermissionError:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[logging.StreamHandler()]
            )
        self.logger = logging.getLogger("AegisWineOptimizer")
        self.logger.info(f"Starting {self.APP_NAME} v{self.VERSION}")
    
    def check_system_capabilities(self):
        """Check for available tools"""
        self.winetricks_available = shutil.which("winetricks") is not None
        self.cabextract_available = shutil.which("cabextract") is not None
        self.wine_available = shutil.which("wine") is not None
        self.wine64_available = shutil.which("wine64") is not None
        
        self.logger.info(f"Wine available: {self.wine_available}")
        self.logger.info(f"Wine64 available: {self.wine64_available}")
        self.logger.info(f"Winetricks available: {self.winetricks_available}")
        self.logger.info(f"Cabextract available: {self.cabextract_available}")
    
    def load_license_tier(self):
        """Load and determine license tier"""
        try:
            if self.license_file.exists():
                with open(self.license_file, 'r') as f:
                    license_data = json.load(f)
                
                edition = license_data.get('edition', 'freemium').lower()
                tier_map = {
                    'freemium': LicenseTier.FREEMIUM,
                    'basic': LicenseTier.BASIC,
                    'gamer': LicenseTier.GAMER,
                    'gamer-ai': LicenseTier.GAMER_AI,
                    'gamer_ai': LicenseTier.GAMER_AI,
                    'server': LicenseTier.SERVER
                }
                self.license_tier = tier_map.get(edition, LicenseTier.FREEMIUM)
            else:
                marker_files = [
                    (Path("/etc/aegis-gamer-ai-marker"), LicenseTier.GAMER_AI),
                    (Path("/etc/aegis-gamer-marker"), LicenseTier.GAMER),
                    (Path("/etc/aegis-server-marker"), LicenseTier.SERVER),
                    (Path("/etc/aegis-basic-marker"), LicenseTier.BASIC),
                    (Path("/etc/aegis-freemium-marker"), LicenseTier.FREEMIUM),
                ]
                for marker, tier in marker_files:
                    if marker.exists():
                        self.license_tier = tier
                        break
                        
        except Exception as e:
            self.logger.warning(f"Failed to load license tier: {e}")
            self.license_tier = LicenseTier.FREEMIUM
        
        self.logger.info(f"License tier: {self.license_tier.name}")
    
    def is_full_version(self) -> bool:
        """Check if running full version with all features"""
        return self.license_tier in self.FULL_FEATURE_TIERS
    
    def check_feature_access(self, feature: str) -> Tuple[bool, str]:
        """Check if user has access to a feature"""
        basic_features = ["wine_basic", "create_prefix", "list_versions"]
        gamer_features = ["dxvk", "vkd3d", "winetricks", "dependencies", "benchmarks", 
                         "per_game_profiles", "advanced_options", "templates"]
        
        if self.license_tier == LicenseTier.FREEMIUM:
            return False, "Wine/Proton features require BASIC edition or higher. Upgrade at: https://aegis-os.com/pricing"
        
        if feature in gamer_features and self.license_tier == LicenseTier.BASIC:
            return False, f"'{feature}' requires GAMER edition or higher. Upgrade at: https://aegis-os.com/pricing"
        
        return True, ""
    
    def load_config(self):
        """Load optimizer configuration"""
        default_config = {
            "default_arch": "win64",
            "default_windows_version": "win10",
            "auto_install_dependencies": True,
            "winetricks_silent": True,
            "shader_cache_enabled": True,
            "dxvk_async": True,
            "fsync_enabled": True,
            "esync_enabled": True,
            "gamemode_enabled": True,
            "mangohud_enabled": False,
            "last_scan": None
        }
        
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    self.config = {**default_config, **json.load(f)}
            else:
                self.config = default_config
        except Exception as e:
            self.logger.error(f"Error loading config: {e}")
            self.config = default_config
    
    def save_config(self):
        """Save configuration"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
        except PermissionError:
            self.logger.warning("Cannot save config - permission denied")
    
    def detect_wine_versions(self):
        """Detect all installed Wine versions"""
        self.wine_versions.clear()
        
        wine_paths = [
            "/usr/bin/wine",
            "/usr/bin/wine64",
            "/opt/wine-stable/bin/wine",
            "/opt/wine-staging/bin/wine",
            "/opt/wine-devel/bin/wine",
            str(self.home_dir / ".local/bin/wine"),
        ]
        
        ge_wine_dirs = [
            self.home_dir / ".local/share/lutris/runners/wine",
            Path("/opt/wine-ge"),
            self.home_dir / "Games/wine-ge",
        ]
        
        proton_dirs = [
            self.home_dir / ".local/share/Steam/compatibilitytools.d",
            self.home_dir / ".steam/steam/compatibilitytools.d",
            Path("/usr/share/steam/compatibilitytools.d"),
        ]
        
        for wine_path in wine_paths:
            if Path(wine_path).exists():
                self._add_wine_version(wine_path)
        
        for ge_dir in ge_wine_dirs:
            if ge_dir.exists():
                for version_dir in ge_dir.iterdir():
                    if version_dir.is_dir():
                        wine_bin = version_dir / "bin" / "wine"
                        if wine_bin.exists():
                            self._add_wine_version(str(wine_bin), wine_type="wine-ge")
        
        for proton_dir in proton_dirs:
            if proton_dir.exists():
                for version_dir in proton_dir.iterdir():
                    if version_dir.is_dir():
                        proton_script = version_dir / "proton"
                        if proton_script.exists():
                            self._add_proton_version(str(version_dir))
        
        self.logger.info(f"Detected {len(self.wine_versions)} Wine/Proton versions")
    
    def _add_wine_version(self, wine_path: str, wine_type: str = "wine"):
        """Add a Wine version to the detected list"""
        try:
            result = subprocess.run([wine_path, "--version"], capture_output=True, text=True, timeout=10)
            version = result.stdout.strip() if result.returncode == 0 else "unknown"
            
            path = Path(wine_path)
            name = path.parent.parent.name if wine_type == "wine-ge" else wine_type
            
            arch_check = subprocess.run([wine_path + "64" if Path(wine_path + "64").exists() else wine_path, 
                                        "--version"], capture_output=True, text=True, timeout=10)
            arch = "win64" if "64" in wine_path or Path(wine_path + "64").exists() else "win32"
            
            features = []
            if "staging" in wine_path.lower() or "staging" in version.lower():
                features.append("staging")
            if wine_type == "wine-ge":
                features.extend(["dxvk", "vkd3d", "fsync"])
            
            wine_version = WineVersion(
                name=name,
                path=wine_path,
                version=version,
                type=wine_type,
                arch=arch,
                features=features
            )
            
            self.wine_versions[wine_path] = wine_version
            
        except Exception as e:
            self.logger.warning(f"Failed to detect Wine version at {wine_path}: {e}")
    
    def _add_proton_version(self, proton_dir: str):
        """Add a Proton version to the detected list"""
        try:
            path = Path(proton_dir)
            name = path.name
            
            version_file = path / "version"
            if version_file.exists():
                version = version_file.read_text().strip()
            else:
                version = name
            
            proton_type = "proton"
            if "GE" in name:
                proton_type = "ge-proton"
            elif "experimental" in name.lower():
                proton_type = "proton-experimental"
            
            features = ["dxvk", "vkd3d", "fsync", "esync"]
            if "GE" in name:
                features.extend(["wine-ge", "additional-patches"])
            
            wine_version = WineVersion(
                name=name,
                path=proton_dir,
                version=version,
                type=proton_type,
                arch="win64",
                features=features
            )
            
            self.wine_versions[proton_dir] = wine_version
            
        except Exception as e:
            self.logger.warning(f"Failed to detect Proton version at {proton_dir}: {e}")
    
    def load_prefixes(self):
        """Load saved prefix information"""
        try:
            if self.prefixes_file.exists():
                with open(self.prefixes_file, 'r') as f:
                    data = json.load(f)
                    for prefix_name, prefix_data in data.get('prefixes', {}).items():
                        self.prefixes[prefix_name] = WinePrefix(**prefix_data)
        except Exception as e:
            self.logger.error(f"Error loading prefixes: {e}")
    
    def save_prefixes(self):
        """Save prefix information"""
        try:
            data = {
                'version': self.VERSION,
                'last_updated': datetime.now().isoformat(),
                'prefixes': {name: asdict(p) for name, p in self.prefixes.items()}
            }
            self.prefixes_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.prefixes_file, 'w') as f:
                json.dump(data, f, indent=2)
        except PermissionError:
            self.logger.warning("Cannot save prefixes - permission denied")
    
    def create_prefix(self, name: str, template: str = "gaming", 
                     custom_path: Optional[str] = None,
                     arch: Optional[str] = None,
                     windows_version: Optional[str] = None) -> Tuple[bool, str]:
        """Create a new Wine prefix"""
        
        can_access, message = self.check_feature_access("create_prefix")
        if not can_access:
            return False, message
        
        if not self.is_full_version():
            can_access, message = self.check_feature_access("templates")
            if not can_access and template not in ["minimal", "gaming"]:
                return False, f"Template '{template}' requires GAMER edition. Using 'minimal' instead."
        
        template_config = self.PREFIX_TEMPLATES.get(template, self.PREFIX_TEMPLATES["minimal"])
        
        prefix_path = Path(custom_path) if custom_path else self.user_prefixes_dir / name
        prefix_arch = arch or template_config["arch"]
        prefix_winver = windows_version or template_config["windows_version"]
        
        if prefix_path.exists():
            return False, f"Prefix already exists at {prefix_path}"
        
        self.logger.info(f"Creating Wine prefix: {name} at {prefix_path}")
        
        try:
            prefix_path.mkdir(parents=True, exist_ok=True)
            
            env = os.environ.copy()
            env["WINEPREFIX"] = str(prefix_path)
            env["WINEARCH"] = prefix_arch
            
            wine_cmd = "wine64" if prefix_arch == "win64" and self.wine64_available else "wine"
            
            subprocess.run(
                [wine_cmd, "wineboot", "--init"],
                env=env,
                capture_output=True,
                timeout=120
            )
            
            self._set_windows_version(prefix_path, prefix_winver)
            
            if self.is_full_version() and template_config.get("dependencies"):
                self.install_dependencies(prefix_path, template_config["dependencies"])
            
            prefix = WinePrefix(
                name=name,
                path=str(prefix_path),
                arch=prefix_arch,
                windows_version=prefix_winver,
                created=datetime.now().isoformat(),
                last_used=datetime.now().isoformat(),
                dependencies=template_config.get("dependencies", []),
                apps=[]
            )
            
            self.prefixes[name] = prefix
            self.save_prefixes()
            
            return True, f"Successfully created prefix '{name}' at {prefix_path}"
            
        except subprocess.TimeoutExpired:
            return False, "Prefix creation timed out"
        except Exception as e:
            return False, f"Failed to create prefix: {e}"
    
    def _set_windows_version(self, prefix_path: Path, version: str):
        """Set the Windows version for a prefix"""
        try:
            env = os.environ.copy()
            env["WINEPREFIX"] = str(prefix_path)
            
            if self.winetricks_available:
                subprocess.run(
                    ["winetricks", "-q", version],
                    env=env,
                    capture_output=True,
                    timeout=60
                )
            else:
                wine_cmd = "wine64" if (prefix_path / "drive_c" / "windows" / "syswow64").exists() else "wine"
                subprocess.run(
                    [wine_cmd, "winecfg", "-v", version],
                    env=env,
                    capture_output=True,
                    timeout=60
                )
                
        except Exception as e:
            self.logger.warning(f"Failed to set Windows version: {e}")
    
    def install_dependencies(self, prefix_path: Path, dependencies: List[str], 
                            progress_callback=None) -> Tuple[bool, List[str]]:
        """Install dependencies using winetricks"""
        
        can_access, message = self.check_feature_access("dependencies")
        if not can_access:
            return False, [message]
        
        if not self.winetricks_available:
            return False, ["Winetricks not installed. Install with: sudo apt install winetricks"]
        
        results = []
        total = len(dependencies)
        
        for i, dep in enumerate(dependencies):
            if dep not in self.COMMON_DEPENDENCIES:
                results.append(f"Unknown dependency: {dep}")
                continue
            
            if progress_callback:
                progress_callback(i + 1, total, f"Installing {self.COMMON_DEPENDENCIES[dep]['name']}...")
            
            try:
                env = os.environ.copy()
                env["WINEPREFIX"] = str(prefix_path)
                
                cmd = ["winetricks", "-q", dep]
                
                result = subprocess.run(
                    cmd,
                    env=env,
                    capture_output=True,
                    text=True,
                    timeout=600
                )
                
                if result.returncode == 0:
                    results.append(f"‚úì {self.COMMON_DEPENDENCIES[dep]['name']}")
                else:
                    results.append(f"‚úó {self.COMMON_DEPENDENCIES[dep]['name']}: {result.stderr[:100]}")
                    
            except subprocess.TimeoutExpired:
                results.append(f"‚úó {dep}: Installation timed out")
            except Exception as e:
                results.append(f"‚úó {dep}: {str(e)}")
        
        return True, results
    
    def run_benchmark(self, prefix_path: Path, app_path: str, 
                     duration: int = 60) -> Optional[BenchmarkResult]:
        """Run a performance benchmark on a Windows application"""
        
        can_access, message = self.check_feature_access("benchmarks")
        if not can_access:
            self.logger.warning(message)
            return None
        
        self.logger.info(f"Starting benchmark: {app_path} for {duration}s")
        
        env = os.environ.copy()
        env["WINEPREFIX"] = str(prefix_path)
        env["DXVK_HUD"] = "fps,frametimes,memory"
        env["MANGOHUD"] = "1"
        
        try:
            start_time = time.time()
            
            wine_cmd = "wine64" if (prefix_path / "drive_c" / "windows" / "syswow64").exists() else "wine"
            
            process = subprocess.Popen(
                [wine_cmd, app_path],
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            fps_samples = []
            cpu_samples = []
            
            while time.time() - start_time < duration and process.poll() is None:
                time.sleep(1)
            
            if process.poll() is None:
                process.terminate()
                process.wait(timeout=5)
            
            avg_fps = sum(fps_samples) / len(fps_samples) if fps_samples else 0
            min_fps = min(fps_samples) if fps_samples else 0
            max_fps = max(fps_samples) if fps_samples else 0
            avg_cpu = sum(cpu_samples) / len(cpu_samples) if cpu_samples else 0
            
            score = avg_fps * 10
            
            result = BenchmarkResult(
                app_name=Path(app_path).name,
                timestamp=datetime.now().isoformat(),
                fps_avg=avg_fps,
                fps_min=min_fps,
                fps_max=max_fps,
                frame_time_avg=1000.0 / avg_fps if avg_fps > 0 else 0,
                cpu_usage=avg_cpu,
                gpu_usage=0,
                memory_usage=0,
                score=score
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"Benchmark failed: {e}")
            return None
    
    def optimize_prefix(self, prefix_path: Path) -> Tuple[bool, str]:
        """Apply optimizations to a Wine prefix"""
        
        can_access, message = self.check_feature_access("advanced_options")
        if not can_access:
            return False, message
        
        self.logger.info(f"Optimizing prefix: {prefix_path}")
        
        try:
            env = os.environ.copy()
            env["WINEPREFIX"] = str(prefix_path)
            
            reg_file = tempfile.NamedTemporaryFile(mode='w', suffix='.reg', delete=False)
            reg_content = """REGEDIT4

[HKEY_CURRENT_USER\\Software\\Wine\\Direct3D]
"UseGLSL"="enabled"
"DirectDrawRenderer"="opengl"
"csmt"=dword:00000003

[HKEY_CURRENT_USER\\Software\\Wine\\DllOverrides]
"winemenubuilder.exe"=""

[HKEY_CURRENT_USER\\Control Panel\\Desktop]
"FontSmoothing"="2"
"FontSmoothingType"=dword:00000002
"FontSmoothingGamma"=dword:00000578
"FontSmoothingOrientation"=dword:00000001

[HKEY_CURRENT_USER\\Software\\Wine\\X11 Driver]
"GrabFullscreen"="Y"
"UseTakeFocus"="N"

"""
            reg_file.write(reg_content)
            reg_file.close()
            
            wine_cmd = "wine64" if (prefix_path / "drive_c" / "windows" / "syswow64").exists() else "wine"
            subprocess.run(
                [wine_cmd, "regedit", reg_file.name],
                env=env,
                capture_output=True,
                timeout=30
            )
            
            os.unlink(reg_file.name)
            
            return True, "Prefix optimized successfully"
            
        except Exception as e:
            return False, f"Optimization failed: {e}"
    
    def list_versions(self) -> str:
        """List all detected Wine/Proton versions"""
        output = ["Detected Wine/Proton Versions:", "=" * 50]
        
        for path, version in self.wine_versions.items():
            features = ", ".join(version.features) if version.features else "none"
            output.append(f"\n{version.name}")
            output.append(f"  Path: {version.path}")
            output.append(f"  Version: {version.version}")
            output.append(f"  Type: {version.type}")
            output.append(f"  Architecture: {version.arch}")
            output.append(f"  Features: {features}")
        
        if not self.wine_versions:
            output.append("\nNo Wine/Proton versions detected.")
            output.append("Install Wine with: sudo apt install wine64")
        
        return "\n".join(output)
    
    def list_prefixes(self) -> str:
        """List all Wine prefixes"""
        output = ["Wine Prefixes:", "=" * 50]
        
        default_prefix = self.home_dir / ".wine"
        if default_prefix.exists() and ".wine" not in self.prefixes:
            output.append(f"\ndefault (system)")
            output.append(f"  Path: {default_prefix}")
            output.append(f"  Status: exists")
        
        for name, prefix in self.prefixes.items():
            exists = Path(prefix.path).exists()
            output.append(f"\n{name}")
            output.append(f"  Path: {prefix.path}")
            output.append(f"  Architecture: {prefix.arch}")
            output.append(f"  Windows Version: {prefix.windows_version}")
            output.append(f"  Created: {prefix.created}")
            output.append(f"  Status: {'exists' if exists else 'missing'}")
            if prefix.dependencies:
                output.append(f"  Dependencies: {', '.join(prefix.dependencies[:5])}...")
        
        if not self.prefixes and not default_prefix.exists():
            output.append("\nNo Wine prefixes found.")
        
        return "\n".join(output)
    
    def print_status(self):
        """Print current status"""
        print(f"\n{'=' * 60}")
        print(f"  {self.APP_NAME} v{self.VERSION}")
        print(f"{'=' * 60}")
        print(f"\nLicense Tier: {self.license_tier.name}")
        print(f"Full Features: {'Yes' if self.is_full_version() else 'No'}")
        print(f"\nSystem Capabilities:")
        print(f"  Wine: {'‚úì' if self.wine_available else '‚úó'}")
        print(f"  Wine64: {'‚úì' if self.wine64_available else '‚úó'}")
        print(f"  Winetricks: {'‚úì' if self.winetricks_available else '‚úó'}")
        print(f"  Cabextract: {'‚úì' if self.cabextract_available else '‚úó'}")
        print(f"\nDetected Versions: {len(self.wine_versions)}")
        print(f"Configured Prefixes: {len(self.prefixes)}")
        
        if not self.is_full_version():
            print(f"\n‚ö†Ô∏è  Upgrade to GAMER edition for full features:")
            print(f"   - DXVK/VKD3D integration")
            print(f"   - Winetricks dependency management")
            print(f"   - Performance benchmarking")
            print(f"   - Prefix templates")
            print(f"   Visit: https://aegis-os.com/pricing")


class WineOptimizerGUI:
    """Tkinter GUI for Wine Optimizer"""
    
    def __init__(self, optimizer: AegisWineOptimizer):
        self.optimizer = optimizer
        
        self.root = tk.Tk()
        self.root.title(f"{optimizer.APP_NAME} v{optimizer.VERSION}")
        self.root.geometry("900x700")
        self.root.minsize(800, 600)
        
        self.style = ttk.Style()
        self.style.theme_use('clam')
        
        self.setup_ui()
        
    def setup_ui(self):
        """Setup the GUI"""
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(header_frame, text=f"üç∑ {self.optimizer.APP_NAME}", 
                 font=('Helvetica', 16, 'bold')).pack(side=tk.LEFT)
        
        tier_text = f"Tier: {self.optimizer.license_tier.name}"
        tier_color = "green" if self.optimizer.is_full_version() else "orange"
        tier_label = ttk.Label(header_frame, text=tier_text, foreground=tier_color)
        tier_label.pack(side=tk.RIGHT)
        
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        versions_tab = ttk.Frame(notebook)
        notebook.add(versions_tab, text="Wine Versions")
        self.setup_versions_tab(versions_tab)
        
        prefixes_tab = ttk.Frame(notebook)
        notebook.add(prefixes_tab, text="Prefixes")
        self.setup_prefixes_tab(prefixes_tab)
        
        dependencies_tab = ttk.Frame(notebook)
        notebook.add(dependencies_tab, text="Dependencies")
        self.setup_dependencies_tab(dependencies_tab)
        
        benchmarks_tab = ttk.Frame(notebook)
        notebook.add(benchmarks_tab, text="Benchmarks")
        self.setup_benchmarks_tab(benchmarks_tab)
        
        status_frame = ttk.Frame(main_frame)
        status_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.status_var = tk.StringVar(value="Ready")
        ttk.Label(status_frame, textvariable=self.status_var).pack(side=tk.LEFT)
        
        ttk.Button(status_frame, text="Refresh", 
                  command=self.refresh_all).pack(side=tk.RIGHT)
    
    def setup_versions_tab(self, parent):
        """Setup Wine versions tab"""
        frame = ttk.LabelFrame(parent, text="Detected Wine/Proton Versions", padding="10")
        frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        columns = ("Name", "Version", "Type", "Architecture", "Features")
        self.versions_tree = ttk.Treeview(frame, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.versions_tree.heading(col, text=col)
            self.versions_tree.column(col, width=150)
        
        scrollbar = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=self.versions_tree.yview)
        self.versions_tree.configure(yscrollcommand=scrollbar.set)
        
        self.versions_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        btn_frame = ttk.Frame(parent)
        btn_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(btn_frame, text="Scan for Versions", 
                  command=self.scan_versions).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Download GE-Proton", 
                  command=self.download_ge_proton).pack(side=tk.LEFT, padx=5)
        
        self.refresh_versions()
    
    def setup_prefixes_tab(self, parent):
        """Setup prefixes tab"""
        list_frame = ttk.LabelFrame(parent, text="Wine Prefixes", padding="10")
        list_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        columns = ("Name", "Path", "Architecture", "Windows", "Created")
        self.prefixes_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=10)
        
        for col in columns:
            self.prefixes_tree.heading(col, text=col)
            self.prefixes_tree.column(col, width=150)
        
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.prefixes_tree.yview)
        self.prefixes_tree.configure(yscrollcommand=scrollbar.set)
        
        self.prefixes_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        create_frame = ttk.LabelFrame(parent, text="Create New Prefix", padding="10")
        create_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(create_frame, text="Name:").grid(row=0, column=0, sticky=tk.W, padx=5)
        self.prefix_name_var = tk.StringVar()
        ttk.Entry(create_frame, textvariable=self.prefix_name_var, width=30).grid(row=0, column=1, padx=5)
        
        ttk.Label(create_frame, text="Template:").grid(row=0, column=2, sticky=tk.W, padx=5)
        self.template_var = tk.StringVar(value="gaming")
        templates = list(self.optimizer.PREFIX_TEMPLATES.keys())
        ttk.Combobox(create_frame, textvariable=self.template_var, 
                    values=templates, state="readonly", width=20).grid(row=0, column=3, padx=5)
        
        ttk.Button(create_frame, text="Create Prefix", 
                  command=self.create_prefix).grid(row=0, column=4, padx=5)
        
        btn_frame = ttk.Frame(parent)
        btn_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(btn_frame, text="Optimize Selected", 
                  command=self.optimize_prefix).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Delete Selected", 
                  command=self.delete_prefix).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Open in File Manager", 
                  command=self.open_prefix_folder).pack(side=tk.LEFT, padx=5)
        
        self.refresh_prefixes()
    
    def setup_dependencies_tab(self, parent):
        """Setup dependencies tab"""
        if not self.optimizer.is_full_version():
            ttk.Label(parent, text="‚ö†Ô∏è Dependency management requires GAMER edition or higher",
                     font=('Helvetica', 12)).pack(pady=20)
            ttk.Button(parent, text="Upgrade Now", 
                      command=lambda: self.open_url("https://aegis-os.com/pricing")).pack()
            return
        
        left_frame = ttk.LabelFrame(parent, text="Available Dependencies", padding="10")
        left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.deps_listbox = tk.Listbox(left_frame, selectmode=tk.MULTIPLE, height=20)
        self.deps_listbox.pack(fill=tk.BOTH, expand=True)
        
        for dep_id, dep_info in self.optimizer.COMMON_DEPENDENCIES.items():
            critical = " [Critical]" if dep_info.get("critical") else ""
            self.deps_listbox.insert(tk.END, f"{dep_id} - {dep_info['name']}{critical}")
        
        right_frame = ttk.Frame(parent)
        right_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5, pady=5)
        
        ttk.Label(right_frame, text="Select Prefix:").pack(pady=5)
        
        self.deps_prefix_var = tk.StringVar()
        prefixes = list(self.optimizer.prefixes.keys())
        ttk.Combobox(right_frame, textvariable=self.deps_prefix_var, 
                    values=prefixes, state="readonly", width=25).pack(pady=5)
        
        ttk.Button(right_frame, text="Install Selected", 
                  command=self.install_dependencies).pack(pady=10)
        
        ttk.Button(right_frame, text="Install Critical Only", 
                  command=self.install_critical_deps).pack(pady=5)
        
        ttk.Button(right_frame, text="Install All", 
                  command=self.install_all_deps).pack(pady=5)
    
    def setup_benchmarks_tab(self, parent):
        """Setup benchmarks tab"""
        if not self.optimizer.is_full_version():
            ttk.Label(parent, text="‚ö†Ô∏è Benchmarking requires GAMER edition or higher",
                     font=('Helvetica', 12)).pack(pady=20)
            ttk.Button(parent, text="Upgrade Now", 
                      command=lambda: self.open_url("https://aegis-os.com/pricing")).pack()
            return
        
        config_frame = ttk.LabelFrame(parent, text="Benchmark Configuration", padding="10")
        config_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(config_frame, text="Select Prefix:").grid(row=0, column=0, padx=5)
        self.bench_prefix_var = tk.StringVar()
        prefixes = list(self.optimizer.prefixes.keys())
        ttk.Combobox(config_frame, textvariable=self.bench_prefix_var, 
                    values=prefixes, state="readonly", width=25).grid(row=0, column=1, padx=5)
        
        ttk.Label(config_frame, text="Application:").grid(row=0, column=2, padx=5)
        self.bench_app_var = tk.StringVar()
        ttk.Entry(config_frame, textvariable=self.bench_app_var, width=40).grid(row=0, column=3, padx=5)
        ttk.Button(config_frame, text="Browse", command=self.browse_app).grid(row=0, column=4, padx=5)
        
        ttk.Label(config_frame, text="Duration (s):").grid(row=1, column=0, padx=5, pady=5)
        self.bench_duration_var = tk.IntVar(value=60)
        ttk.Spinbox(config_frame, from_=10, to=300, textvariable=self.bench_duration_var, 
                   width=10).grid(row=1, column=1, padx=5, sticky=tk.W)
        
        ttk.Button(config_frame, text="Run Benchmark", 
                  command=self.run_benchmark).grid(row=1, column=3, padx=5)
        
        results_frame = ttk.LabelFrame(parent, text="Results", padding="10")
        results_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.results_text = ScrolledText(results_frame, height=15)
        self.results_text.pack(fill=tk.BOTH, expand=True)
    
    def refresh_all(self):
        """Refresh all data"""
        self.optimizer.detect_wine_versions()
        self.optimizer.load_prefixes()
        self.refresh_versions()
        self.refresh_prefixes()
        self.status_var.set("Refreshed")
    
    def refresh_versions(self):
        """Refresh versions list"""
        for item in self.versions_tree.get_children():
            self.versions_tree.delete(item)
        
        for path, version in self.optimizer.wine_versions.items():
            features = ", ".join(version.features[:3]) if version.features else "none"
            self.versions_tree.insert("", tk.END, values=(
                version.name, version.version, version.type, version.arch, features
            ))
    
    def refresh_prefixes(self):
        """Refresh prefixes list"""
        for item in self.prefixes_tree.get_children():
            self.prefixes_tree.delete(item)
        
        for name, prefix in self.optimizer.prefixes.items():
            created = prefix.created[:10] if prefix.created else "Unknown"
            self.prefixes_tree.insert("", tk.END, values=(
                name, prefix.path, prefix.arch, prefix.windows_version, created
            ))
    
    def scan_versions(self):
        """Scan for Wine versions"""
        self.status_var.set("Scanning...")
        self.root.update()
        self.optimizer.detect_wine_versions()
        self.refresh_versions()
        self.status_var.set(f"Found {len(self.optimizer.wine_versions)} versions")
    
    def download_ge_proton(self):
        """Download GE-Proton"""
        messagebox.showinfo("Download GE-Proton", 
            "GE-Proton downloads are available from:\n\n"
            "https://github.com/GloriousEggroll/proton-ge-custom/releases\n\n"
            "Extract to:\n~/.local/share/Steam/compatibilitytools.d/")
    
    def create_prefix(self):
        """Create a new prefix"""
        name = self.prefix_name_var.get().strip()
        template = self.template_var.get()
        
        if not name:
            messagebox.showerror("Error", "Please enter a prefix name")
            return
        
        self.status_var.set(f"Creating prefix '{name}'...")
        self.root.update()
        
        success, message = self.optimizer.create_prefix(name, template)
        
        if success:
            messagebox.showinfo("Success", message)
            self.refresh_prefixes()
        else:
            messagebox.showerror("Error", message)
        
        self.status_var.set("Ready")
    
    def optimize_prefix(self):
        """Optimize selected prefix"""
        selected = self.prefixes_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a prefix")
            return
        
        item = self.prefixes_tree.item(selected[0])
        prefix_path = Path(item['values'][1])
        
        self.status_var.set("Optimizing...")
        success, message = self.optimizer.optimize_prefix(prefix_path)
        
        if success:
            messagebox.showinfo("Success", message)
        else:
            messagebox.showerror("Error", message)
        
        self.status_var.set("Ready")
    
    def delete_prefix(self):
        """Delete selected prefix"""
        selected = self.prefixes_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a prefix")
            return
        
        item = self.prefixes_tree.item(selected[0])
        name = item['values'][0]
        
        if messagebox.askyesno("Confirm", f"Delete prefix '{name}'?\nThis cannot be undone."):
            prefix_path = Path(item['values'][1])
            try:
                if prefix_path.exists():
                    shutil.rmtree(prefix_path)
                if name in self.optimizer.prefixes:
                    del self.optimizer.prefixes[name]
                    self.optimizer.save_prefixes()
                self.refresh_prefixes()
                messagebox.showinfo("Success", f"Prefix '{name}' deleted")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to delete: {e}")
    
    def open_prefix_folder(self):
        """Open selected prefix in file manager"""
        selected = self.prefixes_tree.selection()
        if not selected:
            messagebox.showwarning("Warning", "Please select a prefix")
            return
        
        item = self.prefixes_tree.item(selected[0])
        prefix_path = item['values'][1]
        
        try:
            subprocess.Popen(["xdg-open", prefix_path])
        except Exception as e:
            messagebox.showerror("Error", f"Failed to open: {e}")
    
    def install_dependencies(self):
        """Install selected dependencies"""
        prefix_name = self.deps_prefix_var.get()
        if not prefix_name:
            messagebox.showwarning("Warning", "Please select a prefix")
            return
        
        selected_indices = self.deps_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Warning", "Please select dependencies to install")
            return
        
        deps = []
        for idx in selected_indices:
            item = self.deps_listbox.get(idx)
            dep_id = item.split(" - ")[0]
            deps.append(dep_id)
        
        prefix_path = Path(self.optimizer.prefixes[prefix_name].path)
        
        self.status_var.set("Installing dependencies...")
        self.root.update()
        
        success, results = self.optimizer.install_dependencies(prefix_path, deps)
        
        result_text = "\n".join(results)
        messagebox.showinfo("Installation Results", result_text)
        self.status_var.set("Ready")
    
    def install_critical_deps(self):
        """Install critical dependencies only"""
        prefix_name = self.deps_prefix_var.get()
        if not prefix_name:
            messagebox.showwarning("Warning", "Please select a prefix")
            return
        
        critical_deps = [dep_id for dep_id, info in self.optimizer.COMMON_DEPENDENCIES.items() 
                        if info.get("critical")]
        
        prefix_path = Path(self.optimizer.prefixes[prefix_name].path)
        
        self.status_var.set("Installing critical dependencies...")
        success, results = self.optimizer.install_dependencies(prefix_path, critical_deps)
        
        result_text = "\n".join(results)
        messagebox.showinfo("Installation Results", result_text)
        self.status_var.set("Ready")
    
    def install_all_deps(self):
        """Install all dependencies"""
        prefix_name = self.deps_prefix_var.get()
        if not prefix_name:
            messagebox.showwarning("Warning", "Please select a prefix")
            return
        
        if not messagebox.askyesno("Confirm", "Install ALL dependencies?\nThis may take a long time."):
            return
        
        all_deps = list(self.optimizer.COMMON_DEPENDENCIES.keys())
        prefix_path = Path(self.optimizer.prefixes[prefix_name].path)
        
        self.status_var.set("Installing all dependencies...")
        success, results = self.optimizer.install_dependencies(prefix_path, all_deps)
        
        result_text = "\n".join(results)
        messagebox.showinfo("Installation Results", result_text)
        self.status_var.set("Ready")
    
    def browse_app(self):
        """Browse for application"""
        filename = filedialog.askopenfilename(
            title="Select Windows Application",
            filetypes=[("Executables", "*.exe"), ("All files", "*.*")]
        )
        if filename:
            self.bench_app_var.set(filename)
    
    def run_benchmark(self):
        """Run benchmark"""
        prefix_name = self.bench_prefix_var.get()
        app_path = self.bench_app_var.get()
        duration = self.bench_duration_var.get()
        
        if not prefix_name or not app_path:
            messagebox.showwarning("Warning", "Please select prefix and application")
            return
        
        prefix_path = Path(self.optimizer.prefixes[prefix_name].path)
        
        self.status_var.set("Running benchmark...")
        self.results_text.delete(1.0, tk.END)
        self.results_text.insert(tk.END, "Benchmark running...\n")
        self.root.update()
        
        result = self.optimizer.run_benchmark(prefix_path, app_path, duration)
        
        if result:
            output = f"""
Benchmark Results
==================
Application: {result.app_name}
Timestamp: {result.timestamp}

Performance:
  Average FPS: {result.fps_avg:.1f}
  Min FPS: {result.fps_min:.1f}
  Max FPS: {result.fps_max:.1f}
  Avg Frame Time: {result.frame_time_avg:.2f} ms

Resource Usage:
  CPU: {result.cpu_usage:.1f}%
  GPU: {result.gpu_usage:.1f}%
  Memory: {result.memory_usage:.1f}%

Score: {result.score:.0f}
"""
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, output)
        else:
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, "Benchmark failed or was cancelled.\n")
        
        self.status_var.set("Ready")
    
    def open_url(self, url):
        """Open URL in browser"""
        try:
            subprocess.Popen(["xdg-open", url])
        except:
            pass
    
    def run(self):
        """Run the GUI"""
        self.root.mainloop()


def main():
    parser = argparse.ArgumentParser(
        description=f"Aegis Wine Optimizer v{AegisWineOptimizer.VERSION}",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  aegis-wine-optimizer --gui                    # Launch GUI
  aegis-wine-optimizer --list-versions          # List Wine versions
  aegis-wine-optimizer --list-prefixes          # List Wine prefixes
  aegis-wine-optimizer --create-prefix gaming   # Create gaming prefix
  aegis-wine-optimizer --install-deps vcrun2019 dxvk  # Install dependencies
        """
    )
    
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--list-versions', action='store_true', help='List detected Wine versions')
    parser.add_argument('--list-prefixes', action='store_true', help='List Wine prefixes')
    parser.add_argument('--status', action='store_true', help='Show system status')
    parser.add_argument('--create-prefix', metavar='NAME', help='Create a new Wine prefix')
    parser.add_argument('--template', default='gaming', 
                       choices=list(AegisWineOptimizer.PREFIX_TEMPLATES.keys()),
                       help='Template for new prefix')
    parser.add_argument('--install-deps', nargs='+', metavar='DEP', 
                       help='Install dependencies to prefix')
    parser.add_argument('--prefix', metavar='PATH', help='Wine prefix path for operations')
    parser.add_argument('--optimize', metavar='PATH', help='Optimize a Wine prefix')
    parser.add_argument('--benchmark', metavar='APP', help='Benchmark an application')
    parser.add_argument('--benchmark-duration', type=int, default=60, 
                       help='Benchmark duration in seconds')
    parser.add_argument('--scan', action='store_true', help='Scan for Wine versions')
    parser.add_argument('--version', action='version', 
                       version=f'Aegis Wine Optimizer v{AegisWineOptimizer.VERSION}')
    
    args = parser.parse_args()
    
    if args.gui:
        if not TKINTER_AVAILABLE:
            print("Error: tkinter not available. Install with: sudo apt install python3-tk")
            sys.exit(1)
        
        optimizer = AegisWineOptimizer(headless=False)
        gui = WineOptimizerGUI(optimizer)
        gui.run()
        return
    
    optimizer = AegisWineOptimizer(headless=True)
    
    if args.status:
        optimizer.print_status()
        return
    
    if args.scan:
        optimizer.detect_wine_versions()
        print(f"Found {len(optimizer.wine_versions)} Wine/Proton versions")
        return
    
    if args.list_versions:
        print(optimizer.list_versions())
        return
    
    if args.list_prefixes:
        print(optimizer.list_prefixes())
        return
    
    if args.create_prefix:
        success, message = optimizer.create_prefix(args.create_prefix, args.template)
        print(message)
        sys.exit(0 if success else 1)
    
    if args.install_deps:
        prefix_path = Path(args.prefix) if args.prefix else Path.home() / ".wine"
        success, results = optimizer.install_dependencies(prefix_path, args.install_deps)
        for result in results:
            print(result)
        sys.exit(0 if success else 1)
    
    if args.optimize:
        prefix_path = Path(args.optimize)
        success, message = optimizer.optimize_prefix(prefix_path)
        print(message)
        sys.exit(0 if success else 1)
    
    if args.benchmark:
        prefix_path = Path(args.prefix) if args.prefix else Path.home() / ".wine"
        result = optimizer.run_benchmark(prefix_path, args.benchmark, args.benchmark_duration)
        if result:
            print(f"Benchmark Score: {result.score:.0f}")
            print(f"Average FPS: {result.fps_avg:.1f}")
        else:
            print("Benchmark failed")
            sys.exit(1)
        return
    
    optimizer.print_status()
    print("\nUse --help for available commands or --gui for graphical interface")


if __name__ == "__main__":
    main()
