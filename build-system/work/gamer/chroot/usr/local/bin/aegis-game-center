#!/usr/bin/env python3
"""
Aegis Game Center - Unified Game Library
Central hub for managing games across all platforms: Steam, Lutris, Heroic, RetroArch, Wine

Features:
- Unified library view across all game sources
- One-click launch with optimal settings
- Per-game performance profiles
- Automatic cover art and metadata fetching
- Playtime tracking and statistics
- Game categorization and favorites
- Quick search and filtering
- Integration with Aegis Performance Tuner

Copyright (c) 2024 Aegis OS Team
License: GPL-3.0
"""

import os
import sys
import json
import subprocess
import argparse
import shutil
import sqlite3
import hashlib
import threading
import time
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field, asdict
from enum import Enum

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

VERSION = "1.0.0"
APP_NAME = "Aegis Game Center"
CONFIG_DIR = Path.home() / ".config/aegis/game-center"
DATABASE_FILE = CONFIG_DIR / "library.db"
CACHE_DIR = CONFIG_DIR / "cache"
COVERS_DIR = CACHE_DIR / "covers"


class GameSource(Enum):
    STEAM = "steam"
    LUTRIS = "lutris"
    HEROIC = "heroic"
    RETROARCH = "retroarch"
    WINE = "wine"
    NATIVE = "native"
    FLATPAK = "flatpak"
    EXTERNAL = "external"


class GameStatus(Enum):
    INSTALLED = "installed"
    NOT_INSTALLED = "not_installed"
    UPDATING = "updating"
    RUNNING = "running"


@dataclass
class Game:
    id: str
    name: str
    source: str
    executable: str = ""
    install_path: str = ""
    icon: str = ""
    cover_art: str = ""
    description: str = ""
    developer: str = ""
    publisher: str = ""
    genre: str = ""
    release_date: str = ""
    playtime_minutes: int = 0
    last_played: str = ""
    added_date: str = ""
    favorite: bool = False
    hidden: bool = False
    category: str = ""
    launch_options: str = ""
    wine_prefix: str = ""
    proton_version: str = ""
    gamemode_enabled: bool = True
    mangohud_enabled: bool = False
    custom_resolution: str = ""
    performance_profile: str = "balanced"
    status: str = "installed"


@dataclass
class LibraryStats:
    total_games: int = 0
    installed_games: int = 0
    total_playtime_hours: float = 0.0
    games_by_source: Dict[str, int] = field(default_factory=dict)
    recently_played: List[str] = field(default_factory=list)
    most_played: List[Tuple[str, int]] = field(default_factory=list)


class GameLibraryDB:
    def __init__(self, db_path: Path):
        self.db_path = db_path
        db_path.parent.mkdir(parents=True, exist_ok=True)
        self.conn = sqlite3.connect(str(db_path), check_same_thread=False)
        self._init_schema()

    def _init_schema(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS games (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                source TEXT NOT NULL,
                executable TEXT DEFAULT '',
                install_path TEXT DEFAULT '',
                icon TEXT DEFAULT '',
                cover_art TEXT DEFAULT '',
                description TEXT DEFAULT '',
                developer TEXT DEFAULT '',
                publisher TEXT DEFAULT '',
                genre TEXT DEFAULT '',
                release_date TEXT DEFAULT '',
                playtime_minutes INTEGER DEFAULT 0,
                last_played TEXT DEFAULT '',
                added_date TEXT DEFAULT '',
                favorite INTEGER DEFAULT 0,
                hidden INTEGER DEFAULT 0,
                category TEXT DEFAULT '',
                launch_options TEXT DEFAULT '',
                wine_prefix TEXT DEFAULT '',
                proton_version TEXT DEFAULT '',
                gamemode_enabled INTEGER DEFAULT 1,
                mangohud_enabled INTEGER DEFAULT 0,
                custom_resolution TEXT DEFAULT '',
                performance_profile TEXT DEFAULT 'balanced',
                status TEXT DEFAULT 'installed'
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                game_id TEXT NOT NULL,
                start_time TEXT NOT NULL,
                end_time TEXT,
                duration_minutes INTEGER DEFAULT 0,
                FOREIGN KEY (game_id) REFERENCES games (id)
            )
        ''')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_games_source ON games(source)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_games_name ON games(name)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_sessions_game ON sessions(game_id)')
        self.conn.commit()

    def add_game(self, game: Game) -> bool:
        cursor = self.conn.cursor()
        try:
            cursor.execute('''
                INSERT OR REPLACE INTO games 
                (id, name, source, executable, install_path, icon, cover_art, description,
                 developer, publisher, genre, release_date, playtime_minutes, last_played,
                 added_date, favorite, hidden, category, launch_options, wine_prefix,
                 proton_version, gamemode_enabled, mangohud_enabled, custom_resolution,
                 performance_profile, status)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                game.id, game.name, game.source, game.executable, game.install_path,
                game.icon, game.cover_art, game.description, game.developer, game.publisher,
                game.genre, game.release_date, game.playtime_minutes, game.last_played,
                game.added_date or datetime.now().isoformat(), int(game.favorite),
                int(game.hidden), game.category, game.launch_options, game.wine_prefix,
                game.proton_version, int(game.gamemode_enabled), int(game.mangohud_enabled),
                game.custom_resolution, game.performance_profile, game.status
            ))
            self.conn.commit()
            return True
        except Exception as e:
            print(f"Error adding game: {e}", file=sys.stderr)
            return False

    def get_game(self, game_id: str) -> Optional[Game]:
        cursor = self.conn.cursor()
        cursor.execute('SELECT * FROM games WHERE id = ?', (game_id,))
        row = cursor.fetchone()
        if row:
            return self._row_to_game(row)
        return None

    def get_all_games(self, include_hidden: bool = False) -> List[Game]:
        cursor = self.conn.cursor()
        if include_hidden:
            cursor.execute('SELECT * FROM games ORDER BY name')
        else:
            cursor.execute('SELECT * FROM games WHERE hidden = 0 ORDER BY name')
        return [self._row_to_game(row) for row in cursor.fetchall()]

    def get_games_by_source(self, source: str) -> List[Game]:
        cursor = self.conn.cursor()
        cursor.execute('SELECT * FROM games WHERE source = ? AND hidden = 0 ORDER BY name', (source,))
        return [self._row_to_game(row) for row in cursor.fetchall()]

    def get_favorites(self) -> List[Game]:
        cursor = self.conn.cursor()
        cursor.execute('SELECT * FROM games WHERE favorite = 1 AND hidden = 0 ORDER BY name')
        return [self._row_to_game(row) for row in cursor.fetchall()]

    def get_recent(self, limit: int = 10) -> List[Game]:
        cursor = self.conn.cursor()
        cursor.execute('''
            SELECT * FROM games WHERE last_played != '' AND hidden = 0
            ORDER BY last_played DESC LIMIT ?
        ''', (limit,))
        return [self._row_to_game(row) for row in cursor.fetchall()]

    def search_games(self, query: str) -> List[Game]:
        cursor = self.conn.cursor()
        search = f'%{query}%'
        cursor.execute('''
            SELECT * FROM games WHERE hidden = 0 AND 
            (name LIKE ? OR developer LIKE ? OR genre LIKE ? OR category LIKE ?)
            ORDER BY name
        ''', (search, search, search, search))
        return [self._row_to_game(row) for row in cursor.fetchall()]

    def update_playtime(self, game_id: str, minutes: int, start_time: str):
        cursor = self.conn.cursor()
        cursor.execute('''
            UPDATE games SET 
            playtime_minutes = playtime_minutes + ?,
            last_played = ?
            WHERE id = ?
        ''', (minutes, datetime.now().isoformat(), game_id))
        cursor.execute('''
            INSERT INTO sessions (game_id, start_time, end_time, duration_minutes)
            VALUES (?, ?, ?, ?)
        ''', (game_id, start_time, datetime.now().isoformat(), minutes))
        self.conn.commit()

    def toggle_favorite(self, game_id: str) -> bool:
        cursor = self.conn.cursor()
        cursor.execute('UPDATE games SET favorite = NOT favorite WHERE id = ?', (game_id,))
        self.conn.commit()
        cursor.execute('SELECT favorite FROM games WHERE id = ?', (game_id,))
        row = cursor.fetchone()
        return bool(row[0]) if row else False

    def get_stats(self) -> LibraryStats:
        cursor = self.conn.cursor()
        cursor.execute('SELECT COUNT(*) FROM games')
        total = cursor.fetchone()[0]
        cursor.execute("SELECT COUNT(*) FROM games WHERE status = 'installed'")
        installed = cursor.fetchone()[0]
        cursor.execute('SELECT SUM(playtime_minutes) FROM games')
        playtime = cursor.fetchone()[0] or 0
        cursor.execute('SELECT source, COUNT(*) FROM games GROUP BY source')
        by_source = {row[0]: row[1] for row in cursor.fetchall()}
        cursor.execute('''
            SELECT id, name FROM games WHERE last_played != '' 
            ORDER BY last_played DESC LIMIT 5
        ''')
        recent = [row[1] for row in cursor.fetchall()]
        cursor.execute('''
            SELECT name, playtime_minutes FROM games 
            ORDER BY playtime_minutes DESC LIMIT 5
        ''')
        most_played = [(row[0], row[1]) for row in cursor.fetchall()]
        return LibraryStats(
            total_games=total,
            installed_games=installed,
            total_playtime_hours=playtime / 60.0,
            games_by_source=by_source,
            recently_played=recent,
            most_played=most_played
        )

    def _row_to_game(self, row) -> Game:
        return Game(
            id=row[0], name=row[1], source=row[2], executable=row[3],
            install_path=row[4], icon=row[5], cover_art=row[6], description=row[7],
            developer=row[8], publisher=row[9], genre=row[10], release_date=row[11],
            playtime_minutes=row[12], last_played=row[13], added_date=row[14],
            favorite=bool(row[15]), hidden=bool(row[16]), category=row[17],
            launch_options=row[18], wine_prefix=row[19], proton_version=row[20],
            gamemode_enabled=bool(row[21]), mangohud_enabled=bool(row[22]),
            custom_resolution=row[23], performance_profile=row[24], status=row[25]
        )

    def close(self):
        self.conn.close()


class GameScanner:
    def __init__(self, db: GameLibraryDB):
        self.db = db

    def scan_all(self) -> int:
        count = 0
        count += self._scan_steam()
        count += self._scan_lutris()
        count += self._scan_heroic()
        count += self._scan_native()
        count += self._scan_flatpak()
        return count

    def _scan_steam(self) -> int:
        count = 0
        steam_paths = [
            Path.home() / ".steam/steam/steamapps",
            Path.home() / ".local/share/Steam/steamapps",
            Path("/mnt/games/Steam/steamapps"),
        ]
        for steam_path in steam_paths:
            if not steam_path.exists():
                continue
            for acf in steam_path.glob("*.acf"):
                try:
                    with open(acf, 'r') as f:
                        content = f.read()
                    app_id = self._parse_vdf_value(content, "appid")
                    name = self._parse_vdf_value(content, "name")
                    install_dir = self._parse_vdf_value(content, "installdir")
                    if app_id and name:
                        game = Game(
                            id=f"steam:{app_id}",
                            name=name,
                            source="steam",
                            install_path=str(steam_path / "common" / install_dir) if install_dir else "",
                            executable=f"steam://rungameid/{app_id}"
                        )
                        if self.db.add_game(game):
                            count += 1
                except Exception:
                    continue
        return count

    def _scan_lutris(self) -> int:
        count = 0
        lutris_db = Path.home() / ".local/share/lutris/pga.db"
        if lutris_db.exists():
            try:
                conn = sqlite3.connect(str(lutris_db))
                cursor = conn.cursor()
                cursor.execute("SELECT id, name, slug, runner, directory FROM games")
                for row in cursor.fetchall():
                    game = Game(
                        id=f"lutris:{row[0]}",
                        name=row[1],
                        source="lutris",
                        install_path=row[4] or "",
                        executable=f"lutris:rungame/{row[2]}"
                    )
                    if self.db.add_game(game):
                        count += 1
                conn.close()
            except Exception:
                pass
        return count

    def _scan_heroic(self) -> int:
        count = 0
        heroic_path = Path.home() / ".config/heroic/store_cache"
        for store in ["gog_library.json", "legendary_library.json"]:
            store_file = heroic_path / store
            if store_file.exists():
                try:
                    with open(store_file) as f:
                        data = json.load(f)
                    games_data = data.get("library", []) if isinstance(data, dict) else data
                    for g in games_data:
                        if isinstance(g, dict):
                            game = Game(
                                id=f"heroic:{g.get('app_name', g.get('id', ''))}",
                                name=g.get('title', g.get('name', 'Unknown')),
                                source="heroic",
                                install_path=g.get('install_path', ''),
                                developer=g.get('developer', '')
                            )
                            if self.db.add_game(game):
                                count += 1
                except Exception:
                    continue
        return count

    def _scan_native(self) -> int:
        count = 0
        app_dirs = [
            Path("/usr/share/applications"),
            Path.home() / ".local/share/applications"
        ]
        game_categories = ["Game", "ActionGame", "AdventureGame", "ArcadeGame", "RolePlaying"]
        for app_dir in app_dirs:
            if not app_dir.exists():
                continue
            for desktop in app_dir.glob("*.desktop"):
                try:
                    with open(desktop, 'r') as f:
                        content = f.read()
                    if any(cat in content for cat in game_categories):
                        name = self._parse_desktop_value(content, "Name")
                        exec_cmd = self._parse_desktop_value(content, "Exec")
                        icon = self._parse_desktop_value(content, "Icon")
                        if name and exec_cmd:
                            game = Game(
                                id=f"native:{desktop.stem}",
                                name=name,
                                source="native",
                                executable=exec_cmd,
                                icon=icon
                            )
                            if self.db.add_game(game):
                                count += 1
                except Exception:
                    continue
        return count

    def _scan_flatpak(self) -> int:
        count = 0
        try:
            result = subprocess.run(
                ["flatpak", "list", "--app", "--columns=application,name"],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if not line:
                        continue
                    parts = line.split('\t')
                    if len(parts) >= 2:
                        app_id, name = parts[0], parts[1]
                        info = subprocess.run(
                            ["flatpak", "info", "--show-metadata", app_id],
                            capture_output=True, text=True
                        )
                        if "Categories=Game" in info.stdout or "Game" in name.lower():
                            game = Game(
                                id=f"flatpak:{app_id}",
                                name=name,
                                source="flatpak",
                                executable=f"flatpak run {app_id}"
                            )
                            if self.db.add_game(game):
                                count += 1
        except Exception:
            pass
        return count

    def _parse_vdf_value(self, content: str, key: str) -> str:
        import re
        pattern = rf'"{key}"\s+"([^"]*)"'
        match = re.search(pattern, content, re.IGNORECASE)
        return match.group(1) if match else ""

    def _parse_desktop_value(self, content: str, key: str) -> str:
        for line in content.split('\n'):
            if line.startswith(f"{key}="):
                return line.split('=', 1)[1].strip()
        return ""


class GameLauncher:
    def __init__(self, db: GameLibraryDB):
        self.db = db
        self.current_game: Optional[Game] = None
        self.start_time: Optional[datetime] = None
        self.process: Optional[subprocess.Popen] = None

    def launch(self, game_id: str) -> Tuple[bool, str]:
        game = self.db.get_game(game_id)
        if not game:
            return False, "Game not found"

        env = os.environ.copy()
        cmd = []

        if game.gamemode_enabled and shutil.which("gamemoderun"):
            cmd.append("gamemoderun")

        if game.mangohud_enabled:
            env["MANGOHUD"] = "1"

        if game.source == "steam":
            cmd = ["steam", "-applaunch", game.id.split(":")[1]]
            if game.launch_options:
                cmd.extend(game.launch_options.split())
        elif game.source == "lutris":
            cmd = ["lutris", f"lutris:rungame/{game.id.split(':')[1]}"]
        elif game.source == "heroic":
            cmd = ["heroic", "--no-gui", game.id.split(":")[1]]
        elif game.source == "flatpak":
            cmd = ["flatpak", "run", game.id.split(":")[1]]
        elif game.executable:
            if game.source == "wine" and game.wine_prefix:
                env["WINEPREFIX"] = game.wine_prefix
                cmd.extend(["wine", game.executable])
            else:
                cmd.extend(game.executable.split())

        if not cmd:
            return False, "No launch command configured"

        try:
            self.process = subprocess.Popen(cmd, env=env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            self.current_game = game
            self.start_time = datetime.now()
            return True, f"Launched {game.name}"
        except Exception as e:
            return False, str(e)

    def stop_tracking(self):
        if self.current_game and self.start_time:
            duration = int((datetime.now() - self.start_time).total_seconds() / 60)
            if duration > 0:
                self.db.update_playtime(self.current_game.id, duration, self.start_time.isoformat())
        self.current_game = None
        self.start_time = None


class GameCenterService:
    def __init__(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        COVERS_DIR.mkdir(parents=True, exist_ok=True)
        self.db = GameLibraryDB(DATABASE_FILE)
        self.scanner = GameScanner(self.db)
        self.launcher = GameLauncher(self.db)

    def scan_library(self) -> int:
        return self.scanner.scan_all()

    def get_all_games(self) -> List[Game]:
        return self.db.get_all_games()

    def get_games_by_source(self, source: str) -> List[Game]:
        return self.db.get_games_by_source(source)

    def get_favorites(self) -> List[Game]:
        return self.db.get_favorites()

    def get_recent(self, limit: int = 10) -> List[Game]:
        return self.db.get_recent(limit)

    def search(self, query: str) -> List[Game]:
        return self.db.search_games(query)

    def launch_game(self, game_id: str) -> Tuple[bool, str]:
        return self.launcher.launch(game_id)

    def toggle_favorite(self, game_id: str) -> bool:
        return self.db.toggle_favorite(game_id)

    def get_stats(self) -> LibraryStats:
        return self.db.get_stats()

    def get_status(self) -> Dict:
        stats = self.get_stats()
        return {
            "version": VERSION,
            "total_games": stats.total_games,
            "installed_games": stats.installed_games,
            "total_playtime_hours": round(stats.total_playtime_hours, 1),
            "games_by_source": stats.games_by_source,
            "recently_played": stats.recently_played,
            "database": str(DATABASE_FILE)
        }

    def close(self):
        self.launcher.stop_tracking()
        self.db.close()


class GameCenterGUI:
    def __init__(self, service: GameCenterService):
        self.service = service
        self.root = None
        self.games_list = None
        self.current_filter = "all"

    def run(self):
        if not TKINTER_AVAILABLE:
            print("Error: Tkinter not available")
            sys.exit(1)

        self.root = tk.Tk()
        self.root.title(f"{APP_NAME} v{VERSION}")
        self.root.geometry("1200x800")
        self.root.configure(bg='#1a1a2e')

        style = ttk.Style()
        style.theme_use('clam')
        style.configure('TFrame', background='#1a1a2e')
        style.configure('TLabel', background='#1a1a2e', foreground='#eef1ff')
        style.configure('Header.TLabel', font=('Segoe UI', 20, 'bold'), foreground='#00d9ff')
        style.configure('Game.TLabel', font=('Segoe UI', 12), foreground='#eef1ff')
        style.configure('Stats.TLabel', font=('Segoe UI', 10), foreground='#a0a0a0')
        style.configure('TButton', padding=8, font=('Segoe UI', 10))
        style.configure('Launch.TButton', padding=12, font=('Segoe UI', 11, 'bold'))
        style.configure('TNotebook', background='#1a1a2e')
        style.configure('TNotebook.Tab', padding=[12, 6], font=('Segoe UI', 10))

        self._create_widgets()
        self._refresh_games()
        self.root.mainloop()

    def _create_widgets(self):
        main = ttk.Frame(self.root, padding=15)
        main.pack(fill=tk.BOTH, expand=True)

        header = ttk.Frame(main)
        header.pack(fill=tk.X, pady=(0, 15))

        ttk.Label(header, text="üéÆ Aegis Game Center", style='Header.TLabel').pack(side=tk.LEFT)

        btn_frame = ttk.Frame(header)
        btn_frame.pack(side=tk.RIGHT)

        ttk.Button(btn_frame, text="üîÑ Scan", command=self._scan_games).pack(side=tk.LEFT, padx=3)
        ttk.Button(btn_frame, text="üìä Stats", command=self._show_stats).pack(side=tk.LEFT, padx=3)
        ttk.Button(btn_frame, text="‚ö° Tuner", command=self._open_tuner).pack(side=tk.LEFT, padx=3)

        search_frame = ttk.Frame(main)
        search_frame.pack(fill=tk.X, pady=(0, 10))

        self.search_var = tk.StringVar()
        self.search_var.trace('w', lambda *args: self._filter_games())
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var, font=('Segoe UI', 11))
        search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        search_entry.insert(0, "Search games...")
        search_entry.bind('<FocusIn>', lambda e: search_entry.delete(0, tk.END) if search_entry.get() == "Search games..." else None)

        filter_frame = ttk.Frame(search_frame)
        filter_frame.pack(side=tk.RIGHT)

        self.filter_var = tk.StringVar(value="all")
        filters = [("All", "all"), ("‚≠ê Favorites", "favorites"), ("üïê Recent", "recent"),
                   ("üéÆ Steam", "steam"), ("üç∑ Lutris", "lutris"), ("ü¶∏ Heroic", "heroic")]
        for text, value in filters:
            ttk.Radiobutton(filter_frame, text=text, value=value, variable=self.filter_var,
                           command=self._filter_games).pack(side=tk.LEFT, padx=3)

        content = ttk.Frame(main)
        content.pack(fill=tk.BOTH, expand=True)

        list_frame = ttk.Frame(content)
        list_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        columns = ("name", "source", "playtime", "last_played")
        self.games_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=25)
        self.games_tree.heading("name", text="Game")
        self.games_tree.heading("source", text="Source")
        self.games_tree.heading("playtime", text="Playtime")
        self.games_tree.heading("last_played", text="Last Played")
        self.games_tree.column("name", width=400)
        self.games_tree.column("source", width=100)
        self.games_tree.column("playtime", width=100)
        self.games_tree.column("last_played", width=150)

        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.games_tree.yview)
        self.games_tree.configure(yscrollcommand=scrollbar.set)

        self.games_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.games_tree.bind('<Double-1>', self._launch_selected)
        self.games_tree.bind('<Return>', self._launch_selected)

        details = ttk.Frame(content, width=300)
        details.pack(side=tk.RIGHT, fill=tk.Y, padx=(15, 0))
        details.pack_propagate(False)

        ttk.Label(details, text="Game Details", style='Header.TLabel').pack(anchor=tk.W, pady=(0, 10))

        self.detail_name = ttk.Label(details, text="Select a game", style='Game.TLabel', wraplength=280)
        self.detail_name.pack(anchor=tk.W, pady=5)

        self.detail_source = ttk.Label(details, text="", style='Stats.TLabel')
        self.detail_source.pack(anchor=tk.W)

        self.detail_playtime = ttk.Label(details, text="", style='Stats.TLabel')
        self.detail_playtime.pack(anchor=tk.W)

        ttk.Separator(details, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=15)

        self.launch_btn = ttk.Button(details, text="‚ñ∂ LAUNCH", style='Launch.TButton', command=self._launch_selected)
        self.launch_btn.pack(fill=tk.X, pady=5)

        self.fav_btn = ttk.Button(details, text="‚≠ê Toggle Favorite", command=self._toggle_favorite)
        self.fav_btn.pack(fill=tk.X, pady=5)

        self.games_tree.bind('<<TreeviewSelect>>', self._on_select)

        stats = self.service.get_stats()
        status_bar = ttk.Frame(main)
        status_bar.pack(fill=tk.X, pady=(10, 0))
        self.status_label = ttk.Label(status_bar, 
            text=f"üìö {stats.total_games} games | ‚è± {stats.total_playtime_hours:.1f}h played",
            style='Stats.TLabel')
        self.status_label.pack(side=tk.LEFT)

    def _refresh_games(self):
        self._filter_games()

    def _filter_games(self):
        for item in self.games_tree.get_children():
            self.games_tree.delete(item)

        filter_type = self.filter_var.get()
        search_query = self.search_var.get()
        if search_query == "Search games...":
            search_query = ""

        if search_query:
            games = self.service.search(search_query)
        elif filter_type == "favorites":
            games = self.service.get_favorites()
        elif filter_type == "recent":
            games = self.service.get_recent(20)
        elif filter_type in ["steam", "lutris", "heroic"]:
            games = self.service.get_games_by_source(filter_type)
        else:
            games = self.service.get_all_games()

        for game in games:
            playtime = f"{game.playtime_minutes // 60}h {game.playtime_minutes % 60}m" if game.playtime_minutes else "-"
            last_played = game.last_played[:10] if game.last_played else "-"
            fav = "‚≠ê " if game.favorite else ""
            self.games_tree.insert("", tk.END, iid=game.id, 
                                  values=(f"{fav}{game.name}", game.source.upper(), playtime, last_played))

    def _on_select(self, event):
        selection = self.games_tree.selection()
        if selection:
            game_id = selection[0]
            game = self.service.db.get_game(game_id)
            if game:
                self.detail_name.config(text=game.name)
                self.detail_source.config(text=f"Source: {game.source.upper()}")
                playtime = f"{game.playtime_minutes // 60}h {game.playtime_minutes % 60}m" if game.playtime_minutes else "Not played"
                self.detail_playtime.config(text=f"Playtime: {playtime}")

    def _launch_selected(self, event=None):
        selection = self.games_tree.selection()
        if selection:
            game_id = selection[0]
            success, msg = self.service.launch_game(game_id)
            if not success:
                messagebox.showerror("Launch Error", msg)

    def _toggle_favorite(self):
        selection = self.games_tree.selection()
        if selection:
            game_id = selection[0]
            self.service.toggle_favorite(game_id)
            self._refresh_games()

    def _scan_games(self):
        count = self.service.scan_library()
        messagebox.showinfo("Scan Complete", f"Found {count} games")
        self._refresh_games()
        stats = self.service.get_stats()
        self.status_label.config(text=f"üìö {stats.total_games} games | ‚è± {stats.total_playtime_hours:.1f}h played")

    def _show_stats(self):
        stats = self.service.get_stats()
        msg = f"""
üìä Library Statistics

Total Games: {stats.total_games}
Installed: {stats.installed_games}
Total Playtime: {stats.total_playtime_hours:.1f} hours

Games by Source:
"""
        for source, count in stats.games_by_source.items():
            msg += f"  ‚Ä¢ {source.upper()}: {count}\n"

        if stats.most_played:
            msg += "\nMost Played:\n"
            for name, mins in stats.most_played[:5]:
                msg += f"  ‚Ä¢ {name}: {mins // 60}h\n"

        messagebox.showinfo("Library Statistics", msg)

    def _open_tuner(self):
        try:
            subprocess.Popen(["/usr/local/bin/aegis-performance-tuner", "--gui"])
        except Exception:
            messagebox.showerror("Error", "Performance Tuner not found")


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - Unified game library")
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--scan', action='store_true', help='Scan for games')
    parser.add_argument('--list', action='store_true', help='List all games')
    parser.add_argument('--favorites', action='store_true', help='List favorite games')
    parser.add_argument('--recent', action='store_true', help='List recently played')
    parser.add_argument('--launch', metavar='GAME_ID', help='Launch a game')
    parser.add_argument('--search', metavar='QUERY', help='Search games')
    parser.add_argument('--source', metavar='SOURCE', help='Filter by source')
    parser.add_argument('--stats', action='store_true', help='Show library statistics')
    parser.add_argument('--status', action='store_true', help='Show status as JSON')
    parser.add_argument('--version', action='version', version=f'{APP_NAME} v{VERSION}')

    args = parser.parse_args()
    service = GameCenterService()

    try:
        if args.scan:
            count = service.scan_library()
            print(f"Scanned library: found {count} games")
        elif args.list:
            games = service.get_games_by_source(args.source) if args.source else service.get_all_games()
            print(f"Games ({len(games)}):")
            for g in games:
                fav = "‚≠ê" if g.favorite else " "
                print(f"  {fav} [{g.source}] {g.name} ({g.id})")
        elif args.favorites:
            games = service.get_favorites()
            print(f"Favorites ({len(games)}):")
            for g in games:
                print(f"  ‚≠ê {g.name}")
        elif args.recent:
            games = service.get_recent()
            print("Recently Played:")
            for g in games:
                print(f"  - {g.name} ({g.last_played[:10] if g.last_played else 'Never'})")
        elif args.search:
            games = service.search(args.search)
            print(f"Search results for '{args.search}' ({len(games)}):")
            for g in games:
                print(f"  - {g.name} [{g.source}]")
        elif args.launch:
            success, msg = service.launch_game(args.launch)
            print(msg)
            sys.exit(0 if success else 1)
        elif args.stats:
            stats = service.get_stats()
            print(f"Total Games: {stats.total_games}")
            print(f"Installed: {stats.installed_games}")
            print(f"Total Playtime: {stats.total_playtime_hours:.1f} hours")
            print("By Source:")
            for src, cnt in stats.games_by_source.items():
                print(f"  {src}: {cnt}")
        elif args.status:
            print(json.dumps(service.get_status(), indent=2))
        elif args.gui or not any([args.scan, args.list, args.favorites, args.recent, 
                                   args.search, args.launch, args.stats, args.status]):
            if TKINTER_AVAILABLE:
                gui = GameCenterGUI(service)
                gui.run()
            else:
                print("GUI requires tkinter. Use --help for CLI options.")
                sys.exit(1)
    finally:
        service.close()


if __name__ == "__main__":
    main()
