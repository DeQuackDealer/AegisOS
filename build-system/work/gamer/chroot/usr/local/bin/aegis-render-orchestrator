#!/usr/bin/env python3
"""
Aegis Render Orchestrator - Dual-GPU Split Rendering Daemon

Manages split-screen rendering across multiple GPUs:
- One GPU renders the screen center, another renders the periphery/rim
- User-configurable region boundaries and GPU assignments
- Per-region upscaler integration with independent quality settings
- Frame synchronization to highest FPS with FreeSync/VRR support
- DBus API for game launcher integration

Architecture:
┌─────────────────┐    ┌─────────────────┐
│   GPU-Center    │    │    GPU-Rim      │
│  (Primary/User) │    │ (Secondary/User)│
└────────┬────────┘    └────────┬────────┘
         │                      │
         ▼                      ▼
┌─────────────────┐    ┌─────────────────┐
│ Region Renderer │    │ Region Renderer │
│  Center Zone    │    │   Rim/Periph    │
└────────┬────────┘    └────────┬────────┘
         │                      │
         ▼                      ▼
┌─────────────────┐    ┌─────────────────┐
│    Upscaler     │    │    Upscaler     │
│  (User Config)  │    │  (User Config)  │
└────────┬────────┘    └────────┬────────┘
         │                      │
         └──────────┬───────────┘
                    ▼
         ┌─────────────────────┐
         │  Frame Compositor   │
         │  (Gamescope/Custom) │
         │  VRR/FreeSync Sync  │
         └─────────────────────┘
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import threading
import time
import signal
import socket
import struct
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum
from datetime import datetime

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, GLib
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False

CONFIG_DIR = Path("/etc/aegis/render-orchestrator")
USER_CONFIG_DIR = Path.home() / ".config/aegis/render-orchestrator"
PROFILES_DIR = USER_CONFIG_DIR / "profiles"
LOG_DIR = Path("/var/log/aegis")
SOCKET_PATH = "/tmp/aegis-render-orchestrator.sock"
DBUS_SERVICE = "com.aegis.RenderOrchestrator"
DBUS_PATH = "/com/aegis/RenderOrchestrator"

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("aegis-render-orchestrator")


class GPUVendor(Enum):
    NVIDIA = "nvidia"
    AMD = "amd"
    INTEL = "intel"
    UNKNOWN = "unknown"


class RenderRegion(Enum):
    CENTER = "center"
    RIM = "rim"
    FULL = "full"


class SyncMode(Enum):
    VSYNC = "vsync"
    FREESYNC = "freesync"
    GSYNC = "gsync"
    ADAPTIVE = "adaptive"
    UNLOCKED = "unlocked"


@dataclass
class GPUDevice:
    """Represents a detected GPU"""
    id: str
    name: str
    vendor: str
    pci_bus: str
    driver: str
    vram_mb: int
    compute_capability: str = ""
    vulkan_support: bool = True
    opengl_version: str = ""
    is_primary: bool = False
    is_active: bool = True
    power_limit_w: int = 0
    current_temp_c: int = 0
    current_usage_pct: int = 0
    current_vram_used_mb: int = 0


@dataclass
class RegionConfig:
    """Configuration for a render region"""
    region: str  # center or rim
    gpu_id: str
    render_resolution: str = "1920x1080"
    output_resolution: str = "2560x1440"
    upscaler_backend: str = "fsr2"
    upscaler_quality: str = "balanced"
    target_fps: int = 60
    region_bounds: Dict = field(default_factory=lambda: {
        "x_start_pct": 0.0,
        "x_end_pct": 100.0,
        "y_start_pct": 0.0,
        "y_end_pct": 100.0
    })
    priority: int = 1


@dataclass
class SplitRenderProfile:
    """Complete dual-GPU rendering profile"""
    name: str
    game_id: str = ""
    description: str = ""
    enabled: bool = True
    center_config: RegionConfig = None
    rim_config: RegionConfig = None
    sync_mode: str = "freesync"
    master_fps: int = 144
    compositor: str = "gamescope"
    latency_target_ms: float = 6.0
    fallback_mode: str = "single_gpu"
    region_blend_px: int = 32
    center_radius_pct: float = 60.0
    created: str = ""
    last_used: str = ""

    def __post_init__(self):
        if self.center_config is None:
            self.center_config = RegionConfig(region="center", gpu_id="")
        if self.rim_config is None:
            self.rim_config = RegionConfig(region="rim", gpu_id="")


@dataclass
class FrameMetrics:
    """Real-time frame metrics per region"""
    region: str
    gpu_id: str
    current_fps: float
    frame_time_ms: float
    latency_ms: float
    gpu_usage_pct: float
    vram_usage_mb: int
    upscale_time_ms: float
    frames_rendered: int
    frames_dropped: int


class GPUEnumerator:
    """Detects and enumerates available GPUs"""

    @staticmethod
    def detect_nvidia_gpus() -> List[GPUDevice]:
        """Detect NVIDIA GPUs using nvidia-smi"""
        gpus = []
        try:
            result = subprocess.run(
                ["nvidia-smi", "--query-gpu=index,name,pci.bus_id,driver_version,memory.total,power.limit,temperature.gpu,utilization.gpu,memory.used",
                 "--format=csv,noheader,nounits"],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if not line.strip():
                        continue
                    parts = [p.strip() for p in line.split(',')]
                    if len(parts) >= 9:
                        gpu = GPUDevice(
                            id=f"nvidia:{parts[0]}",
                            name=parts[1],
                            vendor="nvidia",
                            pci_bus=parts[2],
                            driver=parts[3],
                            vram_mb=int(parts[4]) if parts[4].isdigit() else 0,
                            power_limit_w=int(float(parts[5])) if parts[5].replace('.', '').isdigit() else 0,
                            current_temp_c=int(parts[6]) if parts[6].isdigit() else 0,
                            current_usage_pct=int(parts[7]) if parts[7].isdigit() else 0,
                            current_vram_used_mb=int(parts[8]) if parts[8].isdigit() else 0,
                            vulkan_support=True,
                            is_primary=(parts[0] == "0")
                        )
                        gpus.append(gpu)
        except Exception as e:
            logger.debug(f"NVIDIA detection failed: {e}")
        return gpus

    @staticmethod
    def detect_amd_gpus() -> List[GPUDevice]:
        """Detect AMD GPUs using rocm-smi or /sys"""
        gpus = []
        try:
            result = subprocess.run(
                ["rocm-smi", "--showid", "--showproductname", "--showbus", "--showmeminfo", "vram"],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                pass
        except:
            pass

        drm_path = Path("/sys/class/drm")
        if drm_path.exists():
            for card in drm_path.glob("card[0-9]*"):
                device_path = card / "device"
                if not device_path.exists():
                    continue

                vendor_file = device_path / "vendor"
                if vendor_file.exists():
                    vendor_id = vendor_file.read_text().strip()
                    if vendor_id == "0x1002":
                        name = "AMD GPU"
                        name_file = device_path / "product_name"
                        if name_file.exists():
                            name = name_file.read_text().strip()

                        vram = 0
                        mem_file = device_path / "mem_info_vram_total"
                        if mem_file.exists():
                            try:
                                vram = int(mem_file.read_text().strip()) // (1024 * 1024)
                            except:
                                pass

                        gpu = GPUDevice(
                            id=f"amd:{card.name}",
                            name=name,
                            vendor="amd",
                            pci_bus=device_path.name if device_path.is_symlink() else "",
                            driver="amdgpu",
                            vram_mb=vram,
                            vulkan_support=True
                        )
                        gpus.append(gpu)
        return gpus

    @staticmethod
    def detect_intel_gpus() -> List[GPUDevice]:
        """Detect Intel GPUs"""
        gpus = []
        drm_path = Path("/sys/class/drm")
        if drm_path.exists():
            for card in drm_path.glob("card[0-9]*"):
                device_path = card / "device"
                if not device_path.exists():
                    continue

                vendor_file = device_path / "vendor"
                if vendor_file.exists():
                    vendor_id = vendor_file.read_text().strip()
                    if vendor_id == "0x8086":
                        name = "Intel GPU"
                        gpu = GPUDevice(
                            id=f"intel:{card.name}",
                            name=name,
                            vendor="intel",
                            pci_bus="",
                            driver="i915",
                            vram_mb=0,
                            vulkan_support=True
                        )
                        gpus.append(gpu)
        return gpus

    @classmethod
    def enumerate_all(cls) -> List[GPUDevice]:
        """Enumerate all available GPUs"""
        gpus = []
        gpus.extend(cls.detect_nvidia_gpus())
        gpus.extend(cls.detect_amd_gpus())
        gpus.extend(cls.detect_intel_gpus())

        if gpus and not any(g.is_primary for g in gpus):
            gpus[0].is_primary = True

        return gpus


class UpscalerDaemonManager:
    """Manages upscaler daemons for split rendering - one per region"""

    UPSCALER_BINARY = "/usr/local/bin/aegis-upscaler"

    def __init__(self):
        self.daemons: Dict[str, Dict] = {}
        self.lock = threading.Lock()

    def get_socket_path(self, region: str) -> str:
        """Get socket path for a region"""
        return f"/tmp/aegis-upscaler-{region}.sock"

    def start_daemon(self, region: str, gpu_id: str) -> Tuple[bool, str]:
        """Start an upscaler daemon for a specific region"""
        socket_path = self.get_socket_path(region)

        if os.path.exists(socket_path):
            try:
                os.unlink(socket_path)
            except OSError:
                pass

        cmd = [
            self.UPSCALER_BINARY,
            "--daemon",
            "--region", region,
            "--gpu", gpu_id,
            "--socket", socket_path
        ]

        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True
            )

            with self.lock:
                self.daemons[region] = {
                    "process": process,
                    "gpu_id": gpu_id,
                    "socket_path": socket_path,
                    "started": datetime.now().isoformat(),
                    "healthy": False
                }

            logger.info(f"Started upscaler daemon for {region} on GPU {gpu_id}, PID: {process.pid}")
            return True, f"Daemon started for {region}"

        except FileNotFoundError:
            return False, f"Upscaler binary not found: {self.UPSCALER_BINARY}"
        except Exception as e:
            return False, f"Failed to start daemon for {region}: {e}"

    def wait_for_daemon_ready(self, region: str, timeout: float = 10.0) -> bool:
        """Wait for a daemon to be ready (socket exists and responds)"""
        socket_path = self.get_socket_path(region)
        start_time = time.time()

        while time.time() - start_time < timeout:
            if os.path.exists(socket_path):
                if self.check_daemon_health(region):
                    with self.lock:
                        if region in self.daemons:
                            self.daemons[region]["healthy"] = True
                    return True
            time.sleep(0.2)

        logger.error(f"Timeout waiting for {region} daemon to be ready")
        return False

    def check_daemon_health(self, region: str) -> bool:
        """Check if a daemon is responsive"""
        socket_path = self.get_socket_path(region)

        if not os.path.exists(socket_path):
            return False

        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.settimeout(2.0)
            sock.connect(socket_path)

            header = struct.pack('!IIII', 0, 0, 0, 0)
            sock.sendall(header)

            response = sock.recv(4096).decode()
            sock.close()

            if response:
                data = json.loads(response)
                return data.get("status") == "running"
        except Exception as e:
            logger.debug(f"Health check failed for {region}: {e}")

        return False

    def get_daemon_metrics(self, region: str) -> Optional[Dict]:
        """Get metrics from a daemon via its socket"""
        socket_path = self.get_socket_path(region)

        if not os.path.exists(socket_path):
            return None

        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.settimeout(2.0)
            sock.connect(socket_path)

            header = struct.pack('!IIII', 2, 0, 0, 0)
            sock.sendall(header)

            length_data = sock.recv(4)
            if len(length_data) < 4:
                sock.close()
                return None

            response_len = struct.unpack('!I', length_data)[0]
            response = sock.recv(response_len).decode()
            sock.close()

            return json.loads(response)
        except Exception as e:
            logger.debug(f"Failed to get metrics from {region}: {e}")
            return None

    def restart_daemon_if_needed(self, region: str) -> bool:
        """Restart a daemon if it's not healthy"""
        with self.lock:
            if region not in self.daemons:
                return False

            daemon_info = self.daemons[region]
            process = daemon_info.get("process")

            if process and process.poll() is not None:
                logger.warning(f"Daemon for {region} has died, restarting...")
                gpu_id = daemon_info.get("gpu_id", "")

        if not self.check_daemon_health(region):
            self.stop_daemon(region)
            success, msg = self.start_daemon(region, daemon_info.get("gpu_id", ""))
            if success:
                return self.wait_for_daemon_ready(region, timeout=5.0)
            return False

        return True

    def stop_daemon(self, region: str):
        """Stop a specific daemon"""
        with self.lock:
            if region not in self.daemons:
                return

            daemon_info = self.daemons.pop(region)
            process = daemon_info.get("process")

        if process:
            try:
                process.terminate()
                try:
                    process.wait(timeout=3)
                except subprocess.TimeoutExpired:
                    process.kill()
                    process.wait(timeout=1)
            except Exception as e:
                logger.debug(f"Error stopping daemon {region}: {e}")

        socket_path = self.get_socket_path(region)
        if os.path.exists(socket_path):
            try:
                os.unlink(socket_path)
            except OSError:
                pass

        logger.info(f"Stopped upscaler daemon for {region}")

    def stop_all(self):
        """Stop all daemons"""
        with self.lock:
            regions = list(self.daemons.keys())

        for region in regions:
            self.stop_daemon(region)

    def get_all_status(self) -> Dict[str, Dict]:
        """Get status of all daemons"""
        status = {}
        with self.lock:
            for region, info in self.daemons.items():
                process = info.get("process")
                status[region] = {
                    "gpu_id": info.get("gpu_id"),
                    "socket_path": info.get("socket_path"),
                    "started": info.get("started"),
                    "running": process is not None and process.poll() is None,
                    "healthy": info.get("healthy", False),
                    "pid": process.pid if process else None
                }
        return status


class MetricsCollector:
    """Collects metrics from upscaler daemons in a background thread"""

    def __init__(self, daemon_manager: UpscalerDaemonManager, synchronizer: 'FrameSynchronizer'):
        self.daemon_manager = daemon_manager
        self.synchronizer = synchronizer
        self.running = False
        self.thread: Optional[threading.Thread] = None
        self.lock = threading.Lock()
        self.metrics: Dict[str, Any] = {
            "center_fps": 0.0,
            "center_frametime": 0.0,
            "center_latency": 0.0,
            "rim_fps": 0.0,
            "rim_frametime": 0.0,
            "rim_latency": 0.0,
            "composite_fps": 0.0,
            "sync_status": "unknown",
            "vrr_active": False,
            "last_update": None
        }

    def start(self, poll_interval: float = 0.1):
        """Start the metrics collection thread"""
        if self.running:
            return

        self.running = True
        self.thread = threading.Thread(target=self._collection_loop, args=(poll_interval,), daemon=True)
        self.thread.start()
        logger.info("Metrics collection thread started")

    def stop(self):
        """Stop the metrics collection thread"""
        self.running = False
        if self.thread:
            self.thread.join(timeout=2.0)
            self.thread = None
        logger.info("Metrics collection thread stopped")

    def _collection_loop(self, poll_interval: float):
        """Main metrics collection loop"""
        while self.running:
            try:
                self._collect_metrics()
            except Exception as e:
                logger.debug(f"Metrics collection error: {e}")

            time.sleep(poll_interval)

    def _collect_metrics(self):
        """Collect metrics from all upscaler daemons"""
        center_metrics = self.daemon_manager.get_daemon_metrics("center")
        rim_metrics = self.daemon_manager.get_daemon_metrics("rim")

        with self.lock:
            if center_metrics:
                fps = center_metrics.get("frames_per_second", 0)
                avg_latency = center_metrics.get("avg_latency_ms", 0)
                self.metrics["center_fps"] = fps
                self.metrics["center_frametime"] = 1000.0 / fps if fps > 0 else 0
                self.metrics["center_latency"] = avg_latency

                if self.synchronizer:
                    self.synchronizer.update_region_fps("center", fps)

            if rim_metrics:
                fps = rim_metrics.get("frames_per_second", 0)
                avg_latency = rim_metrics.get("avg_latency_ms", 0)
                self.metrics["rim_fps"] = fps
                self.metrics["rim_frametime"] = 1000.0 / fps if fps > 0 else 0
                self.metrics["rim_latency"] = avg_latency

                if self.synchronizer:
                    self.synchronizer.update_region_fps("rim", fps)

            self.metrics["composite_fps"] = max(
                self.metrics["center_fps"],
                self.metrics["rim_fps"]
            )

            if self.synchronizer:
                vrr_params = self.synchronizer.get_vrr_parameters()
                self.metrics["vrr_active"] = vrr_params.get("vrr_enabled", False)
                self.metrics["sync_status"] = self.synchronizer.sync_mode.value

            self.metrics["last_update"] = datetime.now().isoformat()

        for region in ["center", "rim"]:
            self.daemon_manager.restart_daemon_if_needed(region)

    def get_metrics(self) -> Dict[str, Any]:
        """Get the current metrics"""
        with self.lock:
            return self.metrics.copy()


class FrameSynchronizer:
    """Handles frame synchronization between regions"""

    def __init__(self, sync_mode: str = "freesync", master_fps: int = 144):
        self.sync_mode = SyncMode(sync_mode) if sync_mode in [m.value for m in SyncMode] else SyncMode.ADAPTIVE
        self.master_fps = master_fps
        self.center_fps = 0.0
        self.rim_fps = 0.0
        self.last_center_frame = 0
        self.last_rim_frame = 0
        self.frame_buffer_center = []
        self.frame_buffer_rim = []
        self.lock = threading.Lock()

    def update_region_fps(self, region: str, fps: float):
        """Update FPS for a region"""
        with self.lock:
            if region == "center":
                self.center_fps = fps
            else:
                self.rim_fps = fps

    def get_output_fps(self) -> float:
        """Get the synchronized output FPS (uses higher of the two)"""
        with self.lock:
            if self.sync_mode == SyncMode.FREESYNC or self.sync_mode == SyncMode.GSYNC:
                return max(self.center_fps, self.rim_fps, self.master_fps)
            elif self.sync_mode == SyncMode.VSYNC:
                return min(self.center_fps, self.rim_fps, 60.0)
            else:
                return max(self.center_fps, self.rim_fps)

    def get_vrr_parameters(self) -> Dict:
        """Get VRR/FreeSync parameters for compositor"""
        return {
            "vrr_enabled": self.sync_mode in [SyncMode.FREESYNC, SyncMode.GSYNC, SyncMode.ADAPTIVE],
            "min_refresh": 30,
            "max_refresh": self.master_fps,
            "target_refresh": int(self.get_output_fps()),
            "async_reprojection": True
        }


class GamescopeManager:
    """Manages Gamescope compositor for split rendering"""

    def __init__(self, profile: SplitRenderProfile):
        self.profile = profile
        self.process = None
        self.running = False

    def build_command(self) -> List[str]:
        """Build gamescope command with split-render parameters"""
        cmd = ["gamescope"]

        output_res = self.profile.center_config.output_resolution.split('x')
        if len(output_res) == 2:
            cmd.extend(["-W", output_res[0], "-H", output_res[1]])

        render_res = self.profile.center_config.render_resolution.split('x')
        if len(render_res) == 2:
            cmd.extend(["-w", render_res[0], "-h", render_res[1]])

        cmd.extend(["-r", str(self.profile.master_fps)])

        if self.profile.sync_mode in ["freesync", "gsync", "adaptive"]:
            cmd.append("--adaptive-sync")

        cmd.extend([
            "--force-grab-cursor",
            "--steam",
            "-f",
            "-e",
        ])

        if self.profile.center_config.gpu_id:
            pass

        return cmd

    def start(self, game_command: List[str]) -> bool:
        """Start gamescope with the game"""
        try:
            cmd = self.build_command()
            cmd.append("--")
            cmd.extend(game_command)

            logger.info(f"Starting gamescope: {' '.join(cmd)}")

            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                env=self._build_env()
            )
            self.running = True
            return True
        except Exception as e:
            logger.error(f"Failed to start gamescope: {e}")
            return False

    def _build_env(self) -> Dict[str, str]:
        """Build environment for split rendering"""
        env = os.environ.copy()

        if self.profile.center_config.gpu_id.startswith("nvidia"):
            gpu_idx = self.profile.center_config.gpu_id.split(':')[1]
            env["__NV_PRIME_RENDER_OFFLOAD"] = "1"
            env["__GLX_VENDOR_LIBRARY_NAME"] = "nvidia"
            env["__VK_LAYER_NV_optimus"] = "NVIDIA_only"
            env["VK_ICD_FILENAMES"] = "/usr/share/vulkan/icd.d/nvidia_icd.json"
            env["CUDA_VISIBLE_DEVICES"] = gpu_idx

        env["MANGOHUD"] = "1"
        env["MANGOHUD_CONFIG"] = "fps,frametime,gpu_stats,cpu_stats,vram,ram"

        env["AEGIS_SPLIT_RENDER"] = "1"
        env["AEGIS_CENTER_GPU"] = self.profile.center_config.gpu_id
        env["AEGIS_RIM_GPU"] = self.profile.rim_config.gpu_id
        env["AEGIS_CENTER_RADIUS"] = str(self.profile.center_radius_pct)

        return env

    def stop(self):
        """Stop gamescope"""
        if self.process:
            self.process.terminate()
            try:
                self.process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.process.kill()
            self.running = False


class RenderOrchestrator:
    """Main orchestrator daemon"""

    def __init__(self):
        self.gpus: List[GPUDevice] = []
        self.profiles: Dict[str, SplitRenderProfile] = {}
        self.active_profile: Optional[SplitRenderProfile] = None
        self.active_session: Optional[Dict] = None
        self.gamescope: Optional[GamescopeManager] = None
        self.synchronizer: Optional[FrameSynchronizer] = None
        self.daemon_manager: Optional[UpscalerDaemonManager] = None
        self.metrics_collector: Optional[MetricsCollector] = None
        self.metrics: Dict[str, Any] = {}
        self.running = False
        self.server_socket = None
        self.lock = threading.Lock()

        self._ensure_dirs()
        self._load_profiles()

    def _ensure_dirs(self):
        """Create necessary directories"""
        USER_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        PROFILES_DIR.mkdir(parents=True, exist_ok=True)

    def _load_profiles(self):
        """Load saved profiles"""
        for profile_file in PROFILES_DIR.glob("*.json"):
            try:
                with open(profile_file) as f:
                    data = json.load(f)
                profile = SplitRenderProfile(
                    name=data.get("name", profile_file.stem),
                    game_id=data.get("game_id", ""),
                    description=data.get("description", ""),
                    enabled=data.get("enabled", True),
                    sync_mode=data.get("sync_mode", "freesync"),
                    master_fps=data.get("master_fps", 144),
                    center_radius_pct=data.get("center_radius_pct", 60.0),
                    region_blend_px=data.get("region_blend_px", 32)
                )

                if "center_config" in data:
                    cc = data["center_config"]
                    profile.center_config = RegionConfig(
                        region="center",
                        gpu_id=cc.get("gpu_id", ""),
                        render_resolution=cc.get("render_resolution", "1920x1080"),
                        output_resolution=cc.get("output_resolution", "2560x1440"),
                        upscaler_backend=cc.get("upscaler_backend", "fsr2"),
                        upscaler_quality=cc.get("upscaler_quality", "balanced"),
                        target_fps=cc.get("target_fps", 60)
                    )

                if "rim_config" in data:
                    rc = data["rim_config"]
                    profile.rim_config = RegionConfig(
                        region="rim",
                        gpu_id=rc.get("gpu_id", ""),
                        render_resolution=rc.get("render_resolution", "1280x720"),
                        output_resolution=rc.get("output_resolution", "2560x1440"),
                        upscaler_backend=rc.get("upscaler_backend", "fsr1"),
                        upscaler_quality=rc.get("upscaler_quality", "performance"),
                        target_fps=rc.get("target_fps", 60)
                    )

                self.profiles[profile.name] = profile
                logger.info(f"Loaded profile: {profile.name}")
            except Exception as e:
                logger.error(f"Failed to load profile {profile_file}: {e}")

    def save_profile(self, profile: SplitRenderProfile):
        """Save a profile to disk"""
        profile_file = PROFILES_DIR / f"{profile.name}.json"
        data = {
            "name": profile.name,
            "game_id": profile.game_id,
            "description": profile.description,
            "enabled": profile.enabled,
            "sync_mode": profile.sync_mode,
            "master_fps": profile.master_fps,
            "center_radius_pct": profile.center_radius_pct,
            "region_blend_px": profile.region_blend_px,
            "center_config": {
                "gpu_id": profile.center_config.gpu_id,
                "render_resolution": profile.center_config.render_resolution,
                "output_resolution": profile.center_config.output_resolution,
                "upscaler_backend": profile.center_config.upscaler_backend,
                "upscaler_quality": profile.center_config.upscaler_quality,
                "target_fps": profile.center_config.target_fps
            },
            "rim_config": {
                "gpu_id": profile.rim_config.gpu_id,
                "render_resolution": profile.rim_config.render_resolution,
                "output_resolution": profile.rim_config.output_resolution,
                "upscaler_backend": profile.rim_config.upscaler_backend,
                "upscaler_quality": profile.rim_config.upscaler_quality,
                "target_fps": profile.rim_config.target_fps
            },
            "created": profile.created or datetime.now().isoformat(),
            "last_used": datetime.now().isoformat()
        }
        with open(profile_file, 'w') as f:
            json.dump(data, f, indent=2)
        self.profiles[profile.name] = profile

    def enumerate_gpus(self) -> List[GPUDevice]:
        """Detect all available GPUs"""
        self.gpus = GPUEnumerator.enumerate_all()
        logger.info(f"Detected {len(self.gpus)} GPUs:")
        for gpu in self.gpus:
            logger.info(f"  - {gpu.id}: {gpu.name} ({gpu.vendor}, {gpu.vram_mb}MB VRAM)")
        return self.gpus

    def validate_profile(self, profile: SplitRenderProfile) -> Tuple[bool, str]:
        """Validate a profile can run on current hardware"""
        if not self.gpus:
            self.enumerate_gpus()

        if len(self.gpus) < 2:
            return False, "Dual-GPU split rendering requires at least 2 GPUs"

        gpu_ids = [g.id for g in self.gpus]

        if profile.center_config.gpu_id and profile.center_config.gpu_id not in gpu_ids:
            return False, f"Center GPU {profile.center_config.gpu_id} not found"

        if profile.rim_config.gpu_id and profile.rim_config.gpu_id not in gpu_ids:
            return False, f"Rim GPU {profile.rim_config.gpu_id} not found"

        if profile.center_config.gpu_id == profile.rim_config.gpu_id:
            return False, "Center and Rim must use different GPUs"

        return True, "Profile valid"

    def start_session(self, profile_name: str, game_command: List[str]) -> Tuple[bool, str]:
        """Start a split-render gaming session with full component lifecycle"""
        if profile_name not in self.profiles:
            return False, f"Profile '{profile_name}' not found"

        profile = self.profiles[profile_name]

        if not self.gpus:
            self.enumerate_gpus()

        valid, msg = self.validate_profile(profile)
        if not valid:
            return False, msg

        center_gpu_id = profile.center_config.gpu_id
        rim_gpu_id = profile.rim_config.gpu_id

        gpu_ids = [g.id for g in self.gpus]
        if center_gpu_id not in gpu_ids:
            return False, f"Center GPU '{center_gpu_id}' not found in available GPUs"
        if rim_gpu_id not in gpu_ids:
            return False, f"Rim GPU '{rim_gpu_id}' not found in available GPUs"
        if center_gpu_id == rim_gpu_id:
            return False, "Center and Rim GPUs must be different for split rendering"

        with self.lock:
            if self.active_session:
                return False, "Session already active"

            self.active_profile = profile
            self.synchronizer = FrameSynchronizer(profile.sync_mode, profile.master_fps)
            self.daemon_manager = UpscalerDaemonManager()

            success, err = self.daemon_manager.start_daemon("center", center_gpu_id)
            if not success:
                self._cleanup_session()
                return False, f"Failed to start center upscaler daemon: {err}"

            success, err = self.daemon_manager.start_daemon("rim", rim_gpu_id)
            if not success:
                self._cleanup_session()
                return False, f"Failed to start rim upscaler daemon: {err}"

            logger.info("Waiting for upscaler daemons to be ready...")

            if not self.daemon_manager.wait_for_daemon_ready("center", timeout=10.0):
                self._cleanup_session()
                return False, "Center upscaler daemon failed to become ready"

            if not self.daemon_manager.wait_for_daemon_ready("rim", timeout=10.0):
                self._cleanup_session()
                return False, "Rim upscaler daemon failed to become ready"

            logger.info("Both upscaler daemons are ready")

            self.gamescope = GamescopeManager(profile)
            if not self.gamescope.start(game_command):
                self._cleanup_session()
                return False, "Failed to start gamescope compositor"

            self.metrics_collector = MetricsCollector(self.daemon_manager, self.synchronizer)
            self.metrics_collector.start(poll_interval=0.1)

            self.active_session = {
                "profile": profile_name,
                "game_command": game_command,
                "started": datetime.now().isoformat(),
                "gamescope_pid": self.gamescope.process.pid if self.gamescope.process else None,
                "center_gpu": center_gpu_id,
                "rim_gpu": rim_gpu_id,
                "upscaler_daemons": self.daemon_manager.get_all_status()
            }

            logger.info(f"Started split-render session: {profile_name}")
            logger.info(f"  Center GPU: {center_gpu_id}")
            logger.info(f"  Rim GPU: {rim_gpu_id}")
            logger.info(f"  Gamescope PID: {self.active_session['gamescope_pid']}")

            return True, "Session started successfully"

    def _cleanup_session(self):
        """Internal cleanup helper for failed session starts"""
        if self.metrics_collector:
            self.metrics_collector.stop()
            self.metrics_collector = None

        if self.gamescope:
            self.gamescope.stop()
            self.gamescope = None

        if self.daemon_manager:
            self.daemon_manager.stop_all()
            self.daemon_manager = None

        self.synchronizer = None
        self.active_profile = None
        self.active_session = None

    def stop_session(self) -> Tuple[bool, str]:
        """Stop the active session with full cleanup"""
        with self.lock:
            if not self.active_session:
                return False, "No active session"

            profile_name = self.active_session.get("profile", "unknown")
            logger.info(f"Stopping split-render session: {profile_name}")

            if self.metrics_collector:
                logger.info("Stopping metrics collection thread...")
                self.metrics_collector.stop()
                self.metrics_collector = None

            if self.gamescope:
                logger.info("Stopping gamescope compositor...")
                self.gamescope.stop()
                self.gamescope = None

            if self.daemon_manager:
                logger.info("Stopping upscaler daemons...")
                self.daemon_manager.stop_all()
                self.daemon_manager = None

            self.active_session = None
            self.active_profile = None
            self.synchronizer = None
            self.metrics = {}

            logger.info("Split-render session stopped successfully")
            return True, "Session stopped"

    def get_session_metrics(self) -> Dict[str, Any]:
        """Get current real-time metrics from the active session"""
        if not self.active_session:
            return {
                "active": False,
                "message": "No active session"
            }

        if self.metrics_collector:
            metrics = self.metrics_collector.get_metrics()
        else:
            metrics = {}

        daemon_status = {}
        if self.daemon_manager:
            daemon_status = self.daemon_manager.get_all_status()

        vrr_params = {}
        if self.synchronizer:
            vrr_params = self.synchronizer.get_vrr_parameters()

        return {
            "active": True,
            "profile": self.active_session.get("profile"),
            "started": self.active_session.get("started"),
            "center_fps": metrics.get("center_fps", 0.0),
            "center_frametime": metrics.get("center_frametime", 0.0),
            "center_latency": metrics.get("center_latency", 0.0),
            "rim_fps": metrics.get("rim_fps", 0.0),
            "rim_frametime": metrics.get("rim_frametime", 0.0),
            "rim_latency": metrics.get("rim_latency", 0.0),
            "composite_fps": metrics.get("composite_fps", 0.0),
            "sync_status": metrics.get("sync_status", "unknown"),
            "vrr_active": metrics.get("vrr_active", False),
            "vrr_parameters": vrr_params,
            "upscaler_daemons": daemon_status,
            "last_update": metrics.get("last_update")
        }

    def get_status(self) -> Dict:
        """Get orchestrator status"""
        session_metrics = self.get_session_metrics() if self.active_session else None

        daemon_status = {}
        if self.daemon_manager:
            daemon_status = self.daemon_manager.get_all_status()

        return {
            "running": self.running,
            "gpus": [asdict(g) for g in self.gpus],
            "profiles": list(self.profiles.keys()),
            "active_session": self.active_session,
            "session_metrics": session_metrics,
            "upscaler_daemons": daemon_status
        }

    def handle_client(self, conn, addr):
        """Handle client connection"""
        try:
            data = conn.recv(4096).decode()
            if not data:
                return

            request = json.loads(data)
            cmd = request.get("command")
            response = {"success": False, "error": "Unknown command"}

            if cmd == "status":
                response = {"success": True, "data": self.get_status()}

            elif cmd == "enumerate_gpus":
                gpus = self.enumerate_gpus()
                response = {"success": True, "data": [asdict(g) for g in gpus]}

            elif cmd == "list_profiles":
                response = {"success": True, "data": list(self.profiles.keys())}

            elif cmd == "get_profile":
                name = request.get("name")
                if name in self.profiles:
                    p = self.profiles[name]
                    response = {"success": True, "data": {
                        "name": p.name,
                        "game_id": p.game_id,
                        "sync_mode": p.sync_mode,
                        "master_fps": p.master_fps,
                        "center_radius_pct": p.center_radius_pct,
                        "center_config": asdict(p.center_config),
                        "rim_config": asdict(p.rim_config)
                    }}
                else:
                    response = {"success": False, "error": "Profile not found"}

            elif cmd == "save_profile":
                pdata = request.get("profile", {})
                profile = SplitRenderProfile(
                    name=pdata.get("name", "default"),
                    game_id=pdata.get("game_id", ""),
                    sync_mode=pdata.get("sync_mode", "freesync"),
                    master_fps=pdata.get("master_fps", 144),
                    center_radius_pct=pdata.get("center_radius_pct", 60.0)
                )
                if "center_config" in pdata:
                    profile.center_config = RegionConfig(**pdata["center_config"])
                if "rim_config" in pdata:
                    profile.rim_config = RegionConfig(**pdata["rim_config"])
                self.save_profile(profile)
                response = {"success": True}

            elif cmd == "start_session":
                profile_name = request.get("profile")
                game_cmd = request.get("game_command", [])
                success, msg = self.start_session(profile_name, game_cmd)
                response = {"success": success, "message": msg}

            elif cmd == "stop_session":
                success, msg = self.stop_session()
                response = {"success": success, "message": msg}

            elif cmd == "validate_profile":
                name = request.get("name")
                if name in self.profiles:
                    valid, msg = self.validate_profile(self.profiles[name])
                    response = {"success": True, "valid": valid, "message": msg}
                else:
                    response = {"success": False, "error": "Profile not found"}

            elif cmd == "get_metrics":
                metrics_data = self.get_session_metrics()
                response = {"success": True, "data": metrics_data}

            conn.sendall(json.dumps(response).encode())
        except Exception as e:
            logger.error(f"Client error: {e}")
        finally:
            conn.close()

    def run_daemon(self):
        """Run as a background daemon"""
        if os.path.exists(SOCKET_PATH):
            os.unlink(SOCKET_PATH)

        self.server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.server_socket.bind(SOCKET_PATH)
        self.server_socket.listen(5)
        os.chmod(SOCKET_PATH, 0o666)

        self.running = True
        self.enumerate_gpus()

        logger.info(f"Render Orchestrator daemon started on {SOCKET_PATH}")

        def signal_handler(sig, frame):
            logger.info("Shutting down...")
            self.running = False

            if self.active_session:
                logger.info("Cleaning up active session before shutdown...")
                self.stop_session()

            if self.server_socket:
                self.server_socket.close()
            sys.exit(0)

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        while self.running:
            try:
                conn, addr = self.server_socket.accept()
                thread = threading.Thread(target=self.handle_client, args=(conn, addr))
                thread.daemon = True
                thread.start()
            except Exception as e:
                if self.running:
                    logger.error(f"Server error: {e}")


class OrchestratorClient:
    """Client for communicating with the orchestrator daemon"""

    def __init__(self):
        self.socket_path = SOCKET_PATH

    def _send_command(self, command: Dict) -> Dict:
        """Send command to daemon"""
        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.sendall(json.dumps(command).encode())
            response = sock.recv(65536).decode()
            sock.close()
            return json.loads(response)
        except Exception as e:
            return {"success": False, "error": str(e)}

    def get_status(self) -> Dict:
        return self._send_command({"command": "status"})

    def enumerate_gpus(self) -> Dict:
        return self._send_command({"command": "enumerate_gpus"})

    def list_profiles(self) -> Dict:
        return self._send_command({"command": "list_profiles"})

    def get_profile(self, name: str) -> Dict:
        return self._send_command({"command": "get_profile", "name": name})

    def save_profile(self, profile: Dict) -> Dict:
        return self._send_command({"command": "save_profile", "profile": profile})

    def start_session(self, profile_name: str, game_command: List[str]) -> Dict:
        return self._send_command({
            "command": "start_session",
            "profile": profile_name,
            "game_command": game_command
        })

    def stop_session(self) -> Dict:
        return self._send_command({"command": "stop_session"})

    def get_metrics(self) -> Dict:
        return self._send_command({"command": "get_metrics"})


def main():
    parser = argparse.ArgumentParser(
        description="Aegis Render Orchestrator - Dual-GPU Split Rendering"
    )
    parser.add_argument("--daemon", action="store_true", help="Run as daemon")
    parser.add_argument("--status", action="store_true", help="Show daemon status")
    parser.add_argument("--metrics", action="store_true", help="Show real-time session metrics")
    parser.add_argument("--list-gpus", action="store_true", help="List detected GPUs")
    parser.add_argument("--list-profiles", action="store_true", help="List profiles")
    parser.add_argument("--create-profile", metavar="NAME", help="Create a new profile")
    parser.add_argument("--start", metavar="PROFILE", help="Start session with profile")
    parser.add_argument("--stop", action="store_true", help="Stop active session")
    parser.add_argument("--game", metavar="CMD", help="Game command for --start")
    parser.add_argument("--center-gpu", metavar="ID", help="GPU for center region")
    parser.add_argument("--rim-gpu", metavar="ID", help="GPU for rim region")
    parser.add_argument("--center-upscaler", default="fsr2", help="Upscaler for center")
    parser.add_argument("--rim-upscaler", default="fsr1", help="Upscaler for rim")
    parser.add_argument("--fps", type=int, default=144, help="Target FPS")
    parser.add_argument("--sync", default="freesync", choices=["vsync", "freesync", "gsync", "adaptive", "unlocked"])

    args = parser.parse_args()

    if args.daemon:
        orchestrator = RenderOrchestrator()
        orchestrator.run_daemon()

    elif args.list_gpus:
        gpus = GPUEnumerator.enumerate_all()
        if gpus:
            print("Detected GPUs:\n")
            for gpu in gpus:
                print(f"  {gpu.id}")
                print(f"    Name:   {gpu.name}")
                print(f"    Vendor: {gpu.vendor}")
                print(f"    VRAM:   {gpu.vram_mb} MB")
                print(f"    Driver: {gpu.driver}")
                print()
        else:
            print("No GPUs detected")

    elif args.status:
        client = OrchestratorClient()
        result = client.get_status()
        if result.get("success"):
            data = result["data"]
            print(f"Daemon running: {data.get('running', False)}")
            print(f"GPUs detected: {len(data.get('gpus', []))}")
            print(f"Profiles: {', '.join(data.get('profiles', []))}")
            if data.get("active_session"):
                session = data["active_session"]
                print(f"\nActive session:")
                print(f"  Profile: {session.get('profile')}")
                print(f"  Started: {session.get('started')}")
                print(f"  Center GPU: {session.get('center_gpu')}")
                print(f"  Rim GPU: {session.get('rim_gpu')}")
                if data.get("session_metrics"):
                    m = data["session_metrics"]
                    print(f"\n  Metrics:")
                    print(f"    Center FPS: {m.get('center_fps', 0):.1f}")
                    print(f"    Rim FPS: {m.get('rim_fps', 0):.1f}")
                    print(f"    Composite FPS: {m.get('composite_fps', 0):.1f}")
                    print(f"    VRR Active: {m.get('vrr_active', False)}")
        else:
            print(f"Error: {result.get('error', 'Could not connect to daemon')}")

    elif args.metrics:
        client = OrchestratorClient()
        result = client.get_metrics()
        if result.get("success"):
            data = result.get("data", {})
            if not data.get("active"):
                print("No active session")
            else:
                print("Split Render Session Metrics")
                print("=" * 40)
                print(f"Profile: {data.get('profile')}")
                print(f"Started: {data.get('started')}")
                print()
                print("Center Region:")
                print(f"  FPS:        {data.get('center_fps', 0):.1f}")
                print(f"  Frametime:  {data.get('center_frametime', 0):.2f} ms")
                print(f"  Latency:    {data.get('center_latency', 0):.2f} ms")
                print()
                print("Rim Region:")
                print(f"  FPS:        {data.get('rim_fps', 0):.1f}")
                print(f"  Frametime:  {data.get('rim_frametime', 0):.2f} ms")
                print(f"  Latency:    {data.get('rim_latency', 0):.2f} ms")
                print()
                print("Composite:")
                print(f"  Output FPS: {data.get('composite_fps', 0):.1f}")
                print(f"  Sync Mode:  {data.get('sync_status', 'unknown')}")
                print(f"  VRR Active: {data.get('vrr_active', False)}")
                print()
                if data.get("upscaler_daemons"):
                    print("Upscaler Daemons:")
                    for region, status in data["upscaler_daemons"].items():
                        healthy = "✓" if status.get("healthy") else "✗"
                        running = "running" if status.get("running") else "stopped"
                        print(f"  {region}: {running} {healthy} (GPU: {status.get('gpu_id')})")
        else:
            print(f"Error: {result.get('error', 'Could not connect to daemon')}")

    elif args.list_profiles:
        client = OrchestratorClient()
        result = client.list_profiles()
        if result.get("success"):
            profiles = result.get("data", [])
            if profiles:
                print("Saved Profiles:\n")
                for p in profiles:
                    print(f"  - {p}")
            else:
                print("No profiles saved")
        else:
            print(f"Error: {result.get('error')}")

    elif args.create_profile:
        if not args.center_gpu or not args.rim_gpu:
            print("Error: --center-gpu and --rim-gpu required")
            sys.exit(1)

        profile = {
            "name": args.create_profile,
            "sync_mode": args.sync,
            "master_fps": args.fps,
            "center_config": {
                "region": "center",
                "gpu_id": args.center_gpu,
                "upscaler_backend": args.center_upscaler,
                "upscaler_quality": "balanced"
            },
            "rim_config": {
                "region": "rim",
                "gpu_id": args.rim_gpu,
                "upscaler_backend": args.rim_upscaler,
                "upscaler_quality": "performance"
            }
        }

        client = OrchestratorClient()
        result = client.save_profile(profile)
        if result.get("success"):
            print(f"Profile '{args.create_profile}' created successfully")
        else:
            print(f"Error: {result.get('error')}")

    elif args.start:
        if not args.game:
            print("Error: --game required with --start")
            sys.exit(1)

        client = OrchestratorClient()
        result = client.start_session(args.start, args.game.split())
        if result.get("success"):
            print(f"Session started with profile '{args.start}'")
        else:
            print(f"Error: {result.get('message', result.get('error'))}")

    elif args.stop:
        client = OrchestratorClient()
        result = client.stop_session()
        if result.get("success"):
            print("Session stopped")
        else:
            print(f"Error: {result.get('message', result.get('error'))}")

    else:
        parser.print_help()


if __name__ == "__main__":
    main()
