#!/usr/bin/env python3
"""
Aegis Meet v1.0.0
Comprehensive video conferencing solution

Features:
  - GTK3 GUI with modern interface
  - Quick join for Jitsi, Zoom, Google Meet, Microsoft Teams via browser
  - Built-in Jitsi client (webview or native)
  - Screen sharing setup helper
  - Virtual camera support (OBS integration)
  - Background blur/replacement settings
  - Audio device selector with test
  - Meeting scheduler with calendar integration
  - Meeting recording (local save)
  - --status CLI for health check
  - Tier gating (Freemium: web only, Paid: full features)

Copyright (c) 2024 Aegis OS Team
License: GPL-3.0
"""

import os
import sys
import json
import subprocess
import argparse
import shutil
import re
import threading
import time
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field, asdict
from enum import Enum
import webbrowser
import uuid

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog, simpledialog
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

VERSION = "1.0.0"
APP_NAME = "Aegis Meet"
CONFIG_DIR = Path.home() / ".config" / "aegis" / "meet"
CONFIG_FILE = CONFIG_DIR / "config.json"
MEETINGS_FILE = CONFIG_DIR / "meetings.json"
RECORDINGS_DIR = CONFIG_DIR / "recordings"
BACKGROUNDS_DIR = CONFIG_DIR / "backgrounds"
TIER_CONFIG = Path("/etc/aegis/tier.conf")


class Tier(Enum):
    FREE = "free"
    FREEMIUM = "freemium"
    BASIC = "basic"
    PRO = "pro"
    ENTERPRISE = "enterprise"


class MeetingPlatform(Enum):
    JITSI = "jitsi"
    ZOOM = "zoom"
    GOOGLE_MEET = "google_meet"
    TEAMS = "teams"
    CUSTOM = "custom"


class AudioTestState(Enum):
    IDLE = "idle"
    TESTING = "testing"
    PLAYING = "playing"


@dataclass
class MeetingPlatformConfig:
    id: str
    name: str
    icon: str
    url_pattern: str
    join_url_template: str
    description: str
    requires_app: bool = False
    app_command: str = ""


PLATFORMS = [
    MeetingPlatformConfig(
        "jitsi", "Jitsi Meet", "video-display",
        r"meet\.jit\.si/[\w-]+",
        "https://meet.jit.si/{room}",
        "Free, open-source video conferencing"
    ),
    MeetingPlatformConfig(
        "zoom", "Zoom", "zoom",
        r"zoom\.us/j/\d+",
        "https://zoom.us/j/{meeting_id}",
        "Popular video conferencing platform",
        requires_app=True,
        app_command="zoom"
    ),
    MeetingPlatformConfig(
        "google_meet", "Google Meet", "google",
        r"meet\.google\.com/[\w-]+",
        "https://meet.google.com/{code}",
        "Google's video conferencing service"
    ),
    MeetingPlatformConfig(
        "teams", "Microsoft Teams", "teams",
        r"teams\.microsoft\.com/l/meetup-join",
        "",
        "Microsoft's collaboration platform",
        requires_app=True,
        app_command="teams"
    ),
]


@dataclass
class ScheduledMeeting:
    id: str
    title: str
    platform: str
    url: str
    start_time: str
    duration_minutes: int = 60
    description: str = ""
    reminder_sent: bool = False
    recurring: str = ""


@dataclass
class AudioDevice:
    id: str
    name: str
    device_type: str
    is_default: bool = False


@dataclass
class BackgroundSetting:
    mode: str
    blur_intensity: int = 10
    custom_image: str = ""
    virtual_background: str = ""


@dataclass
class MeetConfig:
    default_platform: str = "jitsi"
    default_audio_input: str = ""
    default_audio_output: str = ""
    default_camera: str = ""
    enable_virtual_camera: bool = False
    obs_virtual_camera: bool = False
    background_mode: str = "none"
    blur_intensity: int = 10
    custom_background: str = ""
    auto_join_audio: bool = True
    auto_start_video: bool = False
    recording_path: str = ""
    recording_format: str = "mkv"
    enable_notifications: bool = True
    reminder_minutes: int = 5
    jitsi_server: str = "meet.jit.si"
    calendar_integration: str = ""


class TierManager:
    def __init__(self):
        self.current_tier = self._load_tier()
    
    def _load_tier(self) -> Tier:
        if TIER_CONFIG.exists():
            try:
                with open(TIER_CONFIG, 'r') as f:
                    content = f.read().strip()
                    for line in content.split('\n'):
                        if line.startswith('TIER='):
                            tier_value = line.split('=')[1].strip().strip('"\'').lower()
                            try:
                                return Tier(tier_value)
                            except ValueError:
                                pass
            except Exception:
                pass
        return Tier.FREEMIUM
    
    def has_access(self, required_tier: str) -> bool:
        tier_hierarchy = {
            Tier.FREE: 0,
            Tier.FREEMIUM: 0,
            Tier.BASIC: 1,
            Tier.PRO: 2,
            Tier.ENTERPRISE: 3
        }
        try:
            required = Tier(required_tier)
        except ValueError:
            return True
        return tier_hierarchy.get(self.current_tier, 0) >= tier_hierarchy.get(required, 0)
    
    def get_tier_name(self) -> str:
        return self.current_tier.value.title()
    
    def is_paid(self) -> bool:
        return self.current_tier in [Tier.BASIC, Tier.PRO, Tier.ENTERPRISE]


class MeetService:
    def __init__(self):
        self.config = self._load_config()
        self.platforms = {p.id: p for p in PLATFORMS}
        self.meetings: List[ScheduledMeeting] = []
        self.tier_manager = TierManager()
        self.audio_devices: Dict[str, List[AudioDevice]] = {"input": [], "output": []}
        self.video_devices: List[Dict] = []
        self.recording_process: Optional[subprocess.Popen] = None
        self._load_meetings()
        self._detect_audio_devices()
        self._detect_video_devices()
        self._ensure_directories()
    
    def _ensure_directories(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        RECORDINGS_DIR.mkdir(parents=True, exist_ok=True)
        BACKGROUNDS_DIR.mkdir(parents=True, exist_ok=True)
        if not self.config.recording_path:
            self.config.recording_path = str(RECORDINGS_DIR)
            self._save_config()
    
    def _load_config(self) -> MeetConfig:
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE, 'r') as f:
                    data = json.load(f)
                    return MeetConfig(**data)
            except Exception:
                pass
        config = MeetConfig()
        self._save_config(config)
        return config
    
    def _save_config(self, config: Optional[MeetConfig] = None):
        if config:
            self.config = config
        with open(CONFIG_FILE, 'w') as f:
            json.dump(asdict(self.config), f, indent=2)
    
    def _load_meetings(self):
        if MEETINGS_FILE.exists():
            try:
                with open(MEETINGS_FILE, 'r') as f:
                    data = json.load(f)
                    self.meetings = [ScheduledMeeting(**m) for m in data]
            except Exception:
                pass
    
    def _save_meetings(self):
        with open(MEETINGS_FILE, 'w') as f:
            json.dump([asdict(m) for m in self.meetings], f, indent=2)
    
    def _detect_audio_devices(self):
        self.audio_devices = {"input": [], "output": []}
        try:
            result = subprocess.run(
                ['pactl', 'list', 'sources', 'short'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if line:
                        parts = line.split('\t')
                        if len(parts) >= 2:
                            self.audio_devices["input"].append(AudioDevice(
                                id=parts[0],
                                name=parts[1],
                                device_type="input",
                                is_default="RUNNING" in line
                            ))
        except Exception:
            pass
        
        try:
            result = subprocess.run(
                ['pactl', 'list', 'sinks', 'short'],
                capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if line:
                        parts = line.split('\t')
                        if len(parts) >= 2:
                            self.audio_devices["output"].append(AudioDevice(
                                id=parts[0],
                                name=parts[1],
                                device_type="output",
                                is_default="RUNNING" in line
                            ))
        except Exception:
            pass
    
    def _detect_video_devices(self):
        self.video_devices = []
        video_path = Path("/dev")
        try:
            for dev in video_path.glob("video*"):
                try:
                    result = subprocess.run(
                        ['v4l2-ctl', '-d', str(dev), '--info'],
                        capture_output=True, text=True, timeout=2
                    )
                    name = str(dev)
                    for line in result.stdout.split('\n'):
                        if 'Card type' in line:
                            name = line.split(':')[1].strip()
                            break
                    self.video_devices.append({
                        "id": str(dev),
                        "name": name,
                        "path": str(dev)
                    })
                except Exception:
                    self.video_devices.append({
                        "id": str(dev),
                        "name": str(dev.name),
                        "path": str(dev)
                    })
        except Exception:
            pass
    
    def join_meeting(self, platform_id: str, meeting_url: str = "", room_code: str = "") -> bool:
        if platform_id not in self.platforms:
            return False
        
        platform = self.platforms[platform_id]
        
        if meeting_url:
            url = meeting_url
        elif room_code:
            url = platform.join_url_template.format(
                room=room_code, 
                code=room_code,
                meeting_id=room_code
            )
        else:
            return False
        
        try:
            if platform.requires_app and shutil.which(platform.app_command):
                subprocess.Popen([platform.app_command, url],
                               stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            else:
                webbrowser.open(url)
            return True
        except Exception:
            return False
    
    def create_jitsi_meeting(self, room_name: str = "") -> str:
        if not room_name:
            room_name = f"aegis-{uuid.uuid4().hex[:8]}"
        room_name = re.sub(r'[^a-zA-Z0-9-]', '-', room_name)
        url = f"https://{self.config.jitsi_server}/{room_name}"
        return url
    
    def schedule_meeting(self, title: str, platform: str, url: str, 
                        start_time: str, duration: int = 60,
                        description: str = "") -> ScheduledMeeting:
        meeting = ScheduledMeeting(
            id=str(uuid.uuid4()),
            title=title,
            platform=platform,
            url=url,
            start_time=start_time,
            duration_minutes=duration,
            description=description
        )
        self.meetings.append(meeting)
        self._save_meetings()
        return meeting
    
    def delete_meeting(self, meeting_id: str) -> bool:
        self.meetings = [m for m in self.meetings if m.id != meeting_id]
        self._save_meetings()
        return True
    
    def get_upcoming_meetings(self) -> List[ScheduledMeeting]:
        now = datetime.now()
        upcoming = []
        for meeting in self.meetings:
            try:
                meeting_time = datetime.fromisoformat(meeting.start_time)
                if meeting_time >= now:
                    upcoming.append(meeting)
            except Exception:
                pass
        return sorted(upcoming, key=lambda m: m.start_time)
    
    def test_audio_input(self, device_id: str = "") -> bool:
        try:
            cmd = ['arecord', '-d', '3', '-f', 'cd', '/tmp/aegis-audio-test.wav']
            if device_id:
                cmd.extend(['-D', device_id])
            result = subprocess.run(cmd, capture_output=True, timeout=5)
            return result.returncode == 0
        except Exception:
            return False
    
    def test_audio_output(self, device_id: str = "") -> bool:
        try:
            test_file = '/tmp/aegis-audio-test.wav'
            if not Path(test_file).exists():
                subprocess.run(['speaker-test', '-t', 'wav', '-l', '1', '-c', '2'],
                             capture_output=True, timeout=3)
                return True
            cmd = ['aplay', test_file]
            if device_id:
                cmd.extend(['-D', device_id])
            result = subprocess.run(cmd, capture_output=True, timeout=5)
            return result.returncode == 0
        except Exception:
            return False
    
    def check_screen_sharing_setup(self) -> Dict:
        status = {
            "xdg_portal": False,
            "pipewire": False,
            "screen_capture": False,
            "wayland": os.environ.get('XDG_SESSION_TYPE') == 'wayland'
        }
        
        if shutil.which('xdg-desktop-portal'):
            try:
                result = subprocess.run(['pgrep', '-x', 'xdg-desktop-portal'],
                                       capture_output=True)
                status["xdg_portal"] = result.returncode == 0
            except Exception:
                pass
        
        try:
            result = subprocess.run(['pgrep', '-x', 'pipewire'], capture_output=True)
            status["pipewire"] = result.returncode == 0
        except Exception:
            pass
        
        status["screen_capture"] = status["xdg_portal"] or not status["wayland"]
        
        return status
    
    def setup_screen_sharing(self) -> Tuple[bool, str]:
        try:
            subprocess.Popen(['xdg-desktop-portal'], 
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True, "Screen sharing portal started"
        except Exception as e:
            return False, str(e)
    
    def check_obs_virtual_camera(self) -> bool:
        if not shutil.which('obs'):
            return False
        
        v4l2_path = Path('/dev/video99')
        return v4l2_path.exists()
    
    def setup_virtual_camera(self) -> Tuple[bool, str]:
        if not self.tier_manager.is_paid():
            return False, "Virtual camera requires paid tier"
        
        try:
            result = subprocess.run(
                ['modprobe', 'v4l2loopback', 'devices=1', 
                 'video_nr=99', 'card_label="Aegis Virtual Camera"'],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                return True, "Virtual camera module loaded"
            return False, result.stderr or "Failed to load module"
        except Exception as e:
            return False, str(e)
    
    def start_recording(self, output_name: str = "") -> Tuple[bool, str]:
        if not self.tier_manager.is_paid():
            return False, "Recording requires paid tier"
        
        if self.recording_process:
            return False, "Recording already in progress"
        
        if not output_name:
            output_name = f"meeting_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        output_path = Path(self.config.recording_path) / f"{output_name}.{self.config.recording_format}"
        
        try:
            display = os.environ.get('DISPLAY', ':0')
            cmd = [
                'ffmpeg', '-y',
                '-f', 'x11grab', '-i', display,
                '-f', 'pulse', '-i', 'default',
                '-c:v', 'libx264', '-preset', 'ultrafast',
                '-c:a', 'aac',
                str(output_path)
            ]
            
            self.recording_process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            return True, str(output_path)
        except Exception as e:
            return False, str(e)
    
    def stop_recording(self) -> Tuple[bool, str]:
        if not self.recording_process:
            return False, "No recording in progress"
        
        try:
            self.recording_process.terminate()
            self.recording_process.wait(timeout=5)
            self.recording_process = None
            return True, "Recording stopped"
        except Exception as e:
            return False, str(e)
    
    def get_recordings(self) -> List[Dict]:
        recordings = []
        try:
            rec_path = Path(self.config.recording_path)
            if rec_path.exists():
                for f in rec_path.glob('*'):
                    if f.suffix in ['.mkv', '.mp4', '.webm', '.avi']:
                        recordings.append({
                            "name": f.name,
                            "path": str(f),
                            "size": f.stat().st_size,
                            "created": datetime.fromtimestamp(f.stat().st_ctime).isoformat()
                        })
        except Exception:
            pass
        return sorted(recordings, key=lambda x: x["created"], reverse=True)
    
    def get_background_options(self) -> List[Dict]:
        backgrounds = [
            {"id": "none", "name": "No Background Effect", "type": "none"},
            {"id": "blur", "name": "Background Blur", "type": "blur"},
        ]
        
        try:
            for f in BACKGROUNDS_DIR.glob('*'):
                if f.suffix.lower() in ['.jpg', '.jpeg', '.png', '.webp']:
                    backgrounds.append({
                        "id": f.stem,
                        "name": f.stem.replace('_', ' ').title(),
                        "type": "image",
                        "path": str(f)
                    })
        except Exception:
            pass
        
        return backgrounds
    
    def set_background(self, mode: str, value: str = "") -> bool:
        if not self.tier_manager.is_paid() and mode != "none":
            return False
        
        self.config.background_mode = mode
        if mode == "blur":
            try:
                self.config.blur_intensity = int(value) if value else 10
            except ValueError:
                pass
        elif mode == "image":
            self.config.custom_background = value
        
        self._save_config()
        return True
    
    def export_calendar(self, meetings: Optional[List[ScheduledMeeting]] = None) -> str:
        if meetings is None:
            meetings = self.meetings
        
        ical = ["BEGIN:VCALENDAR", "VERSION:2.0", "PRODID:-//Aegis Meet//EN"]
        
        for meeting in meetings:
            try:
                start = datetime.fromisoformat(meeting.start_time)
                end = start + timedelta(minutes=meeting.duration_minutes)
                
                ical.extend([
                    "BEGIN:VEVENT",
                    f"UID:{meeting.id}@aegis-meet",
                    f"DTSTART:{start.strftime('%Y%m%dT%H%M%S')}",
                    f"DTEND:{end.strftime('%Y%m%dT%H%M%S')}",
                    f"SUMMARY:{meeting.title}",
                    f"DESCRIPTION:{meeting.description}\\nURL: {meeting.url}",
                    f"URL:{meeting.url}",
                    "END:VEVENT"
                ])
            except Exception:
                pass
        
        ical.append("END:VCALENDAR")
        return "\n".join(ical)
    
    def get_status(self) -> Dict:
        screen_sharing = self.check_screen_sharing_setup()
        
        return {
            "version": VERSION,
            "status": "healthy",
            "tier": self.tier_manager.get_tier_name(),
            "is_paid": self.tier_manager.is_paid(),
            "platforms": {
                "count": len(self.platforms),
                "list": [asdict(p) if hasattr(p, '__dataclass_fields__') else {
                    "id": p.id, "name": p.name, "description": p.description
                } for p in self.platforms.values()]
            },
            "audio": {
                "input_devices": len(self.audio_devices["input"]),
                "output_devices": len(self.audio_devices["output"]),
                "inputs": [asdict(d) for d in self.audio_devices["input"]],
                "outputs": [asdict(d) for d in self.audio_devices["output"]]
            },
            "video": {
                "devices": len(self.video_devices),
                "list": self.video_devices,
                "virtual_camera_available": self.check_obs_virtual_camera(),
                "obs_installed": shutil.which('obs') is not None
            },
            "screen_sharing": screen_sharing,
            "meetings": {
                "scheduled": len(self.meetings),
                "upcoming": len(self.get_upcoming_meetings())
            },
            "recordings": {
                "count": len(self.get_recordings()),
                "recording_active": self.recording_process is not None,
                "path": self.config.recording_path
            },
            "features": {
                "virtual_camera": self.tier_manager.is_paid(),
                "background_blur": self.tier_manager.is_paid(),
                "custom_backgrounds": self.tier_manager.is_paid(),
                "recording": self.tier_manager.is_paid(),
                "calendar_integration": self.tier_manager.is_paid()
            },
            "config": asdict(self.config)
        }


class MeetGUI:
    def __init__(self, service: MeetService):
        self.service = service
        self.root = None
    
    def run(self):
        if not TKINTER_AVAILABLE:
            print("Error: Tkinter not available for GUI mode")
            sys.exit(1)
        
        self.root = tk.Tk()
        self.root.title(f"{APP_NAME} v{VERSION}")
        self.root.geometry("950x700")
        self.root.configure(bg='#1a1b26')
        
        self._setup_styles()
        self._create_widgets()
        self.root.mainloop()
    
    def _setup_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
        
        style.configure('TFrame', background='#1a1b26')
        style.configure('TLabel', background='#1a1b26', foreground='#c0caf5')
        style.configure('Header.TLabel', font=('Segoe UI', 18, 'bold'), 
                       foreground='#7aa2f7', background='#1a1b26')
        style.configure('SubHeader.TLabel', font=('Segoe UI', 12, 'bold'),
                       foreground='#9ece6a', background='#1a1b26')
        style.configure('TButton', padding=10, font=('Segoe UI', 10))
        style.configure('Platform.TButton', padding=15, font=('Segoe UI', 11))
        style.configure('Join.TButton', padding=12, font=('Segoe UI', 11, 'bold'))
        style.configure('TNotebook', background='#1a1b26')
        style.configure('TNotebook.Tab', padding=[15, 8], font=('Segoe UI', 10))
        style.configure('TEntry', padding=8)
        style.configure('TLabelframe', background='#1a1b26')
        style.configure('TLabelframe.Label', background='#1a1b26', foreground='#bb9af7')
    
    def _create_widgets(self):
        main = ttk.Frame(self.root, padding=15)
        main.pack(fill=tk.BOTH, expand=True)
        
        header = ttk.Frame(main)
        header.pack(fill=tk.X, pady=(0, 15))
        
        ttk.Label(header, text="Aegis Meet", style='Header.TLabel').pack(side=tk.LEFT)
        
        tier_frame = ttk.Frame(header)
        tier_frame.pack(side=tk.RIGHT)
        tier_name = self.service.tier_manager.get_tier_name()
        tier_color = '#9ece6a' if self.service.tier_manager.is_paid() else '#f7768e'
        ttk.Label(tier_frame, text=f"Tier: {tier_name}", 
                 foreground=tier_color).pack(side=tk.RIGHT)
        
        notebook = ttk.Notebook(main)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        quick_join_frame = self._create_quick_join_tab()
        notebook.add(quick_join_frame, text="Quick Join")
        
        schedule_frame = self._create_schedule_tab()
        notebook.add(schedule_frame, text="Schedule")
        
        settings_frame = self._create_settings_tab()
        notebook.add(settings_frame, text="Settings")
        
        recording_frame = self._create_recording_tab()
        notebook.add(recording_frame, text="Recording")
        
        status_frame = self._create_status_tab()
        notebook.add(status_frame, text="Status")
    
    def _create_quick_join_tab(self) -> ttk.Frame:
        frame = ttk.Frame(self.root, padding=20)
        
        join_frame = ttk.LabelFrame(frame, text="Join Meeting", padding=15)
        join_frame.pack(fill=tk.X, pady=10)
        
        url_frame = ttk.Frame(join_frame)
        url_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(url_frame, text="Meeting URL or Room:").pack(anchor=tk.W)
        self.meeting_url_entry = ttk.Entry(url_frame, width=60, font=('Segoe UI', 11))
        self.meeting_url_entry.pack(fill=tk.X, pady=5)
        
        ttk.Label(url_frame, text="Or select platform and enter room code:",
                 foreground='#565f89').pack(anchor=tk.W, pady=(10, 5))
        
        platform_frame = ttk.Frame(join_frame)
        platform_frame.pack(fill=tk.X, pady=10)
        
        self.selected_platform = tk.StringVar(value="jitsi")
        
        for platform in self.service.platforms.values():
            rb = ttk.Radiobutton(platform_frame, text=platform.name,
                                variable=self.selected_platform, value=platform.id)
            rb.pack(side=tk.LEFT, padx=15)
        
        room_frame = ttk.Frame(join_frame)
        room_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(room_frame, text="Room Code:").pack(anchor=tk.W)
        self.room_code_entry = ttk.Entry(room_frame, width=40, font=('Segoe UI', 11))
        self.room_code_entry.pack(side=tk.LEFT, pady=5)
        
        ttk.Button(room_frame, text="Join Meeting", style='Join.TButton',
                  command=self._join_meeting).pack(side=tk.LEFT, padx=20)
        
        create_frame = ttk.LabelFrame(frame, text="Create New Jitsi Meeting", padding=15)
        create_frame.pack(fill=tk.X, pady=20)
        
        new_room_frame = ttk.Frame(create_frame)
        new_room_frame.pack(fill=tk.X)
        
        ttk.Label(new_room_frame, text="Room Name (optional):").pack(anchor=tk.W)
        self.new_room_entry = ttk.Entry(new_room_frame, width=40, font=('Segoe UI', 11))
        self.new_room_entry.pack(side=tk.LEFT, pady=5)
        
        ttk.Button(new_room_frame, text="Create & Join",
                  command=self._create_jitsi_meeting).pack(side=tk.LEFT, padx=20)
        
        self.created_url_var = tk.StringVar()
        ttk.Entry(create_frame, textvariable=self.created_url_var, 
                 state='readonly', width=60).pack(fill=tk.X, pady=10)
        
        ttk.Button(create_frame, text="Copy Link",
                  command=self._copy_meeting_link).pack(anchor=tk.W)
        
        return frame
    
    def _create_schedule_tab(self) -> ttk.Frame:
        frame = ttk.Frame(self.root, padding=20)
        
        add_frame = ttk.LabelFrame(frame, text="Schedule New Meeting", padding=15)
        add_frame.pack(fill=tk.X, pady=10)
        
        row1 = ttk.Frame(add_frame)
        row1.pack(fill=tk.X, pady=5)
        
        ttk.Label(row1, text="Title:").pack(side=tk.LEFT)
        self.sched_title_entry = ttk.Entry(row1, width=40)
        self.sched_title_entry.pack(side=tk.LEFT, padx=10)
        
        ttk.Label(row1, text="Platform:").pack(side=tk.LEFT, padx=(20, 0))
        self.sched_platform_combo = ttk.Combobox(row1, width=15,
                                                  values=[p.name for p in self.service.platforms.values()])
        self.sched_platform_combo.set("Jitsi Meet")
        self.sched_platform_combo.pack(side=tk.LEFT, padx=10)
        
        row2 = ttk.Frame(add_frame)
        row2.pack(fill=tk.X, pady=5)
        
        ttk.Label(row2, text="URL:").pack(side=tk.LEFT)
        self.sched_url_entry = ttk.Entry(row2, width=50)
        self.sched_url_entry.pack(side=tk.LEFT, padx=10)
        
        row3 = ttk.Frame(add_frame)
        row3.pack(fill=tk.X, pady=5)
        
        ttk.Label(row3, text="Date/Time (YYYY-MM-DD HH:MM):").pack(side=tk.LEFT)
        self.sched_time_entry = ttk.Entry(row3, width=20)
        self.sched_time_entry.insert(0, datetime.now().strftime("%Y-%m-%d %H:%M"))
        self.sched_time_entry.pack(side=tk.LEFT, padx=10)
        
        ttk.Label(row3, text="Duration (min):").pack(side=tk.LEFT, padx=(20, 0))
        self.sched_duration_entry = ttk.Entry(row3, width=8)
        self.sched_duration_entry.insert(0, "60")
        self.sched_duration_entry.pack(side=tk.LEFT, padx=10)
        
        ttk.Button(add_frame, text="Schedule Meeting",
                  command=self._schedule_meeting).pack(anchor=tk.W, pady=10)
        
        list_frame = ttk.LabelFrame(frame, text="Upcoming Meetings", padding=15)
        list_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        columns = ('title', 'platform', 'time', 'duration')
        self.meetings_tree = ttk.Treeview(list_frame, columns=columns, show='headings', height=8)
        
        for col, width in [('title', 200), ('platform', 100), ('time', 150), ('duration', 80)]:
            self.meetings_tree.heading(col, text=col.title())
            self.meetings_tree.column(col, width=width)
        
        self.meetings_tree.pack(fill=tk.BOTH, expand=True)
        
        btn_frame = ttk.Frame(list_frame)
        btn_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(btn_frame, text="Join Selected",
                  command=self._join_selected_meeting).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Delete Selected",
                  command=self._delete_selected_meeting).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Export Calendar",
                  command=self._export_calendar).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Refresh",
                  command=self._refresh_meetings).pack(side=tk.LEFT, padx=5)
        
        self._refresh_meetings()
        return frame
    
    def _create_settings_tab(self) -> ttk.Frame:
        frame = ttk.Frame(self.root, padding=20)
        
        canvas = tk.Canvas(frame, bg='#1a1b26', highlightthickness=0)
        scrollbar = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        scroll_frame = ttk.Frame(canvas)
        
        scroll_frame.bind("<Configure>", 
                         lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scroll_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        audio_frame = ttk.LabelFrame(scroll_frame, text="Audio Settings", padding=15)
        audio_frame.pack(fill=tk.X, pady=10, padx=5)
        
        ttk.Label(audio_frame, text="Input Device:").pack(anchor=tk.W)
        input_names = [d.name for d in self.service.audio_devices["input"]] or ["Default"]
        self.audio_input_combo = ttk.Combobox(audio_frame, values=input_names, width=40)
        self.audio_input_combo.set(input_names[0] if input_names else "Default")
        self.audio_input_combo.pack(anchor=tk.W, pady=5)
        
        ttk.Button(audio_frame, text="Test Microphone",
                  command=self._test_microphone).pack(anchor=tk.W, pady=5)
        
        ttk.Label(audio_frame, text="Output Device:").pack(anchor=tk.W, pady=(10, 0))
        output_names = [d.name for d in self.service.audio_devices["output"]] or ["Default"]
        self.audio_output_combo = ttk.Combobox(audio_frame, values=output_names, width=40)
        self.audio_output_combo.set(output_names[0] if output_names else "Default")
        self.audio_output_combo.pack(anchor=tk.W, pady=5)
        
        ttk.Button(audio_frame, text="Test Speakers",
                  command=self._test_speakers).pack(anchor=tk.W, pady=5)
        
        video_frame = ttk.LabelFrame(scroll_frame, text="Video Settings", padding=15)
        video_frame.pack(fill=tk.X, pady=10, padx=5)
        
        ttk.Label(video_frame, text="Camera:").pack(anchor=tk.W)
        camera_names = [d["name"] for d in self.service.video_devices] or ["No camera found"]
        self.camera_combo = ttk.Combobox(video_frame, values=camera_names, width=40)
        self.camera_combo.set(camera_names[0] if camera_names else "No camera")
        self.camera_combo.pack(anchor=tk.W, pady=5)
        
        self.virtual_cam_var = tk.BooleanVar(value=self.service.config.enable_virtual_camera)
        vc_check = ttk.Checkbutton(video_frame, text="Enable Virtual Camera (OBS)",
                                   variable=self.virtual_cam_var)
        vc_check.pack(anchor=tk.W, pady=5)
        
        if not self.service.tier_manager.is_paid():
            ttk.Label(video_frame, text="(Requires paid tier)", 
                     foreground='#f7768e').pack(anchor=tk.W)
        
        bg_frame = ttk.LabelFrame(scroll_frame, text="Background Settings", padding=15)
        bg_frame.pack(fill=tk.X, pady=10, padx=5)
        
        self.bg_mode_var = tk.StringVar(value=self.service.config.background_mode)
        
        ttk.Radiobutton(bg_frame, text="No Effect", variable=self.bg_mode_var,
                       value="none").pack(anchor=tk.W)
        
        blur_frame = ttk.Frame(bg_frame)
        blur_frame.pack(fill=tk.X, anchor=tk.W)
        ttk.Radiobutton(blur_frame, text="Background Blur", variable=self.bg_mode_var,
                       value="blur").pack(side=tk.LEFT)
        
        ttk.Label(blur_frame, text="Intensity:").pack(side=tk.LEFT, padx=(20, 5))
        self.blur_scale = ttk.Scale(blur_frame, from_=1, to=20, orient=tk.HORIZONTAL, length=150)
        self.blur_scale.set(self.service.config.blur_intensity)
        self.blur_scale.pack(side=tk.LEFT)
        
        img_frame = ttk.Frame(bg_frame)
        img_frame.pack(fill=tk.X, anchor=tk.W, pady=5)
        ttk.Radiobutton(img_frame, text="Custom Background", variable=self.bg_mode_var,
                       value="image").pack(side=tk.LEFT)
        ttk.Button(img_frame, text="Browse...",
                  command=self._browse_background).pack(side=tk.LEFT, padx=10)
        
        if not self.service.tier_manager.is_paid():
            ttk.Label(bg_frame, text="(Background effects require paid tier)",
                     foreground='#f7768e').pack(anchor=tk.W, pady=5)
        
        screen_frame = ttk.LabelFrame(scroll_frame, text="Screen Sharing", padding=15)
        screen_frame.pack(fill=tk.X, pady=10, padx=5)
        
        status = self.service.check_screen_sharing_setup()
        status_text = "Ready" if status["screen_capture"] else "Setup Required"
        status_color = '#9ece6a' if status["screen_capture"] else '#f7768e'
        ttk.Label(screen_frame, text=f"Status: {status_text}",
                 foreground=status_color).pack(anchor=tk.W)
        
        ttk.Label(screen_frame, text=f"XDG Portal: {'✓' if status['xdg_portal'] else '✗'}").pack(anchor=tk.W)
        ttk.Label(screen_frame, text=f"PipeWire: {'✓' if status['pipewire'] else '✗'}").pack(anchor=tk.W)
        
        ttk.Button(screen_frame, text="Setup Screen Sharing",
                  command=self._setup_screen_sharing).pack(anchor=tk.W, pady=10)
        
        ttk.Button(scroll_frame, text="Save Settings",
                  command=self._save_settings).pack(pady=20)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        return frame
    
    def _create_recording_tab(self) -> ttk.Frame:
        frame = ttk.Frame(self.root, padding=20)
        
        if not self.service.tier_manager.is_paid():
            ttk.Label(frame, text="Recording requires a paid tier",
                     style='SubHeader.TLabel', foreground='#f7768e').pack(pady=20)
            ttk.Label(frame, text="Upgrade to access meeting recording features",
                     foreground='#565f89').pack()
            return frame
        
        control_frame = ttk.LabelFrame(frame, text="Recording Control", padding=15)
        control_frame.pack(fill=tk.X, pady=10)
        
        self.rec_status_label = ttk.Label(control_frame, text="Status: Not Recording",
                                          foreground='#565f89')
        self.rec_status_label.pack(anchor=tk.W)
        
        btn_frame = ttk.Frame(control_frame)
        btn_frame.pack(fill=tk.X, pady=10)
        
        self.start_rec_btn = ttk.Button(btn_frame, text="Start Recording",
                                        command=self._start_recording)
        self.start_rec_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_rec_btn = ttk.Button(btn_frame, text="Stop Recording",
                                       command=self._stop_recording, state=tk.DISABLED)
        self.stop_rec_btn.pack(side=tk.LEFT, padx=5)
        
        recordings_frame = ttk.LabelFrame(frame, text="Saved Recordings", padding=15)
        recordings_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        columns = ('name', 'size', 'date')
        self.recordings_tree = ttk.Treeview(recordings_frame, columns=columns, 
                                            show='headings', height=10)
        
        for col, width in [('name', 300), ('size', 100), ('date', 150)]:
            self.recordings_tree.heading(col, text=col.title())
            self.recordings_tree.column(col, width=width)
        
        self.recordings_tree.pack(fill=tk.BOTH, expand=True)
        
        rec_btn_frame = ttk.Frame(recordings_frame)
        rec_btn_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(rec_btn_frame, text="Play Selected",
                  command=self._play_recording).pack(side=tk.LEFT, padx=5)
        ttk.Button(rec_btn_frame, text="Open Folder",
                  command=self._open_recordings_folder).pack(side=tk.LEFT, padx=5)
        ttk.Button(rec_btn_frame, text="Refresh",
                  command=self._refresh_recordings).pack(side=tk.LEFT, padx=5)
        
        self._refresh_recordings()
        return frame
    
    def _create_status_tab(self) -> ttk.Frame:
        frame = ttk.Frame(self.root, padding=20)
        
        status = self.service.get_status()
        
        general_frame = ttk.LabelFrame(frame, text="General", padding=15)
        general_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(general_frame, text=f"Version: {status['version']}").pack(anchor=tk.W)
        ttk.Label(general_frame, text=f"Status: {status['status']}").pack(anchor=tk.W)
        ttk.Label(general_frame, text=f"Tier: {status['tier']}").pack(anchor=tk.W)
        
        audio_frame = ttk.LabelFrame(frame, text="Audio Devices", padding=15)
        audio_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(audio_frame, 
                 text=f"Input devices: {status['audio']['input_devices']}").pack(anchor=tk.W)
        ttk.Label(audio_frame,
                 text=f"Output devices: {status['audio']['output_devices']}").pack(anchor=tk.W)
        
        video_frame = ttk.LabelFrame(frame, text="Video", padding=15)
        video_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(video_frame,
                 text=f"Cameras: {status['video']['devices']}").pack(anchor=tk.W)
        ttk.Label(video_frame,
                 text=f"OBS Installed: {'Yes' if status['video']['obs_installed'] else 'No'}").pack(anchor=tk.W)
        ttk.Label(video_frame,
                 text=f"Virtual Camera: {'Ready' if status['video']['virtual_camera_available'] else 'Not Available'}").pack(anchor=tk.W)
        
        screen_frame = ttk.LabelFrame(frame, text="Screen Sharing", padding=15)
        screen_frame.pack(fill=tk.X, pady=10)
        
        ss = status['screen_sharing']
        ttk.Label(screen_frame,
                 text=f"XDG Portal: {'✓' if ss['xdg_portal'] else '✗'}").pack(anchor=tk.W)
        ttk.Label(screen_frame,
                 text=f"PipeWire: {'✓' if ss['pipewire'] else '✗'}").pack(anchor=tk.W)
        ttk.Label(screen_frame,
                 text=f"Screen Capture Ready: {'✓' if ss['screen_capture'] else '✗'}").pack(anchor=tk.W)
        
        features_frame = ttk.LabelFrame(frame, text="Feature Access", padding=15)
        features_frame.pack(fill=tk.X, pady=10)
        
        for feature, available in status['features'].items():
            color = '#9ece6a' if available else '#f7768e'
            ttk.Label(features_frame,
                     text=f"{feature.replace('_', ' ').title()}: {'✓' if available else '✗'}",
                     foreground=color).pack(anchor=tk.W)
        
        return frame
    
    def _join_meeting(self):
        url = self.meeting_url_entry.get().strip()
        room = self.room_code_entry.get().strip()
        platform = self.selected_platform.get()
        
        if url:
            webbrowser.open(url)
        elif room:
            if self.service.join_meeting(platform, room_code=room):
                pass
            else:
                messagebox.showerror("Error", "Failed to join meeting")
        else:
            messagebox.showwarning("Warning", "Please enter a meeting URL or room code")
    
    def _create_jitsi_meeting(self):
        room_name = self.new_room_entry.get().strip()
        url = self.service.create_jitsi_meeting(room_name)
        self.created_url_var.set(url)
        webbrowser.open(url)
    
    def _copy_meeting_link(self):
        url = self.created_url_var.get()
        if url:
            self.root.clipboard_clear()
            self.root.clipboard_append(url)
            messagebox.showinfo("Copied", "Meeting link copied to clipboard")
    
    def _schedule_meeting(self):
        title = self.sched_title_entry.get().strip()
        platform_name = self.sched_platform_combo.get()
        url = self.sched_url_entry.get().strip()
        time_str = self.sched_time_entry.get().strip()
        duration = self.sched_duration_entry.get().strip()
        
        if not title or not url:
            messagebox.showwarning("Warning", "Please fill in title and URL")
            return
        
        try:
            start_time = datetime.strptime(time_str, "%Y-%m-%d %H:%M").isoformat()
            duration_min = int(duration)
        except ValueError:
            messagebox.showerror("Error", "Invalid date/time or duration format")
            return
        
        platform_id = "jitsi"
        for p in self.service.platforms.values():
            if p.name == platform_name:
                platform_id = p.id
                break
        
        self.service.schedule_meeting(title, platform_id, url, start_time, duration_min)
        self._refresh_meetings()
        
        self.sched_title_entry.delete(0, tk.END)
        self.sched_url_entry.delete(0, tk.END)
        messagebox.showinfo("Scheduled", "Meeting has been scheduled")
    
    def _refresh_meetings(self):
        for item in self.meetings_tree.get_children():
            self.meetings_tree.delete(item)
        
        for meeting in self.service.get_upcoming_meetings():
            try:
                time_str = datetime.fromisoformat(meeting.start_time).strftime("%Y-%m-%d %H:%M")
            except Exception:
                time_str = meeting.start_time
            
            platform_name = meeting.platform
            if meeting.platform in self.service.platforms:
                platform_name = self.service.platforms[meeting.platform].name
            
            self.meetings_tree.insert('', tk.END, iid=meeting.id, values=(
                meeting.title, platform_name, time_str, f"{meeting.duration_minutes} min"
            ))
    
    def _join_selected_meeting(self):
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a meeting")
            return
        
        meeting_id = selection[0]
        for meeting in self.service.meetings:
            if meeting.id == meeting_id:
                webbrowser.open(meeting.url)
                return
    
    def _delete_selected_meeting(self):
        selection = self.meetings_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a meeting")
            return
        
        if messagebox.askyesno("Confirm", "Delete this meeting?"):
            self.service.delete_meeting(selection[0])
            self._refresh_meetings()
    
    def _export_calendar(self):
        ical = self.service.export_calendar()
        filepath = filedialog.asksaveasfilename(
            defaultextension=".ics",
            filetypes=[("iCalendar", "*.ics")],
            initialfilename="aegis-meetings.ics"
        )
        if filepath:
            with open(filepath, 'w') as f:
                f.write(ical)
            messagebox.showinfo("Exported", f"Calendar exported to {filepath}")
    
    def _test_microphone(self):
        messagebox.showinfo("Testing", "Recording for 3 seconds...")
        if self.service.test_audio_input():
            messagebox.showinfo("Success", "Microphone test completed")
        else:
            messagebox.showerror("Error", "Microphone test failed")
    
    def _test_speakers(self):
        if self.service.test_audio_output():
            messagebox.showinfo("Success", "Speaker test completed")
        else:
            messagebox.showerror("Error", "Speaker test failed")
    
    def _browse_background(self):
        filepath = filedialog.askopenfilename(
            filetypes=[("Images", "*.jpg *.jpeg *.png *.webp")]
        )
        if filepath:
            self.service.config.custom_background = filepath
            self.bg_mode_var.set("image")
    
    def _setup_screen_sharing(self):
        success, msg = self.service.setup_screen_sharing()
        if success:
            messagebox.showinfo("Success", msg)
        else:
            messagebox.showerror("Error", msg)
    
    def _save_settings(self):
        self.service.config.background_mode = self.bg_mode_var.get()
        self.service.config.blur_intensity = int(self.blur_scale.get())
        self.service.config.enable_virtual_camera = self.virtual_cam_var.get()
        self.service._save_config()
        messagebox.showinfo("Saved", "Settings saved successfully")
    
    def _start_recording(self):
        success, result = self.service.start_recording()
        if success:
            self.rec_status_label.configure(text=f"Recording: {result}", foreground='#f7768e')
            self.start_rec_btn.configure(state=tk.DISABLED)
            self.stop_rec_btn.configure(state=tk.NORMAL)
        else:
            messagebox.showerror("Error", result)
    
    def _stop_recording(self):
        success, result = self.service.stop_recording()
        if success:
            self.rec_status_label.configure(text="Status: Not Recording", foreground='#565f89')
            self.start_rec_btn.configure(state=tk.NORMAL)
            self.stop_rec_btn.configure(state=tk.DISABLED)
            self._refresh_recordings()
        else:
            messagebox.showerror("Error", result)
    
    def _refresh_recordings(self):
        for item in self.recordings_tree.get_children():
            self.recordings_tree.delete(item)
        
        for rec in self.service.get_recordings():
            size_mb = rec["size"] / (1024 * 1024)
            try:
                date = datetime.fromisoformat(rec["created"]).strftime("%Y-%m-%d %H:%M")
            except Exception:
                date = rec["created"]
            
            self.recordings_tree.insert('', tk.END, iid=rec["path"], values=(
                rec["name"], f"{size_mb:.1f} MB", date
            ))
    
    def _play_recording(self):
        selection = self.recordings_tree.selection()
        if not selection:
            messagebox.showwarning("Warning", "Please select a recording")
            return
        
        filepath = selection[0]
        try:
            subprocess.Popen(['xdg-open', filepath],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception:
            messagebox.showerror("Error", "Failed to open recording")
    
    def _open_recordings_folder(self):
        try:
            subprocess.Popen(['xdg-open', self.service.config.recording_path],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception:
            pass


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME} - Video conferencing solution")
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--status', action='store_true', help='Show status as JSON')
    parser.add_argument('--join', metavar='URL', help='Join meeting by URL')
    parser.add_argument('--create', metavar='ROOM', nargs='?', const='', 
                       help='Create Jitsi meeting with optional room name')
    parser.add_argument('--schedule', action='store_true', help='Schedule a meeting (interactive)')
    parser.add_argument('--list-meetings', action='store_true', help='List scheduled meetings')
    parser.add_argument('--list-devices', action='store_true', help='List audio/video devices')
    parser.add_argument('--record', action='store_true', help='Start recording')
    parser.add_argument('--stop-record', action='store_true', help='Stop recording')
    parser.add_argument('--check-screen-share', action='store_true', 
                       help='Check screen sharing setup')
    parser.add_argument('--version', action='version', version=f'{APP_NAME} v{VERSION}')
    
    args = parser.parse_args()
    service = MeetService()
    
    if args.status:
        print(json.dumps(service.get_status(), indent=2))
    elif args.join:
        webbrowser.open(args.join)
        print(f"Opening: {args.join}")
    elif args.create is not None:
        url = service.create_jitsi_meeting(args.create)
        print(f"Meeting created: {url}")
        webbrowser.open(url)
    elif args.list_meetings:
        meetings = service.get_upcoming_meetings()
        if meetings:
            print("Upcoming meetings:")
            for m in meetings:
                print(f"  - {m.title} ({m.platform}) at {m.start_time}")
                print(f"    URL: {m.url}")
        else:
            print("No scheduled meetings")
    elif args.list_devices:
        print("Audio Input Devices:")
        for d in service.audio_devices["input"]:
            print(f"  - {d.name}")
        print("\nAudio Output Devices:")
        for d in service.audio_devices["output"]:
            print(f"  - {d.name}")
        print("\nVideo Devices:")
        for d in service.video_devices:
            print(f"  - {d['name']}")
    elif args.record:
        if not service.tier_manager.is_paid():
            print("Error: Recording requires paid tier", file=sys.stderr)
            sys.exit(1)
        success, result = service.start_recording()
        if success:
            print(f"Recording started: {result}")
        else:
            print(f"Error: {result}", file=sys.stderr)
            sys.exit(1)
    elif args.stop_record:
        success, result = service.stop_recording()
        if success:
            print(result)
        else:
            print(f"Error: {result}", file=sys.stderr)
            sys.exit(1)
    elif args.check_screen_share:
        status = service.check_screen_sharing_setup()
        print("Screen Sharing Status:")
        for key, value in status.items():
            print(f"  {key}: {'✓' if value else '✗'}")
    elif args.gui or not any([args.status, args.join, args.create is not None,
                               args.list_meetings, args.list_devices, args.record,
                               args.stop_record, args.check_screen_share]):
        if TKINTER_AVAILABLE:
            gui = MeetGUI(service)
            gui.run()
        else:
            print("GUI requires tkinter. Use --help for CLI options.")
            sys.exit(1)


if __name__ == "__main__":
    main()
