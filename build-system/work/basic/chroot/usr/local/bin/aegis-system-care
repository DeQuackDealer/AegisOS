#!/usr/bin/env python3
"""
Aegis System Care - Maintenance and optimization tool for Aegis OS Basic
Features: System cleanup, update checker, disk space management, performance tips

Version: 1.0.0
Edition: Basic
"""

import os
import sys
import json
import subprocess
import shutil
import logging
import threading
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any

VERSION = "1.0.0"
APP_NAME = "Aegis System Care"
EDITION = "Basic"

CONFIG_DIR = Path.home() / ".config" / "aegis"
STATE_FILE = CONFIG_DIR / "system-care-state.json"
LOG_FILE = Path("/var/log/aegis/system-care.log")

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, Gdk, GLib, Pango
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False

CLEANUP_TARGETS = {
    "apt_cache": {
        "name": "APT Package Cache",
        "description": "Cached package files from apt",
        "path": "/var/cache/apt/archives",
        "command": ["sudo", "apt-get", "clean"],
        "requires_root": True
    },
    "apt_lists": {
        "name": "APT Package Lists",
        "description": "Package index files (will be re-downloaded)",
        "path": "/var/lib/apt/lists",
        "command": ["sudo", "apt-get", "clean"],
        "requires_root": True
    },
    "thumbnail_cache": {
        "name": "Thumbnail Cache",
        "description": "Cached image thumbnails",
        "path": str(Path.home() / ".cache" / "thumbnails"),
        "command": None,
        "requires_root": False
    },
    "browser_cache": {
        "name": "Browser Caches",
        "description": "Firefox and Chromium cache files",
        "paths": [
            str(Path.home() / ".cache" / "mozilla"),
            str(Path.home() / ".cache" / "chromium"),
            str(Path.home() / ".cache" / "google-chrome")
        ],
        "command": None,
        "requires_root": False
    },
    "trash": {
        "name": "Trash",
        "description": "Deleted files in trash",
        "path": str(Path.home() / ".local" / "share" / "Trash"),
        "command": None,
        "requires_root": False
    },
    "temp_files": {
        "name": "Temporary Files",
        "description": "System temporary files",
        "path": "/tmp",
        "command": None,
        "requires_root": False,
        "pattern": "aegis-*"
    },
    "old_logs": {
        "name": "Old Log Files",
        "description": "Rotated and old log files",
        "path": "/var/log",
        "command": ["sudo", "journalctl", "--vacuum-time=7d"],
        "requires_root": True
    },
    "orphan_packages": {
        "name": "Orphaned Packages",
        "description": "Packages no longer needed",
        "command": ["sudo", "apt-get", "autoremove", "-y"],
        "requires_root": True
    }
}

PERFORMANCE_TIPS = [
    {
        "title": "Reduce Startup Programs",
        "description": "Disable unnecessary startup applications to speed up boot time.",
        "action": "Open Session and Startup settings",
        "command": "xfce4-session-settings"
    },
    {
        "title": "Enable zRAM Swap",
        "description": "Use compressed RAM as swap for better performance on low-memory systems.",
        "action": "Install and configure zram-config",
        "command": "sudo apt install zram-config"
    },
    {
        "title": "Optimize SSD",
        "description": "Enable TRIM for SSDs to maintain performance over time.",
        "action": "Check fstrim timer status",
        "command": "systemctl status fstrim.timer"
    },
    {
        "title": "Review Running Services",
        "description": "Disable unused system services to free resources.",
        "action": "View system services",
        "command": "systemctl list-unit-files --type=service"
    },
    {
        "title": "Clear Browser Data",
        "description": "Clear browsing history, cookies, and cache to free disk space.",
        "action": "Run browser cache cleanup",
        "command": None
    },
    {
        "title": "Check Disk Health",
        "description": "Monitor disk health to prevent data loss.",
        "action": "Run disk utility",
        "command": "gnome-disks"
    }
]


class SystemState:
    def __init__(self):
        self.state = {
            "last_cleanup": None,
            "last_update_check": None,
            "total_cleaned_mb": 0,
            "cleanup_history": []
        }
        self.load()
    
    def load(self):
        try:
            if STATE_FILE.exists():
                with open(STATE_FILE, 'r') as f:
                    self.state.update(json.load(f))
        except Exception:
            pass
    
    def save(self):
        try:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            with open(STATE_FILE, 'w') as f:
                json.dump(self.state, f, indent=2)
        except Exception:
            pass
    
    def record_cleanup(self, cleaned_mb: float, targets: List[str]):
        self.state["last_cleanup"] = datetime.now().isoformat()
        self.state["total_cleaned_mb"] += cleaned_mb
        self.state["cleanup_history"].append({
            "date": datetime.now().isoformat(),
            "cleaned_mb": cleaned_mb,
            "targets": targets
        })
        self.state["cleanup_history"] = self.state["cleanup_history"][-50:]
        self.save()
    
    def record_update_check(self):
        self.state["last_update_check"] = datetime.now().isoformat()
        self.save()


class SystemCare:
    def __init__(self):
        self.state = SystemState()
        self.setup_logging()
    
    def setup_logging(self):
        try:
            LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[
                    logging.FileHandler(LOG_FILE) if os.access(str(LOG_FILE.parent), os.W_OK) else logging.NullHandler()
                ]
            )
        except Exception:
            logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger("AegisSystemCare")
    
    def get_directory_size(self, path: str) -> int:
        total = 0
        try:
            path_obj = Path(path)
            if path_obj.exists():
                if path_obj.is_file():
                    return path_obj.stat().st_size
                for entry in path_obj.rglob('*'):
                    try:
                        if entry.is_file():
                            total += entry.stat().st_size
                    except (PermissionError, OSError):
                        pass
        except (PermissionError, OSError):
            pass
        return total
    
    def format_size(self, size_bytes: int) -> str:
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024
        return f"{size_bytes:.1f} PB"
    
    def analyze_cleanup_targets(self) -> List[Dict[str, Any]]:
        results = []
        for target_id, target in CLEANUP_TARGETS.items():
            size = 0
            if 'path' in target:
                size = self.get_directory_size(target['path'])
            elif 'paths' in target:
                for path in target['paths']:
                    size += self.get_directory_size(path)
            
            results.append({
                "id": target_id,
                "name": target["name"],
                "description": target["description"],
                "size": size,
                "size_formatted": self.format_size(size),
                "requires_root": target.get("requires_root", False)
            })
        
        return sorted(results, key=lambda x: x["size"], reverse=True)
    
    def clean_target(self, target_id: str) -> Tuple[bool, str, int]:
        if target_id not in CLEANUP_TARGETS:
            return False, f"Unknown target: {target_id}", 0
        
        target = CLEANUP_TARGETS[target_id]
        cleaned_size = 0
        
        try:
            if 'path' in target:
                cleaned_size = self.get_directory_size(target['path'])
            elif 'paths' in target:
                for path in target['paths']:
                    cleaned_size += self.get_directory_size(path)
            
            if target.get("command"):
                if target.get("requires_root") and os.geteuid() != 0:
                    result = subprocess.run(
                        target["command"],
                        capture_output=True,
                        text=True,
                        timeout=120
                    )
                else:
                    cmd = target["command"]
                    if cmd[0] == "sudo":
                        cmd = cmd[1:]
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
                
                if result.returncode != 0:
                    return False, result.stderr, 0
            else:
                if 'path' in target:
                    path = Path(target['path'])
                    if path.exists():
                        if target.get("pattern"):
                            for item in path.glob(target["pattern"]):
                                if item.is_file():
                                    item.unlink()
                                elif item.is_dir():
                                    shutil.rmtree(item, ignore_errors=True)
                        else:
                            for item in path.iterdir():
                                try:
                                    if item.is_file():
                                        item.unlink()
                                    elif item.is_dir():
                                        shutil.rmtree(item, ignore_errors=True)
                                except (PermissionError, OSError):
                                    pass
                elif 'paths' in target:
                    for path_str in target['paths']:
                        path = Path(path_str)
                        if path.exists():
                            shutil.rmtree(path, ignore_errors=True)
            
            self.logger.info(f"Cleaned {target_id}: {self.format_size(cleaned_size)}")
            return True, f"Cleaned {self.format_size(cleaned_size)}", cleaned_size
            
        except subprocess.TimeoutExpired:
            return False, "Operation timed out", 0
        except Exception as e:
            return False, str(e), 0
    
    def check_updates(self) -> Dict[str, Any]:
        result = {
            "available": 0,
            "security": 0,
            "packages": [],
            "error": None
        }
        
        try:
            subprocess.run(["sudo", "apt-get", "update", "-qq"], 
                         capture_output=True, timeout=300)
            
            check = subprocess.run(
                ["apt", "list", "--upgradable"],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            lines = check.stdout.strip().split('\n')[1:]
            for line in lines:
                if line:
                    result["packages"].append(line.split('/')[0])
                    result["available"] += 1
                    if "security" in line.lower():
                        result["security"] += 1
            
            self.state.record_update_check()
            
        except subprocess.TimeoutExpired:
            result["error"] = "Update check timed out"
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def get_disk_usage(self) -> List[Dict[str, Any]]:
        disks = []
        try:
            result = subprocess.run(["df", "-h", "--output=source,size,used,avail,pcent,target"],
                                   capture_output=True, text=True)
            lines = result.stdout.strip().split('\n')[1:]
            
            for line in lines:
                parts = line.split()
                if len(parts) >= 6 and not parts[0].startswith('tmpfs'):
                    disks.append({
                        "device": parts[0],
                        "size": parts[1],
                        "used": parts[2],
                        "available": parts[3],
                        "percent": int(parts[4].rstrip('%')),
                        "mount": parts[5]
                    })
        except Exception:
            pass
        
        return disks
    
    def get_system_info(self) -> Dict[str, Any]:
        info = {
            "hostname": "",
            "os": "",
            "kernel": "",
            "uptime": "",
            "memory_total": "",
            "memory_used": "",
            "cpu": ""
        }
        
        try:
            info["hostname"] = subprocess.run(["hostname"], capture_output=True, 
                                             text=True).stdout.strip()
            
            if Path("/etc/os-release").exists():
                with open("/etc/os-release") as f:
                    for line in f:
                        if line.startswith("PRETTY_NAME="):
                            info["os"] = line.split("=")[1].strip().strip('"')
                            break
            
            info["kernel"] = subprocess.run(["uname", "-r"], capture_output=True,
                                           text=True).stdout.strip()
            
            uptime_output = subprocess.run(["uptime", "-p"], capture_output=True,
                                          text=True).stdout.strip()
            info["uptime"] = uptime_output.replace("up ", "")
            
            mem = subprocess.run(["free", "-h"], capture_output=True, text=True)
            mem_lines = mem.stdout.strip().split('\n')
            if len(mem_lines) >= 2:
                parts = mem_lines[1].split()
                info["memory_total"] = parts[1]
                info["memory_used"] = parts[2]
            
            cpu = subprocess.run(["lscpu"], capture_output=True, text=True)
            for line in cpu.stdout.split('\n'):
                if "Model name:" in line:
                    info["cpu"] = line.split(":")[1].strip()
                    break
                    
        except Exception:
            pass
        
        return info
    
    def run_cli(self):
        print("\n" + "=" * 60)
        print(f"  {APP_NAME} v{VERSION}")
        print(f"  Aegis OS {EDITION} Edition")
        print("=" * 60)
        
        print("\n[1] System Information")
        print("-" * 40)
        info = self.get_system_info()
        print(f"  Hostname: {info['hostname']}")
        print(f"  OS: {info['os']}")
        print(f"  Kernel: {info['kernel']}")
        print(f"  Uptime: {info['uptime']}")
        print(f"  Memory: {info['memory_used']} / {info['memory_total']}")
        print(f"  CPU: {info['cpu']}")
        
        print("\n[2] Disk Usage")
        print("-" * 40)
        disks = self.get_disk_usage()
        for disk in disks:
            bar_len = 20
            filled = int(bar_len * disk['percent'] / 100)
            bar = '‚ñà' * filled + '‚ñë' * (bar_len - filled)
            status = "‚ö†Ô∏è" if disk['percent'] > 90 else "‚úì" if disk['percent'] < 70 else "‚óã"
            print(f"  {status} {disk['mount']}: [{bar}] {disk['percent']}%")
            print(f"     {disk['used']} used of {disk['size']} ({disk['available']} free)")
        
        print("\n[3] Cleanup Analysis")
        print("-" * 40)
        targets = self.analyze_cleanup_targets()
        total_size = sum(t['size'] for t in targets)
        print(f"  Total cleanable space: {self.format_size(total_size)}")
        for target in targets[:5]:
            if target['size'] > 0:
                print(f"  ‚Ä¢ {target['name']}: {target['size_formatted']}")
        
        print("\n[4] Update Status")
        print("-" * 40)
        updates = self.check_updates()
        if updates['error']:
            print(f"  Error checking updates: {updates['error']}")
        else:
            print(f"  Available updates: {updates['available']}")
            if updates['security'] > 0:
                print(f"  ‚ö†Ô∏è Security updates: {updates['security']}")
        
        print("\n[5] Performance Tips")
        print("-" * 40)
        for i, tip in enumerate(PERFORMANCE_TIPS[:3], 1):
            print(f"  {i}. {tip['title']}")
            print(f"     {tip['description']}")
        
        if self.state.state['last_cleanup']:
            print(f"\nLast cleanup: {self.state.state['last_cleanup'][:10]}")
            print(f"Total cleaned: {self.format_size(int(self.state.state['total_cleaned_mb'] * 1024 * 1024))}")


if GTK_AVAILABLE:
    class SystemCareWindow(Gtk.Window):
        def __init__(self, care: SystemCare):
            super().__init__(title=f"{APP_NAME}")
            self.care = care
            
            self.set_default_size(800, 600)
            self.set_position(Gtk.WindowPosition.CENTER)
            self.set_border_width(10)
            
            main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            self.add(main_box)
            
            header = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            title = Gtk.Label()
            title.set_markup(f"<big><b>{APP_NAME}</b></big>")
            header.pack_start(title, False, False, 0)
            
            refresh_btn = Gtk.Button(label="Refresh")
            refresh_btn.connect("clicked", self.on_refresh)
            header.pack_end(refresh_btn, False, False, 0)
            
            main_box.pack_start(header, False, False, 0)
            
            notebook = Gtk.Notebook()
            main_box.pack_start(notebook, True, True, 0)
            
            notebook.append_page(self.create_overview_tab(), Gtk.Label(label="Overview"))
            notebook.append_page(self.create_cleanup_tab(), Gtk.Label(label="Cleanup"))
            notebook.append_page(self.create_updates_tab(), Gtk.Label(label="Updates"))
            notebook.append_page(self.create_disk_tab(), Gtk.Label(label="Disk Space"))
            notebook.append_page(self.create_tips_tab(), Gtk.Label(label="Performance Tips"))
            
            statusbar = Gtk.Statusbar()
            self.status_context = statusbar.get_context_id("main")
            if self.care.state.state['last_cleanup']:
                statusbar.push(self.status_context, 
                             f"Last cleanup: {self.care.state.state['last_cleanup'][:10]} | "
                             f"Total cleaned: {self.care.format_size(int(self.care.state.state['total_cleaned_mb'] * 1024 * 1024))}")
            main_box.pack_end(statusbar, False, False, 0)
        
        def create_overview_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
            box.set_margin_top(20)
            box.set_margin_start(20)
            box.set_margin_end(20)
            
            info = self.care.get_system_info()
            
            info_grid = Gtk.Grid()
            info_grid.set_column_spacing(20)
            info_grid.set_row_spacing(10)
            
            labels = [
                ("Hostname:", info['hostname']),
                ("Operating System:", info['os']),
                ("Kernel:", info['kernel']),
                ("Uptime:", info['uptime']),
                ("Memory:", f"{info['memory_used']} / {info['memory_total']}"),
                ("CPU:", info['cpu'])
            ]
            
            for i, (label, value) in enumerate(labels):
                lbl = Gtk.Label()
                lbl.set_markup(f"<b>{label}</b>")
                lbl.set_xalign(0)
                info_grid.attach(lbl, 0, i, 1, 1)
                
                val = Gtk.Label(label=value)
                val.set_xalign(0)
                val.set_selectable(True)
                info_grid.attach(val, 1, i, 1, 1)
            
            box.pack_start(info_grid, False, False, 0)
            
            quick_actions = Gtk.Frame(label="Quick Actions")
            actions_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            actions_box.set_margin_top(10)
            actions_box.set_margin_bottom(10)
            actions_box.set_margin_start(10)
            actions_box.set_margin_end(10)
            
            cleanup_btn = Gtk.Button(label="Quick Cleanup")
            cleanup_btn.connect("clicked", self.on_quick_cleanup)
            actions_box.pack_start(cleanup_btn, True, True, 0)
            
            update_btn = Gtk.Button(label="Check Updates")
            update_btn.connect("clicked", self.on_check_updates)
            actions_box.pack_start(update_btn, True, True, 0)
            
            disk_btn = Gtk.Button(label="Disk Utility")
            disk_btn.connect("clicked", lambda b: subprocess.Popen(["gnome-disks"]))
            actions_box.pack_start(disk_btn, True, True, 0)
            
            quick_actions.add(actions_box)
            box.pack_start(quick_actions, False, False, 20)
            
            return box
        
        def create_cleanup_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(15)
            box.set_margin_start(15)
            box.set_margin_end(15)
            
            scrolled = Gtk.ScrolledWindow()
            scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
            
            self.cleanup_listbox = Gtk.ListBox()
            self.cleanup_listbox.set_selection_mode(Gtk.SelectionMode.NONE)
            
            self.cleanup_checks = {}
            targets = self.care.analyze_cleanup_targets()
            
            for target in targets:
                row = Gtk.ListBoxRow()
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
                hbox.set_margin_top(5)
                hbox.set_margin_bottom(5)
                hbox.set_margin_start(10)
                hbox.set_margin_end(10)
                
                check = Gtk.CheckButton()
                check.set_active(target['size'] > 1024 * 1024)
                self.cleanup_checks[target['id']] = check
                hbox.pack_start(check, False, False, 0)
                
                info_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
                name_label = Gtk.Label()
                name_label.set_markup(f"<b>{target['name']}</b>")
                name_label.set_xalign(0)
                info_box.pack_start(name_label, False, False, 0)
                
                desc_label = Gtk.Label(label=target['description'])
                desc_label.set_xalign(0)
                info_box.pack_start(desc_label, False, False, 0)
                hbox.pack_start(info_box, True, True, 0)
                
                size_label = Gtk.Label()
                if target['requires_root']:
                    size_label.set_markup(f"<b>{target['size_formatted']}</b> üîí")
                else:
                    size_label.set_markup(f"<b>{target['size_formatted']}</b>")
                hbox.pack_end(size_label, False, False, 0)
                
                row.add(hbox)
                self.cleanup_listbox.add(row)
            
            scrolled.add(self.cleanup_listbox)
            box.pack_start(scrolled, True, True, 0)
            
            action_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            
            select_all_btn = Gtk.Button(label="Select All")
            select_all_btn.connect("clicked", self.on_select_all_cleanup)
            action_box.pack_start(select_all_btn, False, False, 0)
            
            clear_btn = Gtk.Button(label="Clear Selection")
            clear_btn.connect("clicked", self.on_clear_cleanup_selection)
            action_box.pack_start(clear_btn, False, False, 0)
            
            clean_btn = Gtk.Button(label="Clean Selected")
            clean_btn.get_style_context().add_class("destructive-action")
            clean_btn.connect("clicked", self.on_clean_selected)
            action_box.pack_end(clean_btn, False, False, 0)
            
            box.pack_end(action_box, False, False, 10)
            
            return box
        
        def create_updates_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=15)
            box.set_margin_top(20)
            box.set_margin_start(20)
            box.set_margin_end(20)
            
            self.updates_status = Gtk.Label()
            self.updates_status.set_markup("<b>Click 'Check for Updates' to scan for available updates</b>")
            box.pack_start(self.updates_status, False, False, 0)
            
            self.updates_spinner = Gtk.Spinner()
            box.pack_start(self.updates_spinner, False, False, 0)
            
            scrolled = Gtk.ScrolledWindow()
            scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
            
            self.updates_list = Gtk.ListBox()
            scrolled.add(self.updates_list)
            box.pack_start(scrolled, True, True, 0)
            
            action_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            
            check_btn = Gtk.Button(label="Check for Updates")
            check_btn.connect("clicked", self.on_check_updates)
            action_box.pack_start(check_btn, False, False, 0)
            
            install_btn = Gtk.Button(label="Install Updates")
            install_btn.connect("clicked", self.on_install_updates)
            action_box.pack_end(install_btn, False, False, 0)
            
            box.pack_end(action_box, False, False, 0)
            
            return box
        
        def create_disk_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(15)
            box.set_margin_start(15)
            box.set_margin_end(15)
            
            disks = self.care.get_disk_usage()
            
            for disk in disks:
                frame = Gtk.Frame(label=f"{disk['mount']} ({disk['device']})")
                frame_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
                frame_box.set_margin_top(10)
                frame_box.set_margin_bottom(10)
                frame_box.set_margin_start(10)
                frame_box.set_margin_end(10)
                
                progress = Gtk.ProgressBar()
                progress.set_fraction(disk['percent'] / 100)
                progress.set_text(f"{disk['percent']}% used")
                progress.set_show_text(True)
                
                if disk['percent'] > 90:
                    progress.get_style_context().add_class("error")
                elif disk['percent'] > 70:
                    progress.get_style_context().add_class("warning")
                
                frame_box.pack_start(progress, False, False, 0)
                
                info_label = Gtk.Label()
                info_label.set_markup(f"<small>Used: {disk['used']} | Available: {disk['available']} | Total: {disk['size']}</small>")
                frame_box.pack_start(info_label, False, False, 0)
                
                frame.add(frame_box)
                box.pack_start(frame, False, False, 5)
            
            action_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            
            analyzer_btn = Gtk.Button(label="Disk Analyzer")
            analyzer_btn.connect("clicked", lambda b: subprocess.Popen(["baobab"]))
            action_box.pack_start(analyzer_btn, False, False, 0)
            
            disks_btn = Gtk.Button(label="Disk Utility")
            disks_btn.connect("clicked", lambda b: subprocess.Popen(["gnome-disks"]))
            action_box.pack_start(disks_btn, False, False, 0)
            
            box.pack_end(action_box, False, False, 10)
            
            return box
        
        def create_tips_tab(self):
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            box.set_margin_top(15)
            box.set_margin_start(15)
            box.set_margin_end(15)
            
            scrolled = Gtk.ScrolledWindow()
            scrolled.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
            
            tips_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
            
            for tip in PERFORMANCE_TIPS:
                frame = Gtk.Frame()
                tip_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
                tip_box.set_margin_top(10)
                tip_box.set_margin_bottom(10)
                tip_box.set_margin_start(10)
                tip_box.set_margin_end(10)
                
                title = Gtk.Label()
                title.set_markup(f"<b>{tip['title']}</b>")
                title.set_xalign(0)
                tip_box.pack_start(title, False, False, 0)
                
                desc = Gtk.Label(label=tip['description'])
                desc.set_xalign(0)
                desc.set_line_wrap(True)
                tip_box.pack_start(desc, False, False, 0)
                
                if tip.get('command'):
                    btn = Gtk.Button(label=tip['action'])
                    btn.connect("clicked", self.on_run_tip_action, tip['command'])
                    tip_box.pack_start(btn, False, False, 5)
                
                frame.add(tip_box)
                tips_box.pack_start(frame, False, False, 0)
            
            scrolled.add(tips_box)
            box.pack_start(scrolled, True, True, 0)
            
            return box
        
        def on_refresh(self, button):
            pass
        
        def on_quick_cleanup(self, button):
            targets = ["thumbnail_cache", "browser_cache", "trash"]
            total_cleaned = 0
            
            for target_id in targets:
                success, msg, size = self.care.clean_target(target_id)
                if success:
                    total_cleaned += size
            
            self.care.state.record_cleanup(total_cleaned / (1024 * 1024), targets)
            
            dialog = Gtk.MessageDialog(
                transient_for=self,
                flags=0,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.OK,
                text="Quick Cleanup Complete"
            )
            dialog.format_secondary_text(f"Cleaned {self.care.format_size(total_cleaned)}")
            dialog.run()
            dialog.destroy()
        
        def on_select_all_cleanup(self, button):
            for check in self.cleanup_checks.values():
                check.set_active(True)
        
        def on_clear_cleanup_selection(self, button):
            for check in self.cleanup_checks.values():
                check.set_active(False)
        
        def on_clean_selected(self, button):
            selected = [tid for tid, check in self.cleanup_checks.items() if check.get_active()]
            
            if not selected:
                return
            
            dialog = Gtk.MessageDialog(
                transient_for=self,
                flags=0,
                message_type=Gtk.MessageType.WARNING,
                buttons=Gtk.ButtonsType.OK_CANCEL,
                text="Confirm Cleanup"
            )
            dialog.format_secondary_text(f"This will clean {len(selected)} selected items. Continue?")
            response = dialog.run()
            dialog.destroy()
            
            if response != Gtk.ResponseType.OK:
                return
            
            total_cleaned = 0
            for target_id in selected:
                success, msg, size = self.care.clean_target(target_id)
                if success:
                    total_cleaned += size
            
            self.care.state.record_cleanup(total_cleaned / (1024 * 1024), selected)
            
            result_dialog = Gtk.MessageDialog(
                transient_for=self,
                flags=0,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.OK,
                text="Cleanup Complete"
            )
            result_dialog.format_secondary_text(f"Cleaned {self.care.format_size(total_cleaned)}")
            result_dialog.run()
            result_dialog.destroy()
        
        def on_check_updates(self, button):
            self.updates_spinner.start()
            self.updates_status.set_markup("<b>Checking for updates...</b>")
            
            def check_thread():
                result = self.care.check_updates()
                GLib.idle_add(self.update_updates_display, result)
            
            thread = threading.Thread(target=check_thread)
            thread.daemon = True
            thread.start()
        
        def update_updates_display(self, result):
            self.updates_spinner.stop()
            
            for child in self.updates_list.get_children():
                self.updates_list.remove(child)
            
            if result['error']:
                self.updates_status.set_markup(f"<b>Error:</b> {result['error']}")
            else:
                status = f"<b>{result['available']} updates available</b>"
                if result['security'] > 0:
                    status += f" ({result['security']} security updates)"
                self.updates_status.set_markup(status)
                
                for pkg in result['packages'][:50]:
                    row = Gtk.ListBoxRow()
                    label = Gtk.Label(label=pkg)
                    label.set_xalign(0)
                    label.set_margin_top(5)
                    label.set_margin_bottom(5)
                    label.set_margin_start(10)
                    row.add(label)
                    self.updates_list.add(row)
                
                self.updates_list.show_all()
        
        def on_install_updates(self, button):
            try:
                subprocess.Popen(["x-terminal-emulator", "-e", 
                                "sudo apt upgrade -y; read -p 'Press Enter to close...'"])
            except Exception:
                subprocess.Popen(["xfce4-terminal", "-e", 
                                "sudo apt upgrade -y; read -p 'Press Enter to close...'"])
        
        def on_run_tip_action(self, button, command):
            try:
                if command.startswith("sudo"):
                    subprocess.Popen(["x-terminal-emulator", "-e", command])
                else:
                    subprocess.Popen(command.split())
            except Exception:
                pass


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description=f"{APP_NAME}")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode")
    parser.add_argument("--cleanup", action="store_true", help="Run quick cleanup")
    parser.add_argument("--updates", action="store_true", help="Check for updates")
    parser.add_argument("--disk", action="store_true", help="Show disk usage")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    care = SystemCare()
    
    if args.cleanup:
        targets = ["thumbnail_cache", "browser_cache", "trash"]
        print("Running quick cleanup...")
        total = 0
        for t in targets:
            success, msg, size = care.clean_target(t)
            if success:
                total += size
                print(f"  ‚úì {t}: {care.format_size(size)}")
        print(f"Total cleaned: {care.format_size(total)}")
        return
    
    if args.updates:
        print("Checking for updates...")
        result = care.check_updates()
        if result['error']:
            print(f"Error: {result['error']}")
        else:
            print(f"Available: {result['available']}")
            print(f"Security: {result['security']}")
        return
    
    if args.disk:
        disks = care.get_disk_usage()
        for d in disks:
            print(f"{d['mount']}: {d['percent']}% ({d['used']}/{d['size']})")
        return
    
    if args.cli or not GTK_AVAILABLE:
        care.run_cli()
    else:
        win = SystemCareWindow(care)
        win.connect("destroy", Gtk.main_quit)
        win.show_all()
        Gtk.main()


if __name__ == "__main__":
    main()
