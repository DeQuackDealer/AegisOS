#!/usr/bin/env python3
"""
Aegis OS Game Library - Unified Game Launcher
Detects and manages games from Steam, Lutris, Heroic, and native sources
Provides playtime tracking and game metadata management
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import threading
import time
import re
import glob as glob_module
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, scrolledtext
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

try:
    import yaml
    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False


class AegisGameLibrary:
    def __init__(self):
        self.version = "1.0.0"
        self.config_dir = Path("/etc/aegis")
        self.data_dir = Path("/var/lib/aegis/games")
        self.log_dir = Path("/var/log/aegis")
        self.config_file = self.config_dir / "games-config.json"
        self.library_file = self.data_dir / "library.json"
        self.playtime_file = self.data_dir / "playtime.json"
        
        self.home_dir = Path.home()
        
        self.ensure_directories()
        self.setup_logging()
        self.load_config()
        self.load_library()
        self.load_playtime()
        
    def ensure_directories(self):
        """Create required directories"""
        for directory in [self.config_dir, self.data_dir, self.log_dir]:
            directory.mkdir(parents=True, exist_ok=True)
    
    def setup_logging(self):
        """Configure logging"""
        log_file = self.log_dir / "aegis-games.log"
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger("AegisGameLibrary")
    
    def load_config(self):
        """Load game library configuration"""
        default_config = {
            "auto_scan_on_start": True,
            "scan_steam": True,
            "scan_lutris": True,
            "scan_heroic": True,
            "scan_native": True,
            "steam_paths": [
                str(self.home_dir / ".steam/steam"),
                str(self.home_dir / ".local/share/Steam")
            ],
            "lutris_path": str(self.home_dir / ".config/lutris"),
            "heroic_path": str(self.home_dir / ".config/heroic"),
            "native_paths": [
                "/usr/share/applications",
                str(self.home_dir / ".local/share/applications")
            ],
            "show_hidden_games": False,
            "sort_by": "name",
            "view_mode": "grid",
            "track_playtime": True,
            "last_scan": None
        }
        
        try:
            with open(self.config_file, 'r') as f:
                self.config = {**default_config, **json.load(f)}
        except (FileNotFoundError, json.JSONDecodeError):
            self.config = default_config
            self.save_config()
    
    def save_config(self):
        """Save configuration"""
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def load_library(self):
        """Load game library from file"""
        try:
            with open(self.library_file, 'r') as f:
                self.library = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.library = {
                "version": self.version,
                "last_updated": None,
                "games": {}
            }
            self.save_library()
    
    def save_library(self):
        """Save game library to file"""
        self.library["last_updated"] = datetime.now().isoformat()
        with open(self.library_file, 'w') as f:
            json.dump(self.library, f, indent=2)
    
    def load_playtime(self):
        """Load playtime tracking data"""
        try:
            with open(self.playtime_file, 'r') as f:
                self.playtime = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.playtime = {
                "sessions": [],
                "totals": {}
            }
            self.save_playtime()
    
    def save_playtime(self):
        """Save playtime tracking data"""
        with open(self.playtime_file, 'w') as f:
            json.dump(self.playtime, f, indent=2)

    def scan_steam_games(self) -> List[Dict]:
        """Scan for Steam games from manifest files"""
        games = []
        
        for steam_path in self.config["steam_paths"]:
            steamapps_path = Path(steam_path) / "steamapps"
            
            if not steamapps_path.exists():
                continue
            
            acf_files = list(steamapps_path.glob("appmanifest_*.acf"))
            
            for acf_file in acf_files:
                try:
                    game_data = self.parse_acf_file(acf_file)
                    if game_data:
                        game_id = f"steam_{game_data['appid']}"
                        
                        install_dir = steamapps_path / "common" / game_data.get("installdir", "")
                        install_size = self.get_directory_size(install_dir) if install_dir.exists() else 0
                        
                        games.append({
                            "id": game_id,
                            "name": game_data.get("name", "Unknown Game"),
                            "platform": "steam",
                            "appid": game_data.get("appid"),
                            "install_path": str(install_dir),
                            "install_size": install_size,
                            "state": game_data.get("StateFlags", "4"),
                            "last_updated": game_data.get("LastUpdated"),
                            "launch_command": f"steam://rungameid/{game_data['appid']}",
                            "icon": None,
                            "hidden": False
                        })
                        
                except Exception as e:
                    self.logger.warning(f"Failed to parse {acf_file}: {e}")
        
        return games
    
    def parse_acf_file(self, filepath: Path) -> Optional[Dict]:
        """Parse Steam ACF manifest file (Valve KeyValues format)"""
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            data = {}
            key_pattern = re.compile(r'"(\w+)"\s+"([^"]*)"')
            
            for match in key_pattern.finditer(content):
                key, value = match.groups()
                data[key.lower()] = value
            
            if 'appid' not in data:
                return None
            
            return {
                "appid": data.get("appid"),
                "name": data.get("name", "Unknown"),
                "installdir": data.get("installdir", ""),
                "StateFlags": data.get("stateflags", "4"),
                "LastUpdated": data.get("lastupdated")
            }
            
        except Exception as e:
            self.logger.error(f"Error parsing ACF file {filepath}: {e}")
            return None
    
    def scan_lutris_games(self) -> List[Dict]:
        """Scan for Lutris games from YAML config files"""
        games = []
        
        if not YAML_AVAILABLE:
            self.logger.warning("PyYAML not available, skipping Lutris scan")
            return games
        
        lutris_games_path = Path(self.config["lutris_path"]) / "games"
        
        if not lutris_games_path.exists():
            return games
        
        yml_files = list(lutris_games_path.glob("*.yml"))
        
        for yml_file in yml_files:
            try:
                with open(yml_file, 'r') as f:
                    game_data = yaml.safe_load(f)
                
                if not game_data:
                    continue
                
                game_slug = yml_file.stem
                game_id = f"lutris_{game_slug}"
                
                install_path = game_data.get("game", {}).get("exe", "")
                if install_path:
                    install_path = str(Path(install_path).parent)
                
                games.append({
                    "id": game_id,
                    "name": game_data.get("name", game_slug),
                    "platform": "lutris",
                    "slug": game_slug,
                    "runner": game_data.get("runner", "unknown"),
                    "install_path": install_path,
                    "install_size": self.get_directory_size(Path(install_path)) if install_path and Path(install_path).exists() else 0,
                    "year": game_data.get("year"),
                    "launch_command": f"lutris:rungame/{game_slug}",
                    "icon": None,
                    "hidden": False
                })
                
            except Exception as e:
                self.logger.warning(f"Failed to parse Lutris game {yml_file}: {e}")
        
        return games
    
    def scan_heroic_games(self) -> List[Dict]:
        """Scan for Heroic Games Launcher games"""
        games = []
        heroic_path = Path(self.config["heroic_path"])
        
        library_paths = [
            heroic_path / "gog_store" / "installed.json",
            heroic_path / "store" / "installed.json",
            heroic_path / "legendaryConfig" / "legendary" / "installed.json"
        ]
        
        gog_library = heroic_path / "gog_store" / "library.json"
        epic_library = heroic_path / "store_cache" / "legendary_library.json"
        
        for lib_file in [gog_library, epic_library]:
            if lib_file.exists():
                try:
                    with open(lib_file, 'r') as f:
                        data = json.load(f)
                    
                    game_list = data.get("library", data) if isinstance(data, dict) else data
                    
                    if isinstance(game_list, list):
                        for game in game_list:
                            if isinstance(game, dict):
                                game_id = game.get("app_name", game.get("appName", ""))
                                if not game_id:
                                    continue
                                
                                platform_type = "heroic_gog" if "gog" in str(lib_file) else "heroic_epic"
                                full_game_id = f"{platform_type}_{game_id}"
                                
                                install_path = game.get("install_path", game.get("install", {}).get("install_path", ""))
                                
                                games.append({
                                    "id": full_game_id,
                                    "name": game.get("title", game.get("app_name", "Unknown")),
                                    "platform": platform_type,
                                    "app_name": game_id,
                                    "install_path": install_path,
                                    "install_size": game.get("install_size", 0),
                                    "is_installed": game.get("is_installed", False),
                                    "launch_command": f"heroic://launch/{game_id}",
                                    "icon": game.get("art_square", game.get("art_cover")),
                                    "hidden": False
                                })
                                
                except Exception as e:
                    self.logger.warning(f"Failed to parse Heroic library {lib_file}: {e}")
        
        for installed_file in library_paths:
            if installed_file.exists():
                try:
                    with open(installed_file, 'r') as f:
                        installed_data = json.load(f)
                    
                    if isinstance(installed_data, dict):
                        for app_name, game_info in installed_data.items():
                            existing = next((g for g in games if game_info.get("appName", app_name) in g["id"]), None)
                            if existing:
                                existing["is_installed"] = True
                                existing["install_path"] = game_info.get("install_path", existing.get("install_path", ""))
                                
                except Exception as e:
                    self.logger.warning(f"Failed to parse Heroic installed games {installed_file}: {e}")
        
        return games
    
    def scan_native_games(self) -> List[Dict]:
        """Scan for native Linux games from .desktop files"""
        games = []
        
        for apps_path in self.config["native_paths"]:
            apps_dir = Path(apps_path)
            
            if not apps_dir.exists():
                continue
            
            desktop_files = list(apps_dir.glob("*.desktop"))
            
            for desktop_file in desktop_files:
                try:
                    game_data = self.parse_desktop_file(desktop_file)
                    
                    if not game_data:
                        continue
                    
                    categories = game_data.get("categories", "").lower()
                    if "game" not in categories:
                        continue
                    
                    game_id = f"native_{desktop_file.stem}"
                    
                    games.append({
                        "id": game_id,
                        "name": game_data.get("name", desktop_file.stem),
                        "platform": "native",
                        "desktop_file": str(desktop_file),
                        "exec": game_data.get("exec", ""),
                        "icon": game_data.get("icon"),
                        "categories": game_data.get("categories", ""),
                        "install_path": game_data.get("path", ""),
                        "install_size": 0,
                        "launch_command": game_data.get("exec", ""),
                        "hidden": game_data.get("hidden", False)
                    })
                    
                except Exception as e:
                    self.logger.warning(f"Failed to parse desktop file {desktop_file}: {e}")
        
        return games
    
    def parse_desktop_file(self, filepath: Path) -> Optional[Dict]:
        """Parse a .desktop file"""
        try:
            data = {}
            current_section = None
            
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                for line in f:
                    line = line.strip()
                    
                    if line.startswith('['):
                        current_section = line[1:-1]
                        continue
                    
                    if current_section != "Desktop Entry":
                        continue
                    
                    if '=' in line:
                        key, value = line.split('=', 1)
                        data[key.lower()] = value
            
            return {
                "name": data.get("name", ""),
                "exec": data.get("exec", ""),
                "icon": data.get("icon", ""),
                "categories": data.get("categories", ""),
                "path": data.get("path", ""),
                "hidden": data.get("nodisplay", "false").lower() == "true" or data.get("hidden", "false").lower() == "true"
            }
            
        except Exception as e:
            self.logger.error(f"Error parsing desktop file {filepath}: {e}")
            return None
    
    def get_directory_size(self, path: Path) -> int:
        """Get total size of a directory in bytes"""
        total_size = 0
        try:
            for entry in path.rglob('*'):
                if entry.is_file():
                    total_size += entry.stat().st_size
        except (PermissionError, OSError):
            pass
        return total_size
    
    def format_size(self, size_bytes: int) -> str:
        """Format bytes to human-readable size"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} PB"
    
    def scan_all_games(self, callback=None) -> Dict:
        """Scan all configured game sources"""
        self.logger.info("Starting full game library scan...")
        
        all_games = []
        scan_results = {
            "steam": 0,
            "lutris": 0,
            "heroic": 0,
            "native": 0,
            "total": 0,
            "errors": []
        }
        
        if self.config["scan_steam"]:
            if callback:
                callback("Scanning Steam games...")
            try:
                steam_games = self.scan_steam_games()
                all_games.extend(steam_games)
                scan_results["steam"] = len(steam_games)
                self.logger.info(f"Found {len(steam_games)} Steam games")
            except Exception as e:
                scan_results["errors"].append(f"Steam scan error: {e}")
                self.logger.error(f"Steam scan error: {e}")
        
        if self.config["scan_lutris"]:
            if callback:
                callback("Scanning Lutris games...")
            try:
                lutris_games = self.scan_lutris_games()
                all_games.extend(lutris_games)
                scan_results["lutris"] = len(lutris_games)
                self.logger.info(f"Found {len(lutris_games)} Lutris games")
            except Exception as e:
                scan_results["errors"].append(f"Lutris scan error: {e}")
                self.logger.error(f"Lutris scan error: {e}")
        
        if self.config["scan_heroic"]:
            if callback:
                callback("Scanning Heroic games...")
            try:
                heroic_games = self.scan_heroic_games()
                all_games.extend(heroic_games)
                scan_results["heroic"] = len(heroic_games)
                self.logger.info(f"Found {len(heroic_games)} Heroic games")
            except Exception as e:
                scan_results["errors"].append(f"Heroic scan error: {e}")
                self.logger.error(f"Heroic scan error: {e}")
        
        if self.config["scan_native"]:
            if callback:
                callback("Scanning native games...")
            try:
                native_games = self.scan_native_games()
                all_games.extend(native_games)
                scan_results["native"] = len(native_games)
                self.logger.info(f"Found {len(native_games)} native games")
            except Exception as e:
                scan_results["errors"].append(f"Native scan error: {e}")
                self.logger.error(f"Native scan error: {e}")
        
        for game in all_games:
            game_id = game["id"]
            existing = self.library["games"].get(game_id, {})
            
            game["added_date"] = existing.get("added_date", datetime.now().isoformat())
            game["last_played"] = existing.get("last_played")
            game["play_count"] = existing.get("play_count", 0)
            game["favorite"] = existing.get("favorite", False)
            game["user_rating"] = existing.get("user_rating")
            game["notes"] = existing.get("notes", "")
            
            self.library["games"][game_id] = game
        
        scan_results["total"] = len(all_games)
        self.config["last_scan"] = datetime.now().isoformat()
        self.save_config()
        self.save_library()
        
        if callback:
            callback(f"Scan complete! Found {scan_results['total']} games")
        
        self.logger.info(f"Scan complete: {scan_results}")
        return scan_results
    
    def get_games(self, search: str = None, platform: str = None, 
                  sort_by: str = None, favorites_only: bool = False) -> List[Dict]:
        """Get games from library with optional filtering"""
        games = list(self.library["games"].values())
        
        if not self.config.get("show_hidden_games", False):
            games = [g for g in games if not g.get("hidden", False)]
        
        if search:
            search_lower = search.lower()
            games = [g for g in games if search_lower in g.get("name", "").lower()]
        
        if platform and platform != "all":
            games = [g for g in games if g.get("platform") == platform]
        
        if favorites_only:
            games = [g for g in games if g.get("favorite", False)]
        
        sort_key = sort_by or self.config.get("sort_by", "name")
        
        if sort_key == "name":
            games.sort(key=lambda x: x.get("name", "").lower())
        elif sort_key == "platform":
            games.sort(key=lambda x: (x.get("platform", ""), x.get("name", "").lower()))
        elif sort_key == "last_played":
            games.sort(key=lambda x: x.get("last_played") or "", reverse=True)
        elif sort_key == "play_count":
            games.sort(key=lambda x: x.get("play_count", 0), reverse=True)
        elif sort_key == "install_size":
            games.sort(key=lambda x: x.get("install_size", 0), reverse=True)
        
        return games
    
    def get_game(self, game_id: str) -> Optional[Dict]:
        """Get a specific game by ID"""
        return self.library["games"].get(game_id)
    
    def launch_game(self, game_id: str, callback=None) -> Dict:
        """Launch a game and track playtime"""
        game = self.get_game(game_id)
        if not game:
            return {"success": False, "error": f"Game '{game_id}' not found"}
        
        platform = game.get("platform", "")
        launch_cmd = game.get("launch_command", "")
        
        if not launch_cmd:
            return {"success": False, "error": "No launch command available"}
        
        result = {
            "success": False,
            "game_id": game_id,
            "game_name": game.get("name"),
            "platform": platform,
            "start_time": datetime.now().isoformat(),
            "end_time": None,
            "play_duration": 0,
            "error": None
        }
        
        self.logger.info(f"Launching game: {game.get('name')} ({platform})")
        if callback:
            callback(f"Launching {game.get('name')}...")
        
        try:
            start_time = time.time()
            
            if platform == "steam":
                subprocess.Popen(["xdg-open", launch_cmd])
                result["success"] = True
                
            elif platform == "lutris":
                subprocess.Popen(["xdg-open", launch_cmd])
                result["success"] = True
                
            elif platform.startswith("heroic"):
                subprocess.Popen(["xdg-open", launch_cmd])
                result["success"] = True
                
            elif platform == "native":
                exec_cmd = launch_cmd.replace("%f", "").replace("%F", "").replace("%u", "").replace("%U", "").strip()
                parts = exec_cmd.split()
                if parts:
                    process = subprocess.Popen(parts)
                    
                    if self.config.get("track_playtime", True):
                        process.wait()
                        end_time = time.time()
                        result["play_duration"] = int(end_time - start_time)
                    
                    result["success"] = True
            else:
                subprocess.Popen(["xdg-open", launch_cmd])
                result["success"] = True
            
            if result["success"]:
                game["last_played"] = datetime.now().isoformat()
                game["play_count"] = game.get("play_count", 0) + 1
                self.save_library()
                
                if self.config.get("track_playtime", True):
                    self.record_play_session(game_id, result.get("play_duration", 0))
                
        except Exception as e:
            result["success"] = False
            result["error"] = str(e)
            self.logger.error(f"Failed to launch game: {e}")
        
        result["end_time"] = datetime.now().isoformat()
        return result
    
    def record_play_session(self, game_id: str, duration: int):
        """Record a play session for tracking"""
        session = {
            "game_id": game_id,
            "start_time": datetime.now().isoformat(),
            "duration": duration
        }
        
        self.playtime["sessions"].append(session)
        
        if len(self.playtime["sessions"]) > 10000:
            self.playtime["sessions"] = self.playtime["sessions"][-10000:]
        
        current_total = self.playtime["totals"].get(game_id, 0)
        self.playtime["totals"][game_id] = current_total + duration
        
        self.save_playtime()
    
    def get_playtime(self, game_id: str = None) -> Dict:
        """Get playtime statistics"""
        if game_id:
            total_seconds = self.playtime["totals"].get(game_id, 0)
            sessions = [s for s in self.playtime["sessions"] if s["game_id"] == game_id]
            
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            
            return {
                "game_id": game_id,
                "total_seconds": total_seconds,
                "total_formatted": f"{hours}h {minutes}m",
                "session_count": len(sessions),
                "recent_sessions": sessions[-10:]
            }
        else:
            stats = {
                "total_games_played": len(self.playtime["totals"]),
                "total_playtime_seconds": sum(self.playtime["totals"].values()),
                "games": {}
            }
            
            for gid, total in sorted(self.playtime["totals"].items(), 
                                     key=lambda x: x[1], reverse=True):
                game = self.get_game(gid)
                hours = total // 3600
                minutes = (total % 3600) // 60
                stats["games"][gid] = {
                    "name": game.get("name", "Unknown") if game else "Unknown",
                    "total_seconds": total,
                    "total_formatted": f"{hours}h {minutes}m"
                }
            
            total_hours = stats["total_playtime_seconds"] // 3600
            total_minutes = (stats["total_playtime_seconds"] % 3600) // 60
            stats["total_playtime_formatted"] = f"{total_hours}h {total_minutes}m"
            
            return stats
    
    def toggle_favorite(self, game_id: str) -> bool:
        """Toggle favorite status for a game"""
        game = self.get_game(game_id)
        if not game:
            return False
        
        game["favorite"] = not game.get("favorite", False)
        self.save_library()
        return game["favorite"]
    
    def set_hidden(self, game_id: str, hidden: bool) -> bool:
        """Set hidden status for a game"""
        game = self.get_game(game_id)
        if not game:
            return False
        
        game["hidden"] = hidden
        self.save_library()
        return True
    
    def get_stats(self) -> Dict:
        """Get library statistics"""
        games = list(self.library["games"].values())
        
        platform_counts = {}
        total_size = 0
        favorites_count = 0
        played_count = 0
        
        for game in games:
            platform = game.get("platform", "unknown")
            platform_counts[platform] = platform_counts.get(platform, 0) + 1
            total_size += game.get("install_size", 0)
            
            if game.get("favorite"):
                favorites_count += 1
            
            if game.get("play_count", 0) > 0:
                played_count += 1
        
        playtime_stats = self.get_playtime()
        
        return {
            "total_games": len(games),
            "platform_counts": platform_counts,
            "total_install_size": total_size,
            "total_install_size_formatted": self.format_size(total_size),
            "favorites_count": favorites_count,
            "played_count": played_count,
            "never_played_count": len(games) - played_count,
            "total_playtime": playtime_stats.get("total_playtime_formatted", "0h 0m"),
            "last_scan": self.config.get("last_scan"),
            "library_version": self.library.get("version", self.version)
        }


class GameLibraryGUI:
    def __init__(self):
        self.library = AegisGameLibrary()
        self.root = tk.Tk()
        self.current_platform = "all"
        self.search_var = tk.StringVar()
        self.selected_game = None
        self.setup_window()
        self.create_widgets()
        self.refresh_game_list()
        
    def setup_window(self):
        """Configure the main window"""
        self.root.title("Aegis Game Library")
        self.root.geometry("1100x750")
        self.root.configure(bg='#1a1a2e')
        self.root.minsize(900, 650)
        
        style = ttk.Style()
        style.theme_use('clam')
        
        style.configure('TFrame', background='#1a1a2e')
        style.configure('TLabel', background='#1a1a2e', foreground='white', font=('Arial', 10))
        style.configure('TButton', padding=8, font=('Arial', 10))
        style.configure('Header.TLabel', font=('Arial', 22, 'bold'), foreground='#00d4ff')
        style.configure('SubHeader.TLabel', font=('Arial', 14, 'bold'), foreground='#00d4ff')
        style.configure('GameName.TLabel', font=('Arial', 12, 'bold'), foreground='#ffffff')
        style.configure('GameInfo.TLabel', font=('Arial', 9), foreground='#aaaaaa')
        style.configure('Platform.TLabel', font=('Arial', 9, 'bold'), foreground='#00ff88')
        style.configure('Stats.TLabel', font=('Arial', 11), foreground='#cccccc')
        
        style.configure('TLabelframe', background='#1a1a2e')
        style.configure('TLabelframe.Label', background='#1a1a2e', foreground='white', font=('Arial', 11, 'bold'))
        
        style.configure('Accent.TButton', font=('Arial', 11, 'bold'))
        
    def create_widgets(self):
        """Create GUI widgets"""
        header_frame = ttk.Frame(self.root)
        header_frame.pack(fill='x', padx=20, pady=15)
        
        title = ttk.Label(header_frame, text="üéÆ Aegis Game Library", style='Header.TLabel')
        title.pack(side='left')
        
        stats = self.library.get_stats()
        stats_text = f"üì¶ {stats['total_games']} Games | üíæ {stats['total_install_size_formatted']} | ‚è±Ô∏è {stats['total_playtime']}"
        stats_label = ttk.Label(header_frame, text=stats_text, style='Stats.TLabel')
        stats_label.pack(side='right')
        self.stats_label = stats_label
        
        toolbar_frame = ttk.Frame(self.root)
        toolbar_frame.pack(fill='x', padx=20, pady=5)
        
        search_entry = ttk.Entry(toolbar_frame, textvariable=self.search_var, width=35, font=('Arial', 11))
        search_entry.pack(side='left', padx=(0, 10))
        search_entry.insert(0, "Search games...")
        search_entry.bind('<FocusIn>', lambda e: search_entry.delete(0, tk.END) if search_entry.get() == "Search games..." else None)
        search_entry.bind('<Return>', lambda e: self.do_search())
        
        search_btn = ttk.Button(toolbar_frame, text="üîç Search", command=self.do_search)
        search_btn.pack(side='left', padx=5)
        
        clear_btn = ttk.Button(toolbar_frame, text="‚úñ Clear", command=self.clear_search)
        clear_btn.pack(side='left', padx=5)
        
        ttk.Separator(toolbar_frame, orient='vertical').pack(side='left', fill='y', padx=10)
        
        scan_btn = ttk.Button(toolbar_frame, text="üîÑ Scan Games", command=self.scan_games)
        scan_btn.pack(side='left', padx=5)
        
        stats_btn = ttk.Button(toolbar_frame, text="üìä Stats", command=self.show_stats)
        stats_btn.pack(side='right', padx=5)
        
        fav_btn = ttk.Button(toolbar_frame, text="‚≠ê Favorites", command=self.show_favorites)
        fav_btn.pack(side='right', padx=5)
        
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill='both', expand=True, padx=20, pady=10)
        
        left_panel = ttk.Frame(main_frame, width=180)
        left_panel.pack(side='left', fill='y', padx=(0, 10))
        left_panel.pack_propagate(False)
        
        plat_label = ttk.Label(left_panel, text="Platforms", style='SubHeader.TLabel')
        plat_label.pack(pady=(0, 10))
        
        platform_icons = {
            "all": ("üìã", "All Games"),
            "steam": ("üéÆ", "Steam"),
            "lutris": ("üç∑", "Lutris"),
            "heroic_epic": ("üèÜ", "Epic (Heroic)"),
            "heroic_gog": ("üéØ", "GOG (Heroic)"),
            "native": ("üêß", "Native Linux")
        }
        
        for plat_id, (icon, name) in platform_icons.items():
            btn = ttk.Button(
                left_panel, text=f"{icon} {name}",
                command=lambda p=plat_id: self.filter_by_platform(p)
            )
            btn.pack(fill='x', pady=2)
        
        right_panel = ttk.Frame(main_frame)
        right_panel.pack(side='right', fill='both', expand=True)
        
        list_header = ttk.Frame(right_panel)
        list_header.pack(fill='x', pady=(0, 5))
        
        self.list_title = ttk.Label(list_header, text="All Games", style='SubHeader.TLabel')
        self.list_title.pack(side='left')
        
        self.game_count_label = ttk.Label(list_header, text="", style='GameInfo.TLabel')
        self.game_count_label.pack(side='right')
        
        list_container = ttk.Frame(right_panel)
        list_container.pack(fill='both', expand=True)
        
        self.canvas = tk.Canvas(list_container, bg='#16213e', highlightthickness=0)
        scrollbar = ttk.Scrollbar(list_container, orient='vertical', command=self.canvas.yview)
        
        self.game_list_frame = ttk.Frame(self.canvas)
        
        self.canvas.configure(yscrollcommand=scrollbar.set)
        
        scrollbar.pack(side='right', fill='y')
        self.canvas.pack(side='left', fill='both', expand=True)
        
        self.canvas_window = self.canvas.create_window((0, 0), window=self.game_list_frame, anchor='nw')
        
        self.game_list_frame.bind('<Configure>', self.on_frame_configure)
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        
        self.canvas.bind_all('<MouseWheel>', lambda e: self.canvas.yview_scroll(int(-1*(e.delta/120)), "units"))
        self.canvas.bind_all('<Button-4>', lambda e: self.canvas.yview_scroll(-1, "units"))
        self.canvas.bind_all('<Button-5>', lambda e: self.canvas.yview_scroll(1, "units"))
        
        detail_frame = ttk.LabelFrame(right_panel, text="Game Details", padding=10)
        detail_frame.pack(fill='x', pady=(10, 0))
        
        self.detail_name = ttk.Label(detail_frame, text="Select a game", style='GameName.TLabel')
        self.detail_name.pack(anchor='w')
        
        self.detail_info = ttk.Label(detail_frame, text="", style='GameInfo.TLabel')
        self.detail_info.pack(anchor='w', pady=(5, 0))
        
        detail_buttons = ttk.Frame(detail_frame)
        detail_buttons.pack(fill='x', pady=(10, 0))
        
        self.launch_btn = ttk.Button(detail_buttons, text="‚ñ∂Ô∏è Launch Game", command=self.launch_selected, style='Accent.TButton')
        self.launch_btn.pack(side='left', padx=(0, 10))
        self.launch_btn.state(['disabled'])
        
        self.fav_btn = ttk.Button(detail_buttons, text="‚≠ê Favorite", command=self.toggle_favorite)
        self.fav_btn.pack(side='left', padx=5)
        self.fav_btn.state(['disabled'])
        
        self.hide_btn = ttk.Button(detail_buttons, text="üëÅÔ∏è Hide", command=self.toggle_hidden)
        self.hide_btn.pack(side='left', padx=5)
        self.hide_btn.state(['disabled'])
        
    def on_frame_configure(self, event):
        """Reset scroll region when frame size changes"""
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        
    def on_canvas_configure(self, event):
        """Resize frame when canvas size changes"""
        self.canvas.itemconfig(self.canvas_window, width=event.width)
    
    def refresh_game_list(self, games=None):
        """Refresh the game list display"""
        for widget in self.game_list_frame.winfo_children():
            widget.destroy()
        
        if games is None:
            search_term = self.search_var.get()
            if search_term == "Search games...":
                search_term = None
            
            platform = self.current_platform if self.current_platform != "all" else None
            games = self.library.get_games(search=search_term, platform=platform)
        
        self.game_count_label.config(text=f"({len(games)} games)")
        
        if not games:
            no_games = ttk.Label(self.game_list_frame, text="No games found", style='GameInfo.TLabel')
            no_games.pack(pady=20)
            return
        
        platform_icons = {
            "steam": "üéÆ",
            "lutris": "üç∑",
            "heroic_epic": "üèÜ",
            "heroic_gog": "üéØ",
            "native": "üêß"
        }
        
        for game in games:
            game_frame = tk.Frame(self.game_list_frame, bg='#1f2940', cursor='hand2')
            game_frame.pack(fill='x', pady=2, padx=5)
            
            game_frame.bind('<Enter>', lambda e, f=game_frame: f.configure(bg='#2a3a5a'))
            game_frame.bind('<Leave>', lambda e, f=game_frame: f.configure(bg='#1f2940'))
            game_frame.bind('<Button-1>', lambda e, g=game: self.select_game(g))
            game_frame.bind('<Double-Button-1>', lambda e, g=game: self.launch_game(g))
            
            platform_icon = platform_icons.get(game.get("platform", ""), "üì¶")
            fav_icon = "‚≠ê" if game.get("favorite") else ""
            
            info_frame = tk.Frame(game_frame, bg='#1f2940')
            info_frame.pack(fill='x', padx=10, pady=8)
            info_frame.bind('<Button-1>', lambda e, g=game: self.select_game(g))
            info_frame.bind('<Double-Button-1>', lambda e, g=game: self.launch_game(g))
            
            name_label = tk.Label(
                info_frame, 
                text=f"{platform_icon} {fav_icon} {game.get('name', 'Unknown')}",
                bg='#1f2940', fg='white', font=('Arial', 11, 'bold'),
                anchor='w'
            )
            name_label.pack(fill='x')
            name_label.bind('<Button-1>', lambda e, g=game: self.select_game(g))
            name_label.bind('<Double-Button-1>', lambda e, g=game: self.launch_game(g))
            
            size_str = self.library.format_size(game.get("install_size", 0)) if game.get("install_size", 0) > 0 else "N/A"
            last_played = game.get("last_played", "Never")
            if last_played and last_played != "Never":
                try:
                    dt = datetime.fromisoformat(last_played)
                    last_played = dt.strftime("%Y-%m-%d %H:%M")
                except:
                    pass
            
            play_count = game.get("play_count", 0)
            
            info_text = f"Platform: {game.get('platform', 'unknown').title()} | Size: {size_str} | Played: {play_count}x | Last: {last_played}"
            
            info_label = tk.Label(
                info_frame,
                text=info_text,
                bg='#1f2940', fg='#888888', font=('Arial', 9),
                anchor='w'
            )
            info_label.pack(fill='x')
            info_label.bind('<Button-1>', lambda e, g=game: self.select_game(g))
            info_label.bind('<Double-Button-1>', lambda e, g=game: self.launch_game(g))
        
        self.update_stats_display()
    
    def select_game(self, game: Dict):
        """Select a game and show details"""
        self.selected_game = game
        
        self.detail_name.config(text=f"üéÆ {game.get('name', 'Unknown')}")
        
        size_str = self.library.format_size(game.get("install_size", 0)) if game.get("install_size", 0) > 0 else "N/A"
        last_played = game.get("last_played", "Never")
        if last_played and last_played != "Never":
            try:
                dt = datetime.fromisoformat(last_played)
                last_played = dt.strftime("%Y-%m-%d %H:%M")
            except:
                pass
        
        playtime = self.library.get_playtime(game.get("id"))
        playtime_str = playtime.get("total_formatted", "0h 0m")
        
        info_lines = [
            f"Platform: {game.get('platform', 'unknown').title()}",
            f"Install Size: {size_str}",
            f"Play Count: {game.get('play_count', 0)}",
            f"Total Playtime: {playtime_str}",
            f"Last Played: {last_played}",
            f"Install Path: {game.get('install_path', 'N/A')}"
        ]
        
        self.detail_info.config(text=" | ".join(info_lines[:4]) + f"\n{info_lines[5]}")
        
        self.launch_btn.state(['!disabled'])
        self.fav_btn.state(['!disabled'])
        self.hide_btn.state(['!disabled'])
        
        if game.get("favorite"):
            self.fav_btn.config(text="‚≠ê Unfavorite")
        else:
            self.fav_btn.config(text="‚òÜ Favorite")
    
    def launch_selected(self):
        """Launch the selected game"""
        if self.selected_game:
            self.launch_game(self.selected_game)
    
    def launch_game(self, game: Dict):
        """Launch a game"""
        result = self.library.launch_game(game.get("id"))
        
        if result.get("success"):
            messagebox.showinfo("Game Launched", f"Launching {game.get('name')}...")
        else:
            messagebox.showerror("Launch Failed", f"Failed to launch game: {result.get('error', 'Unknown error')}")
    
    def toggle_favorite(self):
        """Toggle favorite status for selected game"""
        if self.selected_game:
            is_fav = self.library.toggle_favorite(self.selected_game.get("id"))
            self.selected_game["favorite"] = is_fav
            
            if is_fav:
                self.fav_btn.config(text="‚≠ê Unfavorite")
            else:
                self.fav_btn.config(text="‚òÜ Favorite")
            
            self.refresh_game_list()
    
    def toggle_hidden(self):
        """Toggle hidden status for selected game"""
        if self.selected_game:
            current_hidden = self.selected_game.get("hidden", False)
            self.library.set_hidden(self.selected_game.get("id"), not current_hidden)
            self.refresh_game_list()
    
    def filter_by_platform(self, platform: str):
        """Filter games by platform"""
        self.current_platform = platform
        
        platform_names = {
            "all": "All Games",
            "steam": "Steam Games",
            "lutris": "Lutris Games",
            "heroic_epic": "Epic Games (Heroic)",
            "heroic_gog": "GOG Games (Heroic)",
            "native": "Native Linux Games"
        }
        
        self.list_title.config(text=platform_names.get(platform, "Games"))
        self.refresh_game_list()
    
    def do_search(self):
        """Perform search"""
        self.refresh_game_list()
    
    def clear_search(self):
        """Clear search"""
        self.search_var.set("Search games...")
        self.current_platform = "all"
        self.list_title.config(text="All Games")
        self.refresh_game_list()
    
    def show_favorites(self):
        """Show favorite games"""
        games = self.library.get_games(favorites_only=True)
        self.list_title.config(text="‚≠ê Favorite Games")
        self.refresh_game_list(games)
    
    def scan_games(self):
        """Scan for games"""
        def do_scan():
            self.library.scan_all_games(callback=lambda msg: None)
            self.root.after(0, self.refresh_game_list)
            self.root.after(0, lambda: messagebox.showinfo("Scan Complete", "Game library scan completed!"))
        
        messagebox.showinfo("Scanning", "Scanning for games... This may take a moment.")
        thread = threading.Thread(target=do_scan, daemon=True)
        thread.start()
    
    def show_stats(self):
        """Show library statistics"""
        stats = self.library.get_stats()
        playtime = self.library.get_playtime()
        
        stats_window = tk.Toplevel(self.root)
        stats_window.title("Library Statistics")
        stats_window.geometry("500x600")
        stats_window.configure(bg='#1a1a2e')
        
        title = tk.Label(stats_window, text="üìä Library Statistics", 
                        font=('Arial', 16, 'bold'), bg='#1a1a2e', fg='#00d4ff')
        title.pack(pady=20)
        
        stats_frame = tk.Frame(stats_window, bg='#1a1a2e')
        stats_frame.pack(fill='both', expand=True, padx=20)
        
        stats_text = f"""
üì¶ Total Games: {stats['total_games']}
üíæ Total Install Size: {stats['total_install_size_formatted']}
‚≠ê Favorites: {stats['favorites_count']}
üéÆ Games Played: {stats['played_count']}
üìµ Never Played: {stats['never_played_count']}
‚è±Ô∏è Total Playtime: {stats['total_playtime']}

üìã Games by Platform:
"""
        
        for platform, count in stats['platform_counts'].items():
            stats_text += f"   ‚Ä¢ {platform.title()}: {count}\n"
        
        if playtime.get("games"):
            stats_text += "\nüèÜ Most Played Games:\n"
            for i, (gid, gdata) in enumerate(list(playtime["games"].items())[:5]):
                stats_text += f"   {i+1}. {gdata['name']}: {gdata['total_formatted']}\n"
        
        stats_text += f"\nüîÑ Last Scan: {stats.get('last_scan', 'Never')}"
        
        stats_label = tk.Label(stats_frame, text=stats_text, 
                              font=('Arial', 11), bg='#1a1a2e', fg='white',
                              justify='left', anchor='nw')
        stats_label.pack(fill='both', expand=True)
        
        close_btn = ttk.Button(stats_window, text="Close", command=stats_window.destroy)
        close_btn.pack(pady=20)
    
    def update_stats_display(self):
        """Update the stats display in header"""
        stats = self.library.get_stats()
        stats_text = f"üì¶ {stats['total_games']} Games | üíæ {stats['total_install_size_formatted']} | ‚è±Ô∏è {stats['total_playtime']}"
        self.stats_label.config(text=stats_text)
    
    def run(self):
        """Run the GUI"""
        if self.library.config.get("auto_scan_on_start"):
            if not self.library.config.get("last_scan"):
                thread = threading.Thread(target=lambda: self.library.scan_all_games(), daemon=True)
                thread.start()
        
        self.root.mainloop()


def cli_main():
    """Command-line interface"""
    parser = argparse.ArgumentParser(
        description="Aegis Game Library - Unified Game Launcher",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  aegis-game-library --scan                    Scan for installed games
  aegis-game-library --list                    List all games
  aegis-game-library --list --platform steam   List Steam games only
  aegis-game-library --launch steam_12345      Launch a specific game
  aegis-game-library --stats                   Show library statistics
  aegis-game-library                           Launch GUI mode
        """
    )
    
    parser.add_argument('--scan', action='store_true', help='Scan for installed games')
    parser.add_argument('--list', action='store_true', help='List all games')
    parser.add_argument('--launch', metavar='GAME_ID', help='Launch a game by ID')
    parser.add_argument('--stats', action='store_true', help='Show library statistics')
    parser.add_argument('--playtime', metavar='GAME_ID', nargs='?', const='all', 
                       help='Show playtime (optionally for specific game)')
    parser.add_argument('--platform', choices=['steam', 'lutris', 'heroic_epic', 'heroic_gog', 'native'],
                       help='Filter by platform (use with --list)')
    parser.add_argument('--search', metavar='TERM', help='Search games by name')
    parser.add_argument('--favorites', action='store_true', help='Show only favorites')
    parser.add_argument('--json', action='store_true', help='Output in JSON format')
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--version', action='version', version='Aegis Game Library 1.0.0')
    
    args = parser.parse_args()
    
    if len(sys.argv) == 1 or args.gui:
        if TKINTER_AVAILABLE:
            gui = GameLibraryGUI()
            gui.run()
        else:
            print("Error: GUI requires tkinter. Install python3-tk or use CLI mode.")
            sys.exit(1)
        return
    
    library = AegisGameLibrary()
    
    if args.scan:
        print("üîç Scanning for installed games...")
        results = library.scan_all_games(callback=lambda msg: print(f"   {msg}"))
        
        if args.json:
            print(json.dumps(results, indent=2))
        else:
            print(f"\n‚úÖ Scan Complete!")
            print(f"   Steam: {results['steam']} games")
            print(f"   Lutris: {results['lutris']} games")
            print(f"   Heroic: {results['heroic']} games")
            print(f"   Native: {results['native']} games")
            print(f"   Total: {results['total']} games")
            
            if results['errors']:
                print(f"\n‚ö†Ô∏è  Errors:")
                for err in results['errors']:
                    print(f"   - {err}")
    
    elif args.list:
        games = library.get_games(
            search=args.search,
            platform=args.platform,
            favorites_only=args.favorites
        )
        
        if args.json:
            print(json.dumps(games, indent=2))
        else:
            if not games:
                print("No games found.")
                return
            
            print(f"\nüéÆ Game Library ({len(games)} games)")
            print("=" * 80)
            
            platform_icons = {
                "steam": "üéÆ",
                "lutris": "üç∑",
                "heroic_epic": "üèÜ",
                "heroic_gog": "üéØ",
                "native": "üêß"
            }
            
            for game in games:
                icon = platform_icons.get(game.get("platform", ""), "üì¶")
                fav = "‚≠ê" if game.get("favorite") else "  "
                size = library.format_size(game.get("install_size", 0)) if game.get("install_size", 0) > 0 else "N/A"
                
                print(f"{icon} {fav} {game.get('name', 'Unknown'):<40} [{game.get('platform', 'unknown'):<12}] {size:>10}")
                print(f"      ID: {game.get('id')}")
    
    elif args.launch:
        game = library.get_game(args.launch)
        
        if not game:
            games = library.get_games(search=args.launch)
            if len(games) == 1:
                game = games[0]
            elif len(games) > 1:
                print(f"Multiple games match '{args.launch}':")
                for g in games:
                    print(f"  - {g.get('id')}: {g.get('name')}")
                print("Please specify the exact game ID.")
                sys.exit(1)
            else:
                print(f"Game not found: {args.launch}")
                sys.exit(1)
        
        print(f"üöÄ Launching {game.get('name')}...")
        result = library.launch_game(game.get("id"))
        
        if result.get("success"):
            print("‚úÖ Game launched successfully!")
        else:
            print(f"‚ùå Failed to launch: {result.get('error', 'Unknown error')}")
            sys.exit(1)
    
    elif args.stats:
        stats = library.get_stats()
        
        if args.json:
            print(json.dumps(stats, indent=2))
        else:
            print("\nüìä Library Statistics")
            print("=" * 50)
            print(f"üì¶ Total Games: {stats['total_games']}")
            print(f"üíæ Total Install Size: {stats['total_install_size_formatted']}")
            print(f"‚≠ê Favorites: {stats['favorites_count']}")
            print(f"üéÆ Games Played: {stats['played_count']}")
            print(f"üìµ Never Played: {stats['never_played_count']}")
            print(f"‚è±Ô∏è Total Playtime: {stats['total_playtime']}")
            
            print("\nüìã Games by Platform:")
            for platform, count in stats['platform_counts'].items():
                print(f"   ‚Ä¢ {platform.title()}: {count}")
            
            print(f"\nüîÑ Last Scan: {stats.get('last_scan', 'Never')}")
    
    elif args.playtime:
        if args.playtime == 'all':
            playtime = library.get_playtime()
        else:
            playtime = library.get_playtime(args.playtime)
        
        if args.json:
            print(json.dumps(playtime, indent=2))
        else:
            if args.playtime == 'all':
                print("\n‚è±Ô∏è Playtime Statistics")
                print("=" * 50)
                print(f"Total Games Played: {playtime.get('total_games_played', 0)}")
                print(f"Total Playtime: {playtime.get('total_playtime_formatted', '0h 0m')}")
                
                if playtime.get("games"):
                    print("\nüèÜ Games by Playtime:")
                    for gid, gdata in list(playtime["games"].items())[:20]:
                        print(f"   ‚Ä¢ {gdata['name']}: {gdata['total_formatted']}")
            else:
                game = library.get_game(args.playtime)
                game_name = game.get("name", args.playtime) if game else args.playtime
                
                print(f"\n‚è±Ô∏è Playtime for {game_name}")
                print("=" * 50)
                print(f"Total Time: {playtime.get('total_formatted', '0h 0m')}")
                print(f"Sessions: {playtime.get('session_count', 0)}")
    
    else:
        parser.print_help()


if __name__ == "__main__":
    cli_main()
