#!/usr/bin/env python3
"""
Aegis OS Wallpaper Engine v3.1 - SIGMA Edition
Advanced animated wallpaper system with MPV rendering, AI preference learning, and auto-updates
Supports: MP4, AVI, MKV, WebM, MOV, GIF, HEVC, VP9, AV1, and all image formats
"""

import os
import sys
import json
import subprocess
import threading
import time
import signal
import hashlib
import random
from pathlib import Path
from datetime import datetime, timedelta
from collections import defaultdict

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox
    TK_AVAILABLE = True
except ImportError:
    TK_AVAILABLE = False

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False

try:
    import urllib.request
    import urllib.error
    URLLIB_AVAILABLE = True
except ImportError:
    URLLIB_AVAILABLE = False

SUPPORTED_VIDEO_FORMATS = ['.mp4', '.avi', '.mkv', '.webm', '.mov', '.wmv', '.flv', '.m4v', '.3gp', '.ogv', '.ts', '.mts']
SUPPORTED_IMAGE_FORMATS = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg', '.heic', '.heif']
SUPPORTED_AUDIO_FORMATS = ['.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a']

UPDATE_CHECK_URL = "https://aegis-os.example.com/api/updates/wallpaper-engine"
UPDATE_CHECK_INTERVAL_DAYS = 7


class AudioController:
    """Advanced audio control system with per-application volume"""
    
    def __init__(self):
        self.master_volume = 100
        self.wallpaper_volume = 50
        self.muted = False
        self.audio_ducking = True
        self.ducking_level = 30
        self.equalizer = {'bass': 0, 'mid': 0, 'treble': 0}
        
    def set_master_volume(self, level):
        """Set system-wide wallpaper audio volume (0-100)"""
        self.master_volume = max(0, min(100, level))
        self._apply_volume()
        
    def set_wallpaper_volume(self, level):
        """Set wallpaper-specific volume"""
        self.wallpaper_volume = max(0, min(100, level))
        self._apply_volume()
        
    def toggle_mute(self):
        """Toggle audio mute"""
        self.muted = not self.muted
        self._apply_volume()
        return self.muted
        
    def set_audio_ducking(self, enabled, level=30):
        """Enable/disable audio ducking when other apps play sound"""
        self.audio_ducking = enabled
        self.ducking_level = level
        
    def set_equalizer(self, bass=0, mid=0, treble=0):
        """Set equalizer levels (-10 to +10)"""
        self.equalizer = {
            'bass': max(-10, min(10, bass)),
            'mid': max(-10, min(10, mid)),
            'treble': max(-10, min(10, treble))
        }
        
    def _apply_volume(self):
        """Apply volume settings via PulseAudio/PipeWire"""
        if self.muted:
            volume = 0
        else:
            volume = int(self.master_volume * self.wallpaper_volume / 100)
            
        try:
            subprocess.run([
                'pactl', 'set-sink-input-volume', 
                '@DEFAULT_SINK@', f'{volume}%'
            ], capture_output=True, timeout=2)
        except:
            pass


class VideoProcessor:
    """FFmpeg-based video processing for wallpapers"""
    
    def __init__(self):
        self.ffmpeg_available = self._check_ffmpeg()
        self.cache_dir = Path("/tmp/aegis-wallpaper-cache")
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
    def _check_ffmpeg(self):
        """Check if FFmpeg is available"""
        try:
            result = subprocess.run(['ffmpeg', '-version'], capture_output=True, timeout=5)
            return result.returncode == 0
        except:
            return False
            
    def get_video_info(self, video_path):
        """Get video metadata using ffprobe"""
        if not self.ffmpeg_available:
            return None
            
        try:
            cmd = [
                'ffprobe', '-v', 'quiet', '-print_format', 'json',
                '-show_format', '-show_streams', str(video_path)
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                return json.loads(result.stdout)
        except:
            pass
        return None
        
    def remove_audio(self, video_path, output_path=None):
        """Create silent version of video"""
        if not self.ffmpeg_available:
            return video_path
            
        if output_path is None:
            output_path = self.cache_dir / f"{Path(video_path).stem}_silent.mp4"
            
        if output_path.exists():
            return str(output_path)
            
        try:
            cmd = [
                'ffmpeg', '-y', '-i', str(video_path),
                '-an', '-c:v', 'copy', str(output_path)
            ]
            result = subprocess.run(cmd, capture_output=True, timeout=300)
            if result.returncode == 0:
                return str(output_path)
        except:
            pass
        return video_path
        
    def upscale_video(self, video_path, target_resolution='4k'):
        """Upscale video to higher resolution"""
        if not self.ffmpeg_available:
            return video_path
            
        resolutions = {
            '1080p': '1920:1080',
            '1440p': '2560:1440',
            '4k': '3840:2160',
            '8k': '7680:4320'
        }
        
        res = resolutions.get(target_resolution, '3840:2160')
        output_path = self.cache_dir / f"{Path(video_path).stem}_{target_resolution}.mp4"
        
        if output_path.exists():
            return str(output_path)
            
        try:
            cmd = [
                'ffmpeg', '-y', '-i', str(video_path),
                '-vf', f'scale={res}:flags=lanczos',
                '-c:v', 'libx264', '-preset', 'slow', '-crf', '18',
                '-c:a', 'copy', str(output_path)
            ]
            result = subprocess.run(cmd, capture_output=True, timeout=1800)
            if result.returncode == 0:
                return str(output_path)
        except:
            pass
        return video_path
        
    def generate_thumbnail(self, video_path, time_offset='00:00:01'):
        """Generate thumbnail from video"""
        if not self.ffmpeg_available:
            return None
            
        output_path = self.cache_dir / f"{Path(video_path).stem}_thumb.jpg"
        
        try:
            cmd = [
                'ffmpeg', '-y', '-ss', time_offset, '-i', str(video_path),
                '-vframes', '1', '-q:v', '2', str(output_path)
            ]
            result = subprocess.run(cmd, capture_output=True, timeout=30)
            if result.returncode == 0:
                return str(output_path)
        except:
            pass
        return None


class MPVRenderer:
    """MPV-based wallpaper rendering using xwinwrap or direct --wid"""
    
    def __init__(self):
        self.mpv_available = self._check_mpv()
        self.xwinwrap_available = self._check_xwinwrap()
        self.process = None
        self.xwinwrap_process = None
        
    def _check_mpv(self):
        """Check if MPV is available"""
        try:
            result = subprocess.run(['mpv', '--version'], capture_output=True, timeout=5)
            return result.returncode == 0
        except:
            return False
            
    def _check_xwinwrap(self):
        """Check if xwinwrap is available"""
        try:
            result = subprocess.run(['which', 'xwinwrap'], capture_output=True, timeout=5)
            return result.returncode == 0
        except:
            return False
            
    def is_available(self):
        """Check if MPV rendering is available"""
        return self.mpv_available
        
    def get_root_window_id(self, display=':0'):
        """Get root window ID for desktop"""
        try:
            env = os.environ.copy()
            env['DISPLAY'] = display
            result = subprocess.run(
                ['xdotool', 'search', '--class', 'Desktop'],
                capture_output=True, text=True, timeout=5, env=env
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip().split('\n')[0]
                
            result = subprocess.run(
                ['xwininfo', '-root'],
                capture_output=True, text=True, timeout=5, env=env
            )
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'Window id:' in line:
                        parts = line.split()
                        for i, p in enumerate(parts):
                            if p.startswith('0x'):
                                return p
        except:
            pass
        return None
        
    def start_video(self, video_path, options=None, display=':0'):
        """Start MPV video wallpaper"""
        if not self.mpv_available:
            print("MPV not found. Install with: sudo apt install mpv")
            return False
            
        self.stop()
        options = options or {}
        
        env = os.environ.copy()
        env['DISPLAY'] = display
        
        volume = options.get('volume', 0)
        if options.get('muted', True):
            volume = 0
            
        loop_flag = '--loop' if options.get('loop', True) else ''
        
        brightness = options.get('brightness', 0)
        contrast = options.get('contrast', 0)
        saturation = options.get('saturation', 0)
        
        if self.xwinwrap_available:
            screen_res = self._get_screen_resolution(display)
            
            mpv_cmd = f"mpv --wid WID {loop_flag} --no-audio --no-osc --no-input-default-bindings " \
                      f"--no-border --panscan=1.0 --video-unscaled=downscale-big " \
                      f"--brightness={brightness} --contrast={contrast} --saturation={saturation} " \
                      f"'{video_path}'"
            
            cmd = [
                'xwinwrap', '-g', f'{screen_res}+0+0', '-ov', '-ni', '-s', '-nf',
                '--', 'sh', '-c', mpv_cmd
            ]
        else:
            wid = self.get_root_window_id(display)
            cmd = [
                'mpv',
                '--no-audio' if options.get('muted', True) else f'--volume={volume}',
                '--loop' if options.get('loop', True) else '--loop=no',
                '--no-osc',
                '--no-input-default-bindings',
                '--no-border',
                '--panscan=1.0',
                f'--brightness={brightness}',
                f'--contrast={contrast}',
                f'--saturation={saturation}',
            ]
            if wid:
                cmd.extend(['--wid', wid])
            cmd.append(str(video_path))
            
        try:
            self.process = subprocess.Popen(
                cmd,
                env=env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            return True
        except Exception as e:
            print(f"Failed to start MPV: {e}")
            return False
            
    def start_image(self, image_path, options=None, display=':0'):
        """Set image wallpaper using feh/xfconf"""
        options = options or {}
        effect = options.get('effect', 'none')
        
        if effect != 'none' and self.mpv_available:
            return self._start_animated_image(image_path, effect, display)
        else:
            return self._set_static_image(image_path, display)
            
    def _start_animated_image(self, image_path, effect, display):
        """Start animated image effects using MPV"""
        self.stop()
        
        env = os.environ.copy()
        env['DISPLAY'] = display
        
        vf_filter = ''
        if effect == 'ken-burns':
            vf_filter = 'zoompan=z=\'min(zoom+0.0015,1.5)\':d=1:x=\'iw/2-(iw/zoom/2)\':y=\'ih/2-(ih/zoom/2)\':s=1920x1080'
        elif effect == 'parallax':
            vf_filter = 'scroll=horizontal=0.01:vertical=0'
        elif effect == 'pulse':
            vf_filter = 'eq=brightness=\'0.1*sin(2*PI*t/4)\''
            
        if self.xwinwrap_available:
            screen_res = self._get_screen_resolution(display)
            
            mpv_cmd = f"mpv --wid WID --loop --no-audio --no-osc --no-input-default-bindings " \
                      f"--no-border --image-display-duration=inf "
            if vf_filter:
                mpv_cmd += f"--vf='{vf_filter}' "
            mpv_cmd += f"'{image_path}'"
            
            cmd = [
                'xwinwrap', '-g', f'{screen_res}+0+0', '-ov', '-ni', '-s', '-nf',
                '--', 'sh', '-c', mpv_cmd
            ]
        else:
            cmd = [
                'mpv',
                '--loop',
                '--no-audio',
                '--no-osc',
                '--no-input-default-bindings',
                '--no-border',
                '--image-display-duration=inf',
            ]
            if vf_filter:
                cmd.append(f'--vf={vf_filter}')
            cmd.append(str(image_path))
            
        try:
            self.process = subprocess.Popen(
                cmd,
                env=env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            return True
        except:
            return self._set_static_image(image_path, display)
            
    def _set_static_image(self, image_path, display):
        """Set static wallpaper using desktop tools"""
        env = os.environ.copy()
        env['DISPLAY'] = display
        
        try:
            subprocess.run([
                'xfconf-query', '-c', 'xfce4-desktop',
                '-p', '/backdrop/screen0/monitor0/workspace0/last-image',
                '-s', str(image_path)
            ], capture_output=True, timeout=10, env=env)
            return True
        except:
            pass
            
        try:
            subprocess.run([
                'gsettings', 'set', 'org.gnome.desktop.background',
                'picture-uri', f'file://{image_path}'
            ], capture_output=True, timeout=10, env=env)
            return True
        except:
            pass
            
        try:
            subprocess.run([
                'feh', '--bg-fill', str(image_path)
            ], capture_output=True, timeout=10, env=env)
            return True
        except:
            pass
            
        return False
        
    def _get_screen_resolution(self, display):
        """Get screen resolution"""
        try:
            env = os.environ.copy()
            env['DISPLAY'] = display
            result = subprocess.run(
                ['xrandr', '--query'],
                capture_output=True, text=True, timeout=5, env=env
            )
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if ' connected' in line and 'x' in line:
                        for part in line.split():
                            if 'x' in part and part[0].isdigit():
                                res = part.split('+')[0]
                                return res
        except:
            pass
        return '1920x1080'
        
    def stop(self):
        """Stop MPV renderer"""
        if self.process:
            try:
                self.process.terminate()
                self.process.wait(timeout=5)
            except:
                try:
                    self.process.kill()
                except:
                    pass
            self.process = None
            
        if self.xwinwrap_process:
            try:
                self.xwinwrap_process.terminate()
                self.xwinwrap_process.wait(timeout=5)
            except:
                try:
                    self.xwinwrap_process.kill()
                except:
                    pass
            self.xwinwrap_process = None
            
        subprocess.run(['pkill', '-f', 'xwinwrap.*mpv'], capture_output=True)
        subprocess.run(['pkill', '-f', 'mpv.*wallpaper'], capture_output=True)


class PreferenceLearner:
    """AI-based preference learning system for wallpaper suggestions"""
    
    def __init__(self):
        self.config_dir = Path.home() / ".config/aegis"
        self.preferences_file = self.config_dir / "wallpaper-preferences.json"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.preferences = self._load_preferences()
        
    def _load_preferences(self):
        """Load stored preferences"""
        default = {
            'history': [],
            'time_patterns': defaultdict(list),
            'category_scores': defaultdict(float),
            'settings_history': [],
            'favorite_dirs': [],
            'avg_duration': 0,
            'total_sessions': 0
        }
        
        try:
            with open(self.preferences_file, 'r') as f:
                data = json.load(f)
                for key, val in data.items():
                    if key in ['time_patterns', 'category_scores']:
                        default[key] = defaultdict(float if key == 'category_scores' else list, val)
                    else:
                        default[key] = val
                return default
        except (FileNotFoundError, json.JSONDecodeError):
            return default
            
    def _save_preferences(self):
        """Save preferences to disk"""
        save_data = {
            'history': self.preferences['history'][-100:],
            'time_patterns': dict(self.preferences['time_patterns']),
            'category_scores': dict(self.preferences['category_scores']),
            'settings_history': self.preferences['settings_history'][-50:],
            'favorite_dirs': self.preferences['favorite_dirs'][:10],
            'avg_duration': self.preferences['avg_duration'],
            'total_sessions': self.preferences['total_sessions']
        }
        
        try:
            with open(self.preferences_file, 'w') as f:
                json.dump(save_data, f, indent=2)
        except:
            pass
            
    def record_wallpaper_set(self, path, settings=None):
        """Record when user sets a wallpaper"""
        now = datetime.now()
        hour = now.hour
        day_of_week = now.strftime('%A')
        
        time_slot = 'morning' if 5 <= hour < 12 else \
                    'afternoon' if 12 <= hour < 17 else \
                    'evening' if 17 <= hour < 21 else 'night'
        
        category = self._detect_category(path)
        
        entry = {
            'path': str(path),
            'timestamp': now.isoformat(),
            'hour': hour,
            'day': day_of_week,
            'time_slot': time_slot,
            'category': category,
            'settings': settings or {}
        }
        
        self.preferences['history'].append(entry)
        self.preferences['time_patterns'][time_slot].append(str(path))
        self.preferences['category_scores'][category] += 1.0
        self.preferences['total_sessions'] += 1
        
        parent_dir = str(Path(path).parent)
        if parent_dir not in self.preferences['favorite_dirs']:
            self.preferences['favorite_dirs'].insert(0, parent_dir)
            self.preferences['favorite_dirs'] = self.preferences['favorite_dirs'][:10]
            
        if settings:
            self.preferences['settings_history'].append({
                'category': category,
                'time_slot': time_slot,
                'settings': settings
            })
            
        self._save_preferences()
        
    def _detect_category(self, path):
        """Detect wallpaper category from path/filename"""
        path_lower = str(path).lower()
        
        categories = {
            'nature': ['nature', 'forest', 'mountain', 'ocean', 'sky', 'landscape', 'tree', 'water', 'sunset', 'sunrise'],
            'space': ['space', 'galaxy', 'star', 'planet', 'nebula', 'cosmos', 'universe', 'moon', 'aurora'],
            'abstract': ['abstract', 'geometric', 'pattern', 'fractal', 'minimal', 'art', 'design'],
            'gaming': ['game', 'gaming', 'cyberpunk', 'neon', 'scifi', 'fantasy', 'anime'],
            'urban': ['city', 'urban', 'street', 'building', 'architecture', 'night'],
            'animals': ['animal', 'cat', 'dog', 'bird', 'wildlife', 'pet'],
            'technology': ['tech', 'code', 'computer', 'circuit', 'digital', 'cyber']
        }
        
        for category, keywords in categories.items():
            for keyword in keywords:
                if keyword in path_lower:
                    return category
                    
        return 'general'
        
    def get_suggestions(self, count=5):
        """Get wallpaper suggestions based on learned patterns"""
        now = datetime.now()
        hour = now.hour
        time_slot = 'morning' if 5 <= hour < 12 else \
                    'afternoon' if 12 <= hour < 17 else \
                    'evening' if 17 <= hour < 21 else 'night'
        
        suggestions = []
        
        time_based = self.preferences['time_patterns'].get(time_slot, [])
        if time_based:
            time_suggestions = [p for p in time_based if Path(p).exists()][-count:]
            suggestions.extend(time_suggestions)
            
        sorted_categories = sorted(
            self.preferences['category_scores'].items(),
            key=lambda x: x[1],
            reverse=True
        )[:3]
        
        for dir_path in self.preferences['favorite_dirs'][:3]:
            if Path(dir_path).exists():
                try:
                    files = list(Path(dir_path).glob('*'))
                    for f in files[:2]:
                        ext = f.suffix.lower()
                        if ext in SUPPORTED_VIDEO_FORMATS + SUPPORTED_IMAGE_FORMATS:
                            if str(f) not in suggestions:
                                suggestions.append(str(f))
                except:
                    pass
                    
        seen = set()
        unique_suggestions = []
        for s in suggestions:
            if s not in seen:
                seen.add(s)
                unique_suggestions.append(s)
                
        return unique_suggestions[:count]
        
    def get_optimal_settings(self, category=None, time_slot=None):
        """Get learned optimal settings for category/time"""
        if not self.preferences['settings_history']:
            return {}
            
        relevant = [s for s in self.preferences['settings_history'] 
                   if (category is None or s.get('category') == category) and
                      (time_slot is None or s.get('time_slot') == time_slot)]
        
        if not relevant:
            relevant = self.preferences['settings_history']
            
        if not relevant:
            return {}
            
        avg_settings = {}
        setting_counts = defaultdict(int)
        
        for entry in relevant:
            settings = entry.get('settings', {})
            for key, val in settings.items():
                if isinstance(val, (int, float)):
                    avg_settings[key] = avg_settings.get(key, 0) + val
                    setting_counts[key] += 1
                    
        for key in avg_settings:
            avg_settings[key] = avg_settings[key] / setting_counts[key]
            
        return avg_settings
        
    def get_stats(self):
        """Get usage statistics"""
        return {
            'total_wallpapers_set': len(self.preferences['history']),
            'total_sessions': self.preferences['total_sessions'],
            'favorite_categories': dict(sorted(
                self.preferences['category_scores'].items(),
                key=lambda x: x[1],
                reverse=True
            )[:5]),
            'favorite_dirs': self.preferences['favorite_dirs'][:5],
            'last_used': self.preferences['history'][-1] if self.preferences['history'] else None
        }


class UpdateChecker:
    """Weekly update checker for wallpaper engine"""
    
    def __init__(self):
        self.config_dir = Path.home() / ".config/aegis"
        self.update_file = self.config_dir / "wallpaper-updates.json"
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.update_data = self._load_update_data()
        
    def _load_update_data(self):
        """Load update check data"""
        default = {
            'last_check': None,
            'last_version': '3.1.0',
            'news': [],
            'tips': [],
            'featured_wallpapers': [],
            'notifications': []
        }
        
        try:
            with open(self.update_file, 'r') as f:
                return {**default, **json.load(f)}
        except:
            return default
            
    def _save_update_data(self):
        """Save update data"""
        try:
            with open(self.update_file, 'w') as f:
                json.dump(self.update_data, f, indent=2)
        except:
            pass
            
    def should_check(self):
        """Check if it's time for an update check"""
        if not self.update_data['last_check']:
            return True
            
        try:
            last_check = datetime.fromisoformat(self.update_data['last_check'])
            return datetime.now() - last_check > timedelta(days=UPDATE_CHECK_INTERVAL_DAYS)
        except:
            return True
            
    def check_for_updates(self, force=False):
        """Check for updates from server"""
        if not force and not self.should_check():
            return self.update_data
            
        if not URLLIB_AVAILABLE:
            return self._simulate_update_response()
            
        try:
            req = urllib.request.Request(
                UPDATE_CHECK_URL,
                headers={'User-Agent': 'AegisWallpaperEngine/3.1'}
            )
            
            with urllib.request.urlopen(req, timeout=10) as response:
                data = json.loads(response.read().decode())
                self._process_update_response(data)
                
        except (urllib.error.URLError, json.JSONDecodeError, TimeoutError):
            return self._simulate_update_response()
            
        return self.update_data
        
    def _simulate_update_response(self):
        """Simulate update response for offline/failed requests"""
        simulated = {
            'version': '3.1.0',
            'news': [
                {
                    'title': 'Aegis Wallpaper Engine 3.1 Released!',
                    'content': 'Now featuring MPV rendering, AI preference learning, and smart suggestions.',
                    'date': datetime.now().isoformat()
                }
            ],
            'tips': [
                'Use video wallpapers for a dynamic desktop experience',
                'Enable gaming mode to auto-pause wallpapers during gameplay',
                'The AI learns your preferences over time for better suggestions',
                'Press F11 in the GUI to toggle fullscreen preview'
            ],
            'featured_wallpapers': [
                {'name': 'Aurora Borealis', 'category': 'nature', 'url': ''},
                {'name': 'Cyberpunk City', 'category': 'urban', 'url': ''},
                {'name': 'Galaxy Spiral', 'category': 'space', 'url': ''}
            ]
        }
        
        self._process_update_response(simulated)
        return self.update_data
        
    def _process_update_response(self, data):
        """Process update response data"""
        self.update_data['last_check'] = datetime.now().isoformat()
        self.update_data['news'] = data.get('news', [])
        self.update_data['tips'] = data.get('tips', [])
        self.update_data['featured_wallpapers'] = data.get('featured_wallpapers', [])
        
        new_version = data.get('version', '3.1.0')
        if new_version != self.update_data['last_version']:
            self.update_data['notifications'].append({
                'type': 'update',
                'message': f'New version {new_version} available!',
                'date': datetime.now().isoformat()
            })
            
        self._save_update_data()
        
    def get_random_tip(self):
        """Get a random tip"""
        tips = self.update_data.get('tips', [])
        if tips:
            return random.choice(tips)
        return "Enable AI suggestions for personalized wallpaper recommendations!"
        
    def get_notifications(self, unread_only=True):
        """Get notifications"""
        return self.update_data.get('notifications', [])
        
    def clear_notifications(self):
        """Clear all notifications"""
        self.update_data['notifications'] = []
        self._save_update_data()


class WallpaperPlaylist:
    """Manage wallpaper playlists and slideshows"""
    
    def __init__(self):
        self.items = []
        self.current_index = 0
        self.shuffle = False
        self.interval = 300
        self.transition = 'fade'
        
    def add(self, path, duration=None):
        """Add wallpaper to playlist"""
        self.items.append({
            'path': str(path),
            'duration': duration or self.interval,
            'type': self._detect_type(path)
        })
        
    def _detect_type(self, path):
        """Detect wallpaper type"""
        ext = Path(path).suffix.lower()
        if ext in SUPPORTED_VIDEO_FORMATS:
            return 'video'
        elif ext in SUPPORTED_IMAGE_FORMATS:
            return 'image'
        return 'unknown'
        
    def next(self):
        """Get next wallpaper"""
        if not self.items:
            return None
            
        if self.shuffle:
            self.current_index = random.randint(0, len(self.items) - 1)
        else:
            self.current_index = (self.current_index + 1) % len(self.items)
            
        return self.items[self.current_index]
        
    def previous(self):
        """Get previous wallpaper"""
        if not self.items:
            return None
            
        self.current_index = (self.current_index - 1) % len(self.items)
        return self.items[self.current_index]
        
    def current(self):
        """Get current wallpaper"""
        if not self.items:
            return None
        return self.items[self.current_index]


class GamingModeMonitor:
    """Monitor for gaming mode auto-pause"""
    
    def __init__(self, engine):
        self.engine = engine
        self.running = False
        self.thread = None
        self.gaming_apps = [
            'steam', 'lutris', 'wine', 'proton',
            'gamescope', 'mangohud', 'gamemode'
        ]
        
    def start(self):
        """Start gaming mode monitor"""
        if self.running:
            return
            
        self.running = True
        self.thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.thread.start()
        
    def stop(self):
        """Stop gaming mode monitor"""
        self.running = False
        
    def _monitor_loop(self):
        """Main monitoring loop"""
        while self.running:
            if PSUTIL_AVAILABLE:
                try:
                    gaming_detected = False
                    for proc in psutil.process_iter(['name']):
                        name = proc.info['name'].lower()
                        if any(app in name for app in self.gaming_apps):
                            gaming_detected = True
                            break
                            
                    if gaming_detected and not self.engine.gaming_mode:
                        self.engine.gaming_mode = True
                        self.engine.renderer.stop()
                    elif not gaming_detected and self.engine.gaming_mode:
                        self.engine.gaming_mode = False
                        if self.engine.current_wallpaper:
                            self.engine.set_wallpaper(self.engine.current_wallpaper)
                except:
                    pass
                    
            time.sleep(10)


class AegisWallpaperEngine:
    """Main Aegis Wallpaper Engine - SIGMA Edition v3.1"""
    
    VERSION = "3.1.0"
    
    def __init__(self):
        self.config_dir = Path("/etc/aegis")
        self.user_config_dir = Path.home() / ".config/aegis"
        self.config_file = self.user_config_dir / "wallpaper-config.json"
        self.wallpaper_dir = Path("/usr/share/aegis/wallpapers")
        self.user_wallpaper_dir = Path.home() / ".local/share/aegis/wallpapers"
        
        self.audio = AudioController()
        self.video_processor = VideoProcessor()
        self.renderer = MPVRenderer()
        self.playlist = WallpaperPlaylist()
        self.preference_learner = PreferenceLearner()
        self.update_checker = UpdateChecker()
        
        self.current_wallpaper = None
        self.current_mode = "static"
        self.gaming_mode = False
        self.running = False
        
        self.gaming_monitor = GamingModeMonitor(self)
        
        self.setup_directories()
        self.load_config()
        
        if self.config['performance']['auto_pause_gaming']:
            self.gaming_monitor.start()
            
        if self.update_checker.should_check():
            threading.Thread(target=self.update_checker.check_for_updates, daemon=True).start()
        
    def setup_directories(self):
        """Create necessary directories"""
        for d in [self.user_config_dir, self.user_wallpaper_dir]:
            d.mkdir(parents=True, exist_ok=True)
        try:
            self.config_dir.mkdir(parents=True, exist_ok=True)
            self.wallpaper_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            pass
            
    def load_config(self):
        """Load configuration"""
        default_config = {
            "current_wallpaper": None,
            "mode": "static",
            "renderer": "mpv",
            "video_options": {
                "muted": True,
                "loop": True,
                "volume": 0.5,
                "playback_rate": 1.0,
                "quality": "high"
            },
            "image_options": {
                "effect": "none",
                "transition": 3,
                "slideshow_interval": 300
            },
            "audio": {
                "master_volume": 100,
                "wallpaper_volume": 50,
                "muted": True,
                "ducking": True,
                "ducking_level": 30
            },
            "performance": {
                "auto_pause_gaming": True,
                "gpu_threshold": 70,
                "fps_limit": 30,
                "quality_preset": "high"
            },
            "display": {
                "monitor": "all",
                "resolution": "native",
                "brightness": 0,
                "contrast": 0,
                "saturation": 0
            },
            "ai": {
                "suggestions_enabled": True,
                "learn_preferences": True
            },
            "updates": {
                "auto_check": True,
                "show_notifications": True
            }
        }
        
        try:
            with open(self.config_file, 'r') as f:
                self.config = {**default_config, **json.load(f)}
        except (FileNotFoundError, json.JSONDecodeError):
            self.config = default_config
            self.save_config()
            
    def save_config(self):
        """Save configuration"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
        except:
            pass
                
    def set_wallpaper(self, path, mode=None, options=None):
        """Set wallpaper from any supported format"""
        path = Path(path)
        
        if not path.exists():
            print(f"File not found: {path}")
            return False
            
        ext = path.suffix.lower()
        options = options or {}
        
        merged_options = {
            **self.config.get('video_options', {}),
            **self.config.get('display', {}),
            **options
        }
        
        if ext in SUPPORTED_VIDEO_FORMATS:
            success = self._set_video_wallpaper(str(path), merged_options)
        elif ext in SUPPORTED_IMAGE_FORMATS:
            success = self._set_image_wallpaper(str(path), merged_options)
        else:
            print(f"Unsupported format: {ext}")
            return False
            
        if success:
            self.current_wallpaper = str(path)
            self.config['current_wallpaper'] = str(path)
            self.save_config()
            
            if self.config['ai']['learn_preferences']:
                settings = {
                    'brightness': merged_options.get('brightness', 0),
                    'contrast': merged_options.get('contrast', 0),
                    'saturation': merged_options.get('saturation', 0),
                    'volume': merged_options.get('volume', 50),
                    'effect': merged_options.get('effect', 'none')
                }
                self.preference_learner.record_wallpaper_set(path, settings)
                
        return success
            
    def _set_video_wallpaper(self, video_path, options):
        """Set video as wallpaper using MPV"""
        if options.get('remove_audio', True):
            video_path = self.video_processor.remove_audio(video_path)
            
        if options.get('quality') == 'ultra':
            video_path = self.video_processor.upscale_video(video_path, '4k')
            
        success = self.renderer.start_video(video_path, options)
        
        if success:
            self.current_mode = "video"
            
        return success
        
    def _set_image_wallpaper(self, image_path, options):
        """Set image as wallpaper"""
        success = self.renderer.start_image(image_path, options)
        
        if success:
            self.current_mode = "static"
            
        return success
        
    def set_volume(self, level):
        """Set wallpaper audio volume"""
        self.audio.set_wallpaper_volume(level)
        self.config['audio']['wallpaper_volume'] = level
        self.save_config()
        
    def toggle_mute(self):
        """Toggle audio mute"""
        muted = self.audio.toggle_mute()
        self.config['audio']['muted'] = muted
        self.save_config()
        return muted
        
    def get_suggestions(self, count=5):
        """Get AI-powered wallpaper suggestions"""
        return self.preference_learner.get_suggestions(count)
        
    def get_optimal_settings(self):
        """Get AI-learned optimal settings"""
        return self.preference_learner.get_optimal_settings()
        
    def get_supported_formats(self):
        """Get list of supported formats"""
        return {
            'video': SUPPORTED_VIDEO_FORMATS,
            'image': SUPPORTED_IMAGE_FORMATS,
            'audio': SUPPORTED_AUDIO_FORMATS
        }
        
    def get_status(self):
        """Get current engine status"""
        return {
            'version': self.VERSION,
            'current_wallpaper': self.current_wallpaper,
            'mode': self.current_mode,
            'renderer': 'mpv' if self.renderer.is_available() else 'fallback',
            'ffmpeg': self.video_processor.ffmpeg_available,
            'xwinwrap': self.renderer.xwinwrap_available,
            'gaming_mode': self.gaming_mode,
            'audio': {
                'volume': self.audio.wallpaper_volume,
                'muted': self.audio.muted
            },
            'ai': {
                'suggestions_enabled': self.config['ai']['suggestions_enabled'],
                'total_learned': self.preference_learner.preferences['total_sessions']
            }
        }
        
    def stop(self):
        """Stop wallpaper engine"""
        self.running = False
        self.gaming_monitor.stop()
        self.renderer.stop()


class WallpaperEngineGUI:
    """Modern GUI for Aegis Wallpaper Engine v3.1"""
    
    def __init__(self, engine):
        self.engine = engine
        self.root = tk.Tk()
        self.root.title("Aegis Wallpaper Engine v3.1 - SIGMA Edition")
        self.root.geometry("850x700")
        self.root.configure(bg='#0d1117')
        
        self.setup_styles()
        self.create_widgets()
        
    def setup_styles(self):
        """Setup custom styles"""
        style = ttk.Style()
        style.theme_use('clam')
        
        style.configure('Dark.TFrame', background='#0d1117')
        style.configure('Dark.TLabel', background='#0d1117', foreground='#e6edf3', font=('Segoe UI', 10))
        style.configure('Title.TLabel', background='#0d1117', foreground='#58a6ff', font=('Segoe UI', 16, 'bold'))
        style.configure('Dark.TNotebook', background='#0d1117')
        style.configure('Dark.TNotebook.Tab', background='#21262d', foreground='#e6edf3', padding=[10, 5])
        
    def create_widgets(self):
        """Create main GUI widgets"""
        main_frame = ttk.Frame(self.root, style='Dark.TFrame', padding=20)
        main_frame.pack(fill='both', expand=True)
        
        header_frame = ttk.Frame(main_frame, style='Dark.TFrame')
        header_frame.pack(fill='x', pady=(0, 20))
        
        title = ttk.Label(header_frame, text="AEGIS WALLPAPER ENGINE", style='Title.TLabel')
        title.pack(side='left')
        
        version = ttk.Label(header_frame, text=f"v{self.engine.VERSION} SIGMA", 
                           foreground='#8b949e', background='#0d1117')
        version.pack(side='left', padx=10)
        
        mpv_status = "MPV Ready" if self.engine.renderer.is_available() else "MPV Not Found"
        status_color = '#3fb950' if self.engine.renderer.is_available() else '#f85149'
        status = ttk.Label(header_frame, text=f"Renderer: {mpv_status}", 
                          foreground=status_color, background='#0d1117')
        status.pack(side='right')
        
        notebook = ttk.Notebook(main_frame)
        notebook.pack(fill='both', expand=True)
        
        self.create_wallpaper_tab(notebook)
        self.create_audio_tab(notebook)
        self.create_video_tab(notebook)
        self.create_ai_tab(notebook)
        self.create_settings_tab(notebook)
        
    def create_wallpaper_tab(self, notebook):
        """Create wallpaper selection tab"""
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Wallpaper")
        
        preview_frame = tk.Frame(frame, bg='#161b22', width=400, height=225)
        preview_frame.pack(pady=10)
        preview_frame.pack_propagate(False)
        
        self.preview_label = tk.Label(preview_frame, text="No wallpaper selected", 
                                      bg='#161b22', fg='#8b949e')
        self.preview_label.pack(expand=True)
        
        btn_frame = ttk.Frame(frame, style='Dark.TFrame')
        btn_frame.pack(fill='x', pady=10)
        
        select_btn = tk.Button(btn_frame, text="Select File", bg='#238636', fg='white',
                              font=('Segoe UI', 10, 'bold'), border=0, padx=20, pady=8,
                              command=self.select_wallpaper)
        select_btn.pack(side='left', padx=5)
        
        apply_btn = tk.Button(btn_frame, text="Apply", bg='#1f6feb', fg='white',
                             font=('Segoe UI', 10, 'bold'), border=0, padx=20, pady=8,
                             command=self.apply_wallpaper)
        apply_btn.pack(side='left', padx=5)
        
        stop_btn = tk.Button(btn_frame, text="Stop", bg='#da3633', fg='white',
                            font=('Segoe UI', 10, 'bold'), border=0, padx=20, pady=8,
                            command=self.stop_wallpaper)
        stop_btn.pack(side='left', padx=5)
        
        formats_label = ttk.Label(frame, text="Supported: MP4, AVI, MKV, WebM, MOV, GIF, JPG, PNG, HEVC, VP9, AV1",
                                 foreground='#8b949e', background='#0d1117', font=('Segoe UI', 9))
        formats_label.pack(pady=5)
        
        current_frame = ttk.Frame(frame, style='Dark.TFrame')
        current_frame.pack(fill='x', pady=10)
        
        current_label = ttk.Label(current_frame, text="Current:", style='Dark.TLabel')
        current_label.pack(side='left')
        
        self.current_path = ttk.Label(current_frame, text="None", foreground='#58a6ff', background='#0d1117')
        self.current_path.pack(side='left', padx=5)
        
        tip_frame = tk.Frame(frame, bg='#161b22', padx=10, pady=8)
        tip_frame.pack(fill='x', pady=10)
        
        tip_icon = tk.Label(tip_frame, text="ðŸ’¡", bg='#161b22', font=('Segoe UI', 12))
        tip_icon.pack(side='left')
        
        tip_text = self.engine.update_checker.get_random_tip()
        tip_label = tk.Label(tip_frame, text=tip_text, bg='#161b22', fg='#8b949e', 
                            font=('Segoe UI', 9), wraplength=500, justify='left')
        tip_label.pack(side='left', padx=10)
        
        self.selected_path = None
        
    def create_audio_tab(self, notebook):
        """Create audio control tab"""
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Audio Control")
        
        vol_frame = tk.Frame(frame, bg='#0d1117')
        vol_frame.pack(fill='x', pady=10)
        
        vol_label = tk.Label(vol_frame, text="Wallpaper Volume", bg='#0d1117', fg='#e6edf3',
                            font=('Segoe UI', 11, 'bold'))
        vol_label.pack(anchor='w')
        
        self.volume_var = tk.IntVar(value=self.engine.audio.wallpaper_volume)
        volume_scale = tk.Scale(vol_frame, from_=0, to=100, orient='horizontal',
                               variable=self.volume_var, bg='#161b22', fg='#e6edf3',
                               highlightthickness=0, troughcolor='#21262d',
                               activebackground='#58a6ff', length=400,
                               command=self.on_volume_change)
        volume_scale.pack(fill='x', pady=5)
        
        self.mute_var = tk.BooleanVar(value=self.engine.audio.muted)
        mute_check = tk.Checkbutton(frame, text="Mute Audio", variable=self.mute_var,
                                   bg='#0d1117', fg='#e6edf3', selectcolor='#21262d',
                                   activebackground='#0d1117', activeforeground='#e6edf3',
                                   command=self.on_mute_toggle)
        mute_check.pack(anchor='w', pady=5)
        
        remove_frame = tk.Frame(frame, bg='#0d1117')
        remove_frame.pack(fill='x', pady=15)
        
        remove_label = tk.Label(remove_frame, text="Audio Removal", bg='#0d1117', fg='#e6edf3',
                               font=('Segoe UI', 11, 'bold'))
        remove_label.pack(anchor='w')
        
        self.remove_audio_var = tk.BooleanVar(value=True)
        remove_check = tk.Checkbutton(remove_frame, text="Remove audio from video wallpapers",
                                     variable=self.remove_audio_var, bg='#0d1117', fg='#e6edf3',
                                     selectcolor='#21262d')
        remove_check.pack(anchor='w', pady=5)
        
        ducking_frame = tk.Frame(frame, bg='#0d1117')
        ducking_frame.pack(fill='x', pady=15)
        
        duck_label = tk.Label(ducking_frame, text="Audio Ducking", bg='#0d1117', fg='#e6edf3',
                             font=('Segoe UI', 11, 'bold'))
        duck_label.pack(anchor='w')
        
        duck_desc = tk.Label(ducking_frame, text="Automatically lower wallpaper volume when other apps play audio",
                            bg='#0d1117', fg='#8b949e', font=('Segoe UI', 9))
        duck_desc.pack(anchor='w')
        
        self.ducking_var = tk.BooleanVar(value=self.engine.audio.audio_ducking)
        duck_check = tk.Checkbutton(ducking_frame, text="Enable audio ducking",
                                   variable=self.ducking_var, bg='#0d1117', fg='#e6edf3',
                                   selectcolor='#21262d')
        duck_check.pack(anchor='w', pady=5)
        
    def create_video_tab(self, notebook):
        """Create video settings tab"""
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Video Settings")
        
        quality_frame = tk.Frame(frame, bg='#0d1117')
        quality_frame.pack(fill='x', pady=10)
        
        qual_label = tk.Label(quality_frame, text="Quality Preset", bg='#0d1117', fg='#e6edf3',
                             font=('Segoe UI', 11, 'bold'))
        qual_label.pack(anchor='w')
        
        self.quality_var = tk.StringVar(value='high')
        for q, desc in [('ultra', '8K/4K Upscaling'), ('high', 'Native Resolution'), 
                       ('medium', 'Balanced'), ('low', 'Performance')]:
            rb = tk.Radiobutton(quality_frame, text=f"{q.title()} - {desc}",
                               variable=self.quality_var, value=q,
                               bg='#0d1117', fg='#e6edf3', selectcolor='#21262d',
                               activebackground='#0d1117')
            rb.pack(anchor='w', pady=2)
            
        loop_frame = tk.Frame(frame, bg='#0d1117')
        loop_frame.pack(fill='x', pady=15)
        
        self.loop_var = tk.BooleanVar(value=True)
        loop_check = tk.Checkbutton(loop_frame, text="Loop video", variable=self.loop_var,
                                   bg='#0d1117', fg='#e6edf3', selectcolor='#21262d')
        loop_check.pack(anchor='w')
        
        effects_frame = tk.Frame(frame, bg='#0d1117')
        effects_frame.pack(fill='x', pady=15)
        
        effect_label = tk.Label(effects_frame, text="Image Effects", bg='#0d1117', fg='#e6edf3',
                               font=('Segoe UI', 11, 'bold'))
        effect_label.pack(anchor='w')
        
        self.effect_var = tk.StringVar(value='none')
        effects = [
            ('none', 'None - Static image'),
            ('ken-burns', 'Ken Burns - Slow zoom and pan'),
            ('parallax', 'Parallax - Gentle movement'),
            ('pulse', 'Pulse - Subtle breathing effect')
        ]
        
        for value, desc in effects:
            rb = tk.Radiobutton(effects_frame, text=desc, variable=self.effect_var, value=value,
                               bg='#0d1117', fg='#e6edf3', selectcolor='#21262d',
                               activebackground='#0d1117')
            rb.pack(anchor='w', pady=2)
        
        status_frame = tk.Frame(frame, bg='#0d1117')
        status_frame.pack(fill='x', pady=15)
        
        mpv_status = "Available" if self.engine.renderer.mpv_available else "Not Found"
        mpv_color = '#3fb950' if self.engine.renderer.mpv_available else '#f85149'
        mpv_label = tk.Label(status_frame, text=f"MPV: {mpv_status}", bg='#0d1117', fg=mpv_color)
        mpv_label.pack(anchor='w')
        
        xwinwrap_status = "Available" if self.engine.renderer.xwinwrap_available else "Not Found"
        xwinwrap_color = '#3fb950' if self.engine.renderer.xwinwrap_available else '#f85149'
        xwinwrap_label = tk.Label(status_frame, text=f"xwinwrap: {xwinwrap_status}", bg='#0d1117', fg=xwinwrap_color)
        xwinwrap_label.pack(anchor='w')
        
        ffmpeg_status = "Available" if self.engine.video_processor.ffmpeg_available else "Not Found"
        ffmpeg_color = '#3fb950' if self.engine.video_processor.ffmpeg_available else '#f85149'
        ffmpeg_label = tk.Label(status_frame, text=f"FFmpeg: {ffmpeg_status}", bg='#0d1117', fg=ffmpeg_color)
        ffmpeg_label.pack(anchor='w')
        
    def create_ai_tab(self, notebook):
        """Create AI suggestions tab"""
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="AI Suggestions")
        
        header = tk.Label(frame, text="AI Preference Learning", bg='#0d1117', fg='#e6edf3',
                         font=('Segoe UI', 11, 'bold'))
        header.pack(anchor='w', pady=(0, 10))
        
        desc = tk.Label(frame, text="The AI learns your wallpaper preferences and suggests similar ones based on\ntime of day, categories, and your usage patterns.",
                       bg='#0d1117', fg='#8b949e', font=('Segoe UI', 9), justify='left')
        desc.pack(anchor='w', pady=(0, 15))
        
        self.ai_enabled_var = tk.BooleanVar(value=self.engine.config['ai']['suggestions_enabled'])
        ai_check = tk.Checkbutton(frame, text="Enable AI suggestions", variable=self.ai_enabled_var,
                                 bg='#0d1117', fg='#e6edf3', selectcolor='#21262d')
        ai_check.pack(anchor='w', pady=5)
        
        self.learn_var = tk.BooleanVar(value=self.engine.config['ai']['learn_preferences'])
        learn_check = tk.Checkbutton(frame, text="Learn from my preferences", variable=self.learn_var,
                                    bg='#0d1117', fg='#e6edf3', selectcolor='#21262d')
        learn_check.pack(anchor='w', pady=5)
        
        stats_frame = tk.LabelFrame(frame, text="Usage Statistics", bg='#161b22', fg='#e6edf3',
                                   font=('Segoe UI', 10, 'bold'))
        stats_frame.pack(fill='x', pady=15)
        
        stats = self.engine.preference_learner.get_stats()
        
        stats_text = f"Total wallpapers set: {stats['total_wallpapers_set']}\n"
        stats_text += f"Sessions: {stats['total_sessions']}\n"
        if stats['favorite_categories']:
            top_cats = list(stats['favorite_categories'].keys())[:3]
            stats_text += f"Favorite categories: {', '.join(top_cats)}"
            
        stats_label = tk.Label(stats_frame, text=stats_text, bg='#161b22', fg='#8b949e',
                              font=('Segoe UI', 9), justify='left')
        stats_label.pack(anchor='w', padx=10, pady=10)
        
        suggest_frame = tk.LabelFrame(frame, text="Suggestions For You", bg='#161b22', fg='#e6edf3',
                                     font=('Segoe UI', 10, 'bold'))
        suggest_frame.pack(fill='both', expand=True, pady=10)
        
        suggestions = self.engine.get_suggestions(5)
        
        if suggestions:
            for i, path in enumerate(suggestions):
                suggestion_btn = tk.Button(suggest_frame, text=f"ðŸ“ {Path(path).name}",
                                          bg='#21262d', fg='#e6edf3', anchor='w',
                                          border=0, padx=10, pady=5,
                                          command=lambda p=path: self.apply_suggestion(p))
                suggestion_btn.pack(fill='x', padx=5, pady=2)
        else:
            no_suggest = tk.Label(suggest_frame, text="Set more wallpapers to get personalized suggestions!",
                                 bg='#161b22', fg='#8b949e', font=('Segoe UI', 9))
            no_suggest.pack(anchor='w', padx=10, pady=10)
            
        refresh_btn = tk.Button(frame, text="Refresh Suggestions", bg='#21262d', fg='#e6edf3',
                               font=('Segoe UI', 9), border=0, padx=15, pady=5,
                               command=lambda: self.refresh_suggestions(suggest_frame))
        refresh_btn.pack(anchor='w', pady=10)
        
    def create_settings_tab(self, notebook):
        """Create settings tab"""
        frame = ttk.Frame(notebook, style='Dark.TFrame', padding=15)
        notebook.add(frame, text="Settings")
        
        perf_label = tk.Label(frame, text="Performance", bg='#0d1117', fg='#e6edf3',
                             font=('Segoe UI', 11, 'bold'))
        perf_label.pack(anchor='w')
        
        self.gaming_var = tk.BooleanVar(value=self.engine.config['performance']['auto_pause_gaming'])
        gaming_check = tk.Checkbutton(frame, text="Auto-pause during gaming (detect Steam/Lutris/Wine)",
                                     variable=self.gaming_var, bg='#0d1117', fg='#e6edf3',
                                     selectcolor='#21262d')
        gaming_check.pack(anchor='w', pady=3)
        
        fps_frame = tk.Frame(frame, bg='#0d1117')
        fps_frame.pack(fill='x', pady=10)
        
        tk.Label(fps_frame, text="FPS Limit", bg='#0d1117', fg='#e6edf3').pack(side='left')
        self.fps_var = tk.IntVar(value=30)
        fps_combo = ttk.Combobox(fps_frame, textvariable=self.fps_var, values=[15, 24, 30, 60],
                                width=10, state='readonly')
        fps_combo.pack(side='left', padx=10)
        
        update_label = tk.Label(frame, text="Updates", bg='#0d1117', fg='#e6edf3',
                               font=('Segoe UI', 11, 'bold'))
        update_label.pack(anchor='w', pady=(15, 5))
        
        self.auto_update_var = tk.BooleanVar(value=self.engine.config['updates']['auto_check'])
        update_check = tk.Checkbutton(frame, text="Automatically check for updates weekly",
                                     variable=self.auto_update_var, bg='#0d1117', fg='#e6edf3',
                                     selectcolor='#21262d')
        update_check.pack(anchor='w', pady=3)
        
        check_now_btn = tk.Button(frame, text="Check Now", bg='#21262d', fg='#e6edf3',
                                 font=('Segoe UI', 9), border=0, padx=15, pady=5,
                                 command=self.check_updates)
        check_now_btn.pack(anchor='w', pady=5)
        
        last_check = self.engine.update_checker.update_data.get('last_check', 'Never')
        if last_check and last_check != 'Never':
            try:
                last_dt = datetime.fromisoformat(last_check)
                last_check = last_dt.strftime('%Y-%m-%d %H:%M')
            except:
                pass
                
        last_check_label = tk.Label(frame, text=f"Last checked: {last_check}", 
                                   bg='#0d1117', fg='#8b949e', font=('Segoe UI', 9))
        last_check_label.pack(anchor='w')
        
        save_btn = tk.Button(frame, text="Save Settings", bg='#238636', fg='white',
                            font=('Segoe UI', 10, 'bold'), border=0, padx=20, pady=8,
                            command=self.save_settings)
        save_btn.pack(anchor='w', pady=20)
        
    def select_wallpaper(self):
        """Open file dialog to select wallpaper"""
        filetypes = [
            ("All Supported", "*.mp4 *.avi *.mkv *.webm *.mov *.wmv *.gif *.jpg *.jpeg *.png *.webp *.bmp"),
            ("Video Files", "*.mp4 *.avi *.mkv *.webm *.mov *.wmv *.flv *.m4v"),
            ("Image Files", "*.jpg *.jpeg *.png *.gif *.bmp *.webp *.tiff"),
            ("All Files", "*.*")
        ]
        
        path = filedialog.askopenfilename(title="Select Wallpaper", filetypes=filetypes)
        
        if path:
            self.selected_path = path
            self.current_path.config(text=os.path.basename(path))
            self.update_preview(path)
            
    def update_preview(self, path):
        """Update preview image"""
        if PIL_AVAILABLE:
            try:
                ext = Path(path).suffix.lower()
                
                if ext in SUPPORTED_VIDEO_FORMATS:
                    thumb = self.engine.video_processor.generate_thumbnail(path)
                    if thumb:
                        path = thumb
                    else:
                        self.preview_label.config(text="Video: " + os.path.basename(path))
                        return
                        
                img = Image.open(path)
                img.thumbnail((400, 225), Image.Resampling.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                self.preview_label.config(image=photo, text='')
                self.preview_label.image = photo
            except:
                self.preview_label.config(text=f"Preview unavailable\n{os.path.basename(path)}")
        else:
            self.preview_label.config(text=os.path.basename(path))
            
    def apply_wallpaper(self):
        """Apply selected wallpaper"""
        if not self.selected_path:
            messagebox.showwarning("No Selection", "Please select a wallpaper first.")
            return
            
        options = {
            'muted': self.mute_var.get(),
            'remove_audio': self.remove_audio_var.get(),
            'volume': self.volume_var.get(),
            'quality': self.quality_var.get(),
            'loop': self.loop_var.get(),
            'effect': self.effect_var.get()
        }
        
        success = self.engine.set_wallpaper(self.selected_path, options=options)
        
        if success:
            messagebox.showinfo("Success", "Wallpaper applied successfully!")
        else:
            messagebox.showerror("Error", "Failed to apply wallpaper.")
            
    def apply_suggestion(self, path):
        """Apply a suggested wallpaper"""
        self.selected_path = path
        self.current_path.config(text=os.path.basename(path))
        self.update_preview(path)
        self.apply_wallpaper()
        
    def refresh_suggestions(self, suggest_frame):
        """Refresh suggestions list"""
        for widget in suggest_frame.winfo_children():
            widget.destroy()
            
        suggestions = self.engine.get_suggestions(5)
        
        if suggestions:
            for path in suggestions:
                suggestion_btn = tk.Button(suggest_frame, text=f"ðŸ“ {Path(path).name}",
                                          bg='#21262d', fg='#e6edf3', anchor='w',
                                          border=0, padx=10, pady=5,
                                          command=lambda p=path: self.apply_suggestion(p))
                suggestion_btn.pack(fill='x', padx=5, pady=2)
        else:
            no_suggest = tk.Label(suggest_frame, text="Set more wallpapers to get personalized suggestions!",
                                 bg='#161b22', fg='#8b949e', font=('Segoe UI', 9))
            no_suggest.pack(anchor='w', padx=10, pady=10)
            
    def stop_wallpaper(self):
        """Stop current wallpaper"""
        self.engine.stop()
        messagebox.showinfo("Stopped", "Wallpaper engine stopped.")
        
    def on_volume_change(self, value):
        """Handle volume slider change"""
        self.engine.set_volume(int(float(value)))
        
    def on_mute_toggle(self):
        """Handle mute checkbox toggle"""
        self.engine.audio.muted = self.mute_var.get()
        
    def check_updates(self):
        """Manually check for updates"""
        self.engine.update_checker.check_for_updates(force=True)
        messagebox.showinfo("Updates", "Update check complete!")
        
    def save_settings(self):
        """Save all settings"""
        self.engine.config['performance']['auto_pause_gaming'] = self.gaming_var.get()
        self.engine.config['performance']['fps_limit'] = self.fps_var.get()
        self.engine.config['audio']['muted'] = self.mute_var.get()
        self.engine.config['audio']['ducking'] = self.ducking_var.get()
        self.engine.config['video_options']['quality'] = self.quality_var.get()
        self.engine.config['ai']['suggestions_enabled'] = self.ai_enabled_var.get()
        self.engine.config['ai']['learn_preferences'] = self.learn_var.get()
        self.engine.config['updates']['auto_check'] = self.auto_update_var.get()
        self.engine.save_config()
        messagebox.showinfo("Saved", "Settings saved successfully!")
        
    def run(self):
        """Start GUI main loop"""
        self.root.mainloop()


def print_cli_help():
    """Print CLI help"""
    print("""
Aegis Wallpaper Engine v3.1 - SIGMA Edition
============================================

Usage: aegis-wallpaper-engine [OPTIONS] [WALLPAPER_PATH]

Options:
  --gui                 Launch graphical interface
  --set PATH            Set wallpaper from file
  --mute                Mute audio
  --unmute              Unmute audio
  --volume LEVEL        Set volume (0-100)
  --quality PRESET      Set quality (ultra/high/medium/low)
  --remove-audio        Remove audio from video
  --effect EFFECT       Set effect (none/ken-burns/parallax/pulse)
  --stop                Stop wallpaper engine
  --status              Show current status
  --formats             List supported formats
  --suggest             Get AI wallpaper suggestions
  --check-updates       Check for updates
  --help                Show this help

Examples:
  aegis-wallpaper-engine --gui
  aegis-wallpaper-engine --set /path/to/video.mp4 --mute
  aegis-wallpaper-engine --set /path/to/image.jpg --effect ken-burns
  aegis-wallpaper-engine --volume 50
  aegis-wallpaper-engine --suggest
  aegis-wallpaper-engine --stop
""")


def main():
    """Main entry point"""
    engine = AegisWallpaperEngine()
    
    if len(sys.argv) < 2 or '--gui' in sys.argv:
        if TK_AVAILABLE:
            gui = WallpaperEngineGUI(engine)
            gui.run()
        else:
            print("GUI not available. Install tkinter to use graphical interface.")
            print("Run with --help for CLI options.")
            return
            
    args = sys.argv[1:]
    
    if '--help' in args or '-h' in args:
        print_cli_help()
        return
        
    if '--status' in args:
        status = engine.get_status()
        print(f"Aegis Wallpaper Engine v{status['version']}")
        print(f"  Renderer: {status['renderer']}")
        print(f"  MPV: {'Available' if status['renderer'] == 'mpv' else 'Not found'}")
        print(f"  xwinwrap: {'Available' if status.get('xwinwrap') else 'Not found'}")
        print(f"  FFmpeg: {'Available' if status['ffmpeg'] else 'Not found'}")
        print(f"  Current: {status['current_wallpaper'] or 'None'}")
        print(f"  Mode: {status['mode']}")
        print(f"  Gaming Mode: {'Active' if status['gaming_mode'] else 'Inactive'}")
        print(f"  Volume: {status['audio']['volume']}%")
        print(f"  Muted: {status['audio']['muted']}")
        print(f"  AI Sessions: {status['ai']['total_learned']}")
        return
        
    if '--formats' in args:
        formats = engine.get_supported_formats()
        print("Supported Formats:")
        print(f"  Video: {', '.join(formats['video'])}")
        print(f"  Image: {', '.join(formats['image'])}")
        print(f"  Audio: {', '.join(formats['audio'])}")
        return
        
    if '--suggest' in args:
        suggestions = engine.get_suggestions(5)
        print("AI Wallpaper Suggestions:")
        if suggestions:
            for i, path in enumerate(suggestions, 1):
                print(f"  {i}. {path}")
        else:
            print("  No suggestions yet. Set more wallpapers to train the AI!")
        return
        
    if '--check-updates' in args:
        print("Checking for updates...")
        data = engine.update_checker.check_for_updates(force=True)
        print(f"Last check: {data.get('last_check', 'Never')}")
        if data.get('news'):
            print("News:")
            for item in data['news'][:3]:
                print(f"  - {item.get('title', 'Update')}")
        if data.get('tips'):
            print(f"Tip: {data['tips'][0]}")
        return
        
    if '--stop' in args:
        engine.stop()
        print("Wallpaper engine stopped.")
        return
        
    if '--set' in args:
        idx = args.index('--set')
        if idx + 1 < len(args):
            path = args[idx + 1]
            options = {
                'muted': '--mute' in args,
                'remove_audio': '--remove-audio' in args,
                'loop': '--no-loop' not in args
            }
            
            if '--volume' in args:
                vol_idx = args.index('--volume')
                if vol_idx + 1 < len(args):
                    options['volume'] = int(args[vol_idx + 1])
                    
            if '--quality' in args:
                q_idx = args.index('--quality')
                if q_idx + 1 < len(args):
                    options['quality'] = args[q_idx + 1]
                    
            if '--effect' in args:
                e_idx = args.index('--effect')
                if e_idx + 1 < len(args):
                    options['effect'] = args[e_idx + 1]
                    
            if engine.set_wallpaper(path, options=options):
                print(f"Wallpaper set: {path}")
            else:
                print("Failed to set wallpaper.")
        return
        
    if '--volume' in args:
        idx = args.index('--volume')
        if idx + 1 < len(args):
            engine.set_volume(int(args[idx + 1]))
            print(f"Volume set to {args[idx + 1]}%")
        return
        
    if '--mute' in args:
        engine.audio.muted = True
        engine.save_config()
        print("Audio muted.")
        return
        
    if '--unmute' in args:
        engine.audio.muted = False
        engine.save_config()
        print("Audio unmuted.")
        return
        
    if len(args) > 0 and not args[0].startswith('--'):
        if engine.set_wallpaper(args[0]):
            print(f"Wallpaper set: {args[0]}")
        else:
            print("Failed to set wallpaper.")
        return
        
    print_cli_help()


if __name__ == "__main__":
    main()
