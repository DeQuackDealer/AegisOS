#!/usr/bin/env python3
"""
Aegis Data Science - Data science environment setup and management
Features: Environment setup, package management, dataset management

Provides GUI (GTK) and CLI modes with tier-based feature gating.
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import shutil
from pathlib import Path
from typing import Dict, List, Any

TIER_LIMIT = "aidev"
VERSION = "1.5.0"
APP_NAME = "Aegis Data Science"

CONFIG_FILE = "/etc/aegis/aidev-config.json"
LOG_FILE = "/var/log/aegis/data-science.log"

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk
    GTK_AVAILABLE = True
except ImportError:
    GTK_AVAILABLE = False


class LicenseTier:
    FREEMIUM = 1
    AIDEV = 4


DS_PACKAGES = {
    "core": ["numpy", "pandas", "scipy", "matplotlib", "seaborn", "jupyter"],
    "ml": ["scikit-learn", "xgboost", "lightgbm", "catboost"],
    "deep_learning": ["torch", "tensorflow", "keras"],
    "nlp": ["transformers", "spacy", "nltk", "gensim"],
    "vision": ["opencv-python", "pillow", "albumentations"],
    "data": ["sqlalchemy", "pyarrow", "dask", "polars"]
}


COMMON_DS_PACKAGES = ["numpy", "pandas", "scikit-learn", "scipy", "matplotlib", "seaborn", "jupyter", "jupyterlab"]


class AegisDataScience:
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = VERSION
        self.license_tier = LicenseTier.FREEMIUM
        self.jupyter_process = None
        
        self.setup_logging()
        self.load_license_tier()
        
    def setup_logging(self):
        log_dir = Path(LOG_FILE).parent
        try:
            log_dir.mkdir(parents=True, exist_ok=True)
            logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[logging.FileHandler(LOG_FILE), logging.StreamHandler() if not self.headless else logging.NullHandler()])
        except Exception:
            logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger("AegisDataScience")
    
    def load_license_tier(self):
        if Path("/etc/aegis-aidev-marker").exists():
            self.license_tier = LicenseTier.AIDEV
    
    def check_pip(self) -> bool:
        return shutil.which("pip") is not None or shutil.which("pip3") is not None
    
    def check_conda(self) -> bool:
        return shutil.which("conda") is not None
    
    def check_mamba(self) -> bool:
        return shutil.which("mamba") is not None
    
    def _check_jupyter(self) -> Dict[str, Any]:
        """Verifies Jupyter is installed and can start"""
        result = {
            "installed": False,
            "jupyter_version": None,
            "jupyterlab_version": None,
            "can_start": False,
            "jupyter_path": None,
            "jupyterlab_path": None
        }
        
        try:
            jupyter_path = shutil.which("jupyter")
            if jupyter_path:
                result["jupyter_path"] = jupyter_path
                result["installed"] = True
                
                version_result = subprocess.run(
                    ["jupyter", "--version"],
                    capture_output=True, text=True, timeout=30
                )
                if version_result.returncode == 0:
                    for line in version_result.stdout.strip().split('\n'):
                        if 'jupyter_core' in line.lower() or 'jupyter-core' in line.lower():
                            parts = line.split(':')
                            if len(parts) >= 2:
                                result["jupyter_version"] = parts[1].strip()
                        elif 'jupyterlab' in line.lower():
                            parts = line.split(':')
                            if len(parts) >= 2:
                                result["jupyterlab_version"] = parts[1].strip()
                
                check_result = subprocess.run(
                    ["jupyter", "notebook", "--version"],
                    capture_output=True, text=True, timeout=30
                )
                result["can_start"] = check_result.returncode == 0
            
            jupyterlab_path = shutil.which("jupyter-lab")
            if jupyterlab_path:
                result["jupyterlab_path"] = jupyterlab_path
                if not result["jupyterlab_version"]:
                    lab_result = subprocess.run(
                        ["jupyter-lab", "--version"],
                        capture_output=True, text=True, timeout=30
                    )
                    if lab_result.returncode == 0:
                        result["jupyterlab_version"] = lab_result.stdout.strip()
            
            self.logger.info(f"Jupyter check: installed={result['installed']}, can_start={result['can_start']}")
            
        except subprocess.TimeoutExpired:
            self.logger.warning("Jupyter check timed out")
            result["error"] = "Timeout checking Jupyter installation"
        except Exception as e:
            self.logger.error(f"Error checking Jupyter: {e}")
            result["error"] = str(e)
        
        return result
    
    def _start_jupyter_lab(self, port: int = 8888, notebook_dir: str = None, 
                           no_browser: bool = True, allow_root: bool = False) -> Dict[str, Any]:
        """Launches JupyterLab with proper configuration"""
        if self.license_tier < LicenseTier.AIDEV:
            return {"success": False, "error": "Requires AI Developer edition"}
        
        jupyter_check = self._check_jupyter()
        if not jupyter_check.get("jupyterlab_path"):
            return {"success": False, "error": "JupyterLab is not installed"}
        
        try:
            cmd = ["jupyter-lab", f"--port={port}"]
            
            if notebook_dir:
                notebook_path = Path(notebook_dir)
                if notebook_path.exists():
                    cmd.append(f"--notebook-dir={notebook_dir}")
                else:
                    return {"success": False, "error": f"Notebook directory does not exist: {notebook_dir}"}
            
            if no_browser:
                cmd.append("--no-browser")
            
            if allow_root:
                cmd.append("--allow-root")
            
            cmd.extend([
                "--ip=0.0.0.0",
                "--NotebookApp.token=''",
                "--NotebookApp.password=''"
            ])
            
            self.logger.info(f"Starting JupyterLab with command: {' '.join(cmd)}")
            
            self.jupyter_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                start_new_session=True
            )
            
            import time
            time.sleep(2)
            
            if self.jupyter_process.poll() is None:
                return {
                    "success": True,
                    "pid": self.jupyter_process.pid,
                    "port": port,
                    "url": f"http://localhost:{port}/lab"
                }
            else:
                stderr = self.jupyter_process.stderr.read().decode() if self.jupyter_process.stderr else ""
                return {"success": False, "error": f"JupyterLab failed to start: {stderr}"}
                
        except Exception as e:
            self.logger.error(f"Error starting JupyterLab: {e}")
            return {"success": False, "error": str(e)}
    
    def _list_environments(self) -> Dict[str, Any]:
        """Lists conda/mamba environments"""
        result = {
            "success": False,
            "environments": [],
            "manager": None
        }
        
        try:
            if self.check_mamba():
                manager = "mamba"
                cmd = ["mamba", "env", "list", "--json"]
            elif self.check_conda():
                manager = "conda"
                cmd = ["conda", "env", "list", "--json"]
            else:
                return {"success": False, "error": "Neither conda nor mamba is installed"}
            
            result["manager"] = manager
            
            env_result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if env_result.returncode == 0:
                env_data = json.loads(env_result.stdout)
                envs = []
                
                for env_path in env_data.get("envs", []):
                    env_name = os.path.basename(env_path) if env_path else "base"
                    if not env_name or env_path.endswith("anaconda3") or env_path.endswith("miniconda3"):
                        env_name = "base"
                    
                    envs.append({
                        "name": env_name,
                        "path": env_path,
                        "is_active": os.environ.get("CONDA_PREFIX") == env_path
                    })
                
                result["environments"] = envs
                result["success"] = True
                self.logger.info(f"Found {len(envs)} {manager} environments")
            else:
                result["error"] = env_result.stderr
                
        except json.JSONDecodeError as e:
            result["error"] = f"Failed to parse environment list: {e}"
        except subprocess.TimeoutExpired:
            result["error"] = "Timeout listing environments"
        except Exception as e:
            self.logger.error(f"Error listing environments: {e}")
            result["error"] = str(e)
        
        return result
    
    def _create_environment(self, env_name: str, python_version: str = "3.11",
                            packages: List[str] = None) -> Dict[str, Any]:
        """Creates new conda environment with data science packages"""
        if self.license_tier < LicenseTier.AIDEV:
            return {"success": False, "error": "Requires AI Developer edition"}
        
        if not env_name or not env_name.replace("_", "").replace("-", "").isalnum():
            return {"success": False, "error": "Invalid environment name"}
        
        try:
            if self.check_mamba():
                manager = "mamba"
            elif self.check_conda():
                manager = "conda"
            else:
                return {"success": False, "error": "Neither conda nor mamba is installed"}
            
            cmd = [manager, "create", "-n", env_name, f"python={python_version}", "-y"]
            
            if packages:
                cmd.extend(packages)
            
            self.logger.info(f"Creating environment '{env_name}' with {manager}")
            
            create_result = subprocess.run(
                cmd, capture_output=True, text=True, timeout=600
            )
            
            if create_result.returncode == 0:
                result = {
                    "success": True,
                    "environment": env_name,
                    "python_version": python_version,
                    "manager": manager,
                    "packages_installed": packages or []
                }
                
                if packages:
                    install_result = subprocess.run(
                        [manager, "install", "-n", env_name, "-y"] + packages,
                        capture_output=True, text=True, timeout=600
                    )
                    result["packages_success"] = install_result.returncode == 0
                
                self.logger.info(f"Environment '{env_name}' created successfully")
                return result
            else:
                return {
                    "success": False,
                    "error": create_result.stderr,
                    "output": create_result.stdout
                }
                
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Timeout creating environment"}
        except Exception as e:
            self.logger.error(f"Error creating environment: {e}")
            return {"success": False, "error": str(e)}
    
    def _install_packages(self, packages: List[str], use_conda: bool = False,
                          env_name: str = None) -> Dict[str, Any]:
        """Installs Python packages via pip/conda"""
        if self.license_tier < LicenseTier.AIDEV:
            return {"success": False, "error": "Requires AI Developer edition"}
        
        if not packages:
            return {"success": False, "error": "No packages specified"}
        
        try:
            if use_conda:
                if self.check_mamba():
                    manager = "mamba"
                elif self.check_conda():
                    manager = "conda"
                else:
                    return {"success": False, "error": "Conda/mamba not available, falling back to pip"}
                
                cmd = [manager, "install", "-y"]
                if env_name:
                    cmd.extend(["-n", env_name])
                cmd.extend(packages)
            else:
                pip_cmd = shutil.which("pip3") or shutil.which("pip")
                if not pip_cmd:
                    return {"success": False, "error": "pip is not available"}
                
                cmd = [pip_cmd, "install", "--upgrade"]
                cmd.extend(packages)
            
            self.logger.info(f"Installing packages: {', '.join(packages)}")
            
            result = subprocess.run(
                cmd, capture_output=True, text=True, timeout=600
            )
            
            if result.returncode == 0:
                return {
                    "success": True,
                    "packages": packages,
                    "method": "conda" if use_conda else "pip",
                    "output": result.stdout
                }
            else:
                return {
                    "success": False,
                    "error": result.stderr,
                    "packages": packages
                }
                
        except subprocess.TimeoutExpired:
            return {"success": False, "error": "Timeout installing packages"}
        except Exception as e:
            self.logger.error(f"Error installing packages: {e}")
            return {"success": False, "error": str(e)}
    
    def _detect_python_packages(self, packages: List[str] = None) -> Dict[str, Any]:
        """Checks for common DS packages (pandas, numpy, sklearn, etc.)"""
        if packages is None:
            packages = COMMON_DS_PACKAGES
        
        result = {
            "detected": {},
            "missing": [],
            "available": []
        }
        
        try:
            pip_cmd = shutil.which("pip3") or shutil.which("pip")
            if not pip_cmd:
                return {"success": False, "error": "pip is not available"}
            
            list_result = subprocess.run(
                [pip_cmd, "list", "--format=json"],
                capture_output=True, text=True, timeout=30
            )
            
            installed_packages = {}
            if list_result.returncode == 0:
                try:
                    pkg_list = json.loads(list_result.stdout)
                    installed_packages = {pkg["name"].lower(): pkg["version"] for pkg in pkg_list}
                except json.JSONDecodeError:
                    pass
            
            for pkg in packages:
                pkg_lower = pkg.lower()
                pkg_normalized = pkg_lower.replace("-", "_").replace("_", "-")
                
                version = None
                for installed_name, installed_version in installed_packages.items():
                    if (installed_name == pkg_lower or 
                        installed_name.replace("-", "_") == pkg_lower.replace("-", "_")):
                        version = installed_version
                        break
                
                if version:
                    result["detected"][pkg] = version
                    result["available"].append(pkg)
                else:
                    result["missing"].append(pkg)
            
            result["success"] = True
            result["total_checked"] = len(packages)
            result["total_available"] = len(result["available"])
            result["total_missing"] = len(result["missing"])
            
            self.logger.info(f"Package detection: {result['total_available']}/{result['total_checked']} available")
            
        except subprocess.TimeoutExpired:
            result["success"] = False
            result["error"] = "Timeout detecting packages"
        except Exception as e:
            self.logger.error(f"Error detecting packages: {e}")
            result["success"] = False
            result["error"] = str(e)
        
        return result
    
    def install_packages(self, packages: List[str], use_conda: bool = False) -> Dict[str, Any]:
        if self.license_tier < LicenseTier.AIDEV:
            return {"success": False, "error": "Requires AI Developer edition"}
        
        try:
            if use_conda and self.check_conda():
                cmd = ["conda", "install", "-y"] + packages
            elif self.check_pip():
                pip_cmd = shutil.which("pip3") or shutil.which("pip")
                cmd = [pip_cmd, "install"] + packages
            else:
                return {"success": False, "error": "No package manager available"}
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            return {"success": result.returncode == 0, "output": result.stdout}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def get_installed_packages(self) -> List[str]:
        try:
            pip_cmd = shutil.which("pip3") or shutil.which("pip")
            if pip_cmd:
                result = subprocess.run([pip_cmd, "list", "--format=freeze"], capture_output=True, text=True, timeout=30)
                if result.returncode == 0:
                    return [line.split("==")[0] for line in result.stdout.strip().split('\n') if line]
        except Exception:
            pass
        return []
    
    def get_status(self) -> Dict[str, Any]:
        installed = self.get_installed_packages()
        return {
            "pip_available": self.check_pip(),
            "conda_available": self.check_conda(),
            "installed_count": len(installed),
            "package_groups": list(DS_PACKAGES.keys())
        }
    
    def run_cli(self):
        print(f"\n{'='*60}")
        print(f"  {APP_NAME} v{VERSION}")
        print(f"{'='*60}\n")
        
        status = self.get_status()
        print(f"Pip: {'✓' if status['pip_available'] else '✗'}")
        print(f"Conda: {'✓' if status['conda_available'] else '✗'}")
        print(f"Installed Packages: {status['installed_count']}")
        
        print("\nPackage Groups:")
        for group, packages in DS_PACKAGES.items():
            print(f"  {group}: {', '.join(packages[:3])}...")
    
    def run_gui(self):
        if not GTK_AVAILABLE:
            return self.run_cli()
        
        win = Gtk.Window(title=f"{APP_NAME}")
        win.set_default_size(800, 600)
        win.connect("destroy", Gtk.main_quit)
        
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        vbox.set_margin_top(20)
        win.add(vbox)
        
        header = Gtk.Label()
        header.set_markup(f"<big><b>{APP_NAME}</b></big>")
        vbox.pack_start(header, False, False, 10)
        
        for group, packages in DS_PACKAGES.items():
            hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            label = Gtk.Label(label=f"{group}: {', '.join(packages[:3])}...")
            label.set_xalign(0)
            hbox.pack_start(label, True, True, 10)
            
            btn = Gtk.Button(label="Install")
            btn.set_sensitive(self.license_tier >= LicenseTier.AIDEV)
            hbox.pack_end(btn, False, False, 10)
            
            vbox.pack_start(hbox, False, False, 5)
        
        win.show_all()
        Gtk.main()


def main():
    parser = argparse.ArgumentParser(description=f"{APP_NAME}")
    parser.add_argument("--gui", action="store_true", help="Launch GUI mode")
    parser.add_argument("--cli", action="store_true", help="Run in CLI mode")
    parser.add_argument("--install", metavar="GROUP", help="Install package group")
    parser.add_argument("--status", action="store_true", help="Show status")
    parser.add_argument("--version", action="version", version=f"{APP_NAME} {VERSION}")
    
    args = parser.parse_args()
    
    if args.install:
        app = AegisDataScience(headless=True)
        if args.install in DS_PACKAGES:
            result = app.install_packages(DS_PACKAGES[args.install])
            print(json.dumps(result, indent=2))
    elif args.status:
        app = AegisDataScience(headless=True)
        print(json.dumps(app.get_status(), indent=2))
    elif args.cli or not GTK_AVAILABLE:
        app = AegisDataScience(headless=False)
        app.run_cli()
    else:
        app = AegisDataScience(headless=False)
        app.run_gui()


if __name__ == "__main__":
    main()
