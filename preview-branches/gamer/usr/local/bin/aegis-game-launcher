#!/usr/bin/env python3
"""
Aegis OS Game Launcher - Comprehensive Gaming Platform
A SteamOS/Bazzite-inspired game launcher for external media and integrated gaming platforms

Features:
- SD card and USB drive game support (Nintendo cartridge-style)
- Auto-detect and mount removable media
- Steam, Lutris, Heroic, Wine/Proton, RetroArch integration
- Game save sync to cloud or local backup
- Performance overlay (MangoHud) and GameMode integration
- Low-latency input handling
- Cover art, playtime, favorites tracking
- Pre-launch Aegis Neural Upscaler (ANU) injection
- Post-game performance reports with stats
- Game categories and organization
- Recently played section
- Dual-GPU Split Rendering Management
- Per-game GPU profile configuration
"""

import os
import sys
import json
import subprocess
import logging
import argparse
import threading
import time
import re
import shutil
import signal
import hashlib
import socket
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from enum import Enum

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, filedialog
    from tkinter.scrolledtext import ScrolledText
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False


ORCHESTRATOR_SOCKET_PATH = "/tmp/aegis-render-orchestrator.sock"


class LicenseTier(Enum):
    FREEMIUM = 1
    BASIC = 2
    GAMER = 3
    GAMER_AI = 4
    SERVER = 5


class GameRunner(Enum):
    NATIVE = "native"
    WINE = "wine"
    PROTON = "proton"
    RETROARCH = "retroarch"
    STEAM = "steam"
    LUTRIS = "lutris"


class SyncMode(Enum):
    VSYNC = "vsync"
    FREESYNC = "freesync"
    GSYNC = "gsync"
    ADAPTIVE = "adaptive"
    UNLOCKED = "unlocked"


@dataclass
class GameManifest:
    """External game manifest structure (aegis-game.json)"""
    name: str
    executable: str
    icon: str = ""
    runner: str = "native"
    proton_version: str = ""
    save_path: str = "./saves"
    launch_options: str = ""
    description: str = ""
    version: str = "1.0"
    developer: str = ""
    genre: str = ""
    min_ram_mb: int = 0
    min_disk_mb: int = 0


@dataclass
class RegionConfig:
    """Configuration for a render region (center or rim)"""
    region: str
    gpu_id: str = ""
    render_resolution: str = "1920x1080"
    output_resolution: str = "2560x1440"
    upscaler_backend: str = "fsr2"
    upscaler_quality: str = "balanced"
    target_fps: int = 60


@dataclass
class SplitRenderProfile:
    """Dual-GPU split rendering profile"""
    name: str
    game_id: str = ""
    description: str = ""
    enabled: bool = True
    center_gpu: str = ""
    rim_gpu: str = ""
    center_radius_pct: float = 60.0
    region_blend_px: int = 32
    sync_mode: str = "freesync"
    master_fps: int = 144
    center_render_res: str = "1920x1080"
    center_output_res: str = "2560x1440"
    center_upscaler: str = "fsr2"
    center_quality: str = "balanced"
    center_target_fps: int = 144
    rim_render_res: str = "1280x720"
    rim_output_res: str = "2560x1440"
    rim_upscaler: str = "fsr1"
    rim_quality: str = "performance"
    rim_target_fps: int = 144


@dataclass
class GPUDevice:
    """Represents a detected GPU"""
    id: str
    name: str
    vendor: str
    vram_mb: int = 0
    is_primary: bool = False
    driver: str = ""
    current_usage_pct: int = 0
    current_temp_c: int = 0


@dataclass
class Game:
    """Game data structure"""
    id: str
    name: str
    platform: str
    executable: str = ""
    install_path: str = ""
    icon_path: str = ""
    cover_art: str = ""
    runner: str = "native"
    proton_version: str = ""
    save_path: str = ""
    launch_options: str = ""
    launch_command: str = ""
    added_date: str = ""
    last_played: str = ""
    play_count: int = 0
    total_playtime: int = 0
    favorite: bool = False
    hidden: bool = False
    is_external: bool = False
    external_device: str = ""
    description: str = ""
    developer: str = ""
    genre: str = ""
    category: str = ""
    upscaler_enabled: bool = False
    upscaler_profile: str = ""
    last_session_fps_avg: float = 0.0
    last_session_fps_min: float = 0.0
    last_session_fps_max: float = 0.0
    split_render_enabled: bool = False
    split_render_profile: str = ""


@dataclass
class PerformanceReport:
    """Post-game performance report"""
    game_id: str
    game_name: str
    session_start: str
    session_end: str
    duration_seconds: int
    avg_fps: float = 0.0
    min_fps: float = 0.0
    max_fps: float = 0.0
    avg_frametime: float = 0.0
    cpu_avg: float = 0.0
    gpu_avg: float = 0.0
    ram_max_mb: int = 0
    vram_max_mb: int = 0
    upscaler_used: str = ""
    upscaler_quality: str = ""
    resolution: str = ""
    split_render_used: bool = False
    center_gpu: str = ""
    rim_gpu: str = ""


class OrchestratorClient:
    """Client for communicating with the aegis-render-orchestrator daemon"""
    
    def __init__(self, socket_path: str = ORCHESTRATOR_SOCKET_PATH):
        self.socket_path = socket_path
        self.connected = False
        self.last_error = ""
    
    def is_available(self) -> bool:
        """Check if orchestrator daemon is available"""
        return os.path.exists(self.socket_path)
    
    def _send_command(self, command: Dict) -> Dict:
        """Send command to daemon and receive response"""
        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.settimeout(5.0)
            sock.connect(self.socket_path)
            sock.sendall(json.dumps(command).encode())
            response = sock.recv(65536).decode()
            sock.close()
            self.connected = True
            self.last_error = ""
            return json.loads(response)
        except socket.timeout:
            self.connected = False
            self.last_error = "Connection timeout"
            return {"success": False, "error": "Connection timeout"}
        except ConnectionRefusedError:
            self.connected = False
            self.last_error = "Daemon not running"
            return {"success": False, "error": "Daemon not running"}
        except FileNotFoundError:
            self.connected = False
            self.last_error = "Daemon socket not found"
            return {"success": False, "error": "Daemon socket not found"}
        except Exception as e:
            self.connected = False
            self.last_error = str(e)
            return {"success": False, "error": str(e)}
    
    def get_status(self) -> Dict:
        """Get orchestrator daemon status"""
        return self._send_command({"command": "status"})
    
    def enumerate_gpus(self) -> List[GPUDevice]:
        """Get list of detected GPUs"""
        result = self._send_command({"command": "enumerate_gpus"})
        gpus = []
        if result.get("success") and result.get("data"):
            for gpu_data in result["data"]:
                gpus.append(GPUDevice(
                    id=gpu_data.get("id", ""),
                    name=gpu_data.get("name", "Unknown GPU"),
                    vendor=gpu_data.get("vendor", "unknown"),
                    vram_mb=gpu_data.get("vram_mb", 0),
                    is_primary=gpu_data.get("is_primary", False),
                    driver=gpu_data.get("driver", ""),
                    current_usage_pct=gpu_data.get("current_usage_pct", 0),
                    current_temp_c=gpu_data.get("current_temp_c", 0)
                ))
        return gpus
    
    def list_profiles(self) -> List[str]:
        """Get list of saved profile names"""
        result = self._send_command({"command": "list_profiles"})
        if result.get("success"):
            return result.get("data", [])
        return []
    
    def get_profile(self, name: str) -> Optional[Dict]:
        """Get a specific profile"""
        result = self._send_command({"command": "get_profile", "name": name})
        if result.get("success"):
            return result.get("data")
        return None
    
    def save_profile(self, profile: Dict) -> bool:
        """Save a profile to the daemon"""
        result = self._send_command({"command": "save_profile", "profile": profile})
        return result.get("success", False)
    
    def start_session(self, profile_name: str, game_command: List[str]) -> Tuple[bool, str]:
        """Start a split-render gaming session"""
        result = self._send_command({
            "command": "start_session",
            "profile": profile_name,
            "game_command": game_command
        })
        return result.get("success", False), result.get("message", result.get("error", "Unknown error"))
    
    def stop_session(self) -> Tuple[bool, str]:
        """Stop the active split-render session"""
        result = self._send_command({"command": "stop_session"})
        return result.get("success", False), result.get("message", result.get("error", "Unknown error"))
    
    def validate_profile(self, name: str) -> Tuple[bool, str]:
        """Validate a profile can run on current hardware"""
        result = self._send_command({"command": "validate_profile", "name": name})
        if result.get("success"):
            return result.get("valid", False), result.get("message", "")
        return False, result.get("error", "Unknown error")
    
    def get_metrics(self) -> Dict:
        """Get real-time metrics from active session"""
        result = self.get_status()
        if result.get("success") and result.get("data"):
            return result["data"].get("metrics", {})
        return {}


class AegisGameLauncher:
    """Main game launcher class"""
    
    VERSION = "2.0.0"
    APP_NAME = "Aegis Game Launcher"
    
    FULL_FEATURE_TIERS = [LicenseTier.GAMER, LicenseTier.GAMER_AI, LicenseTier.SERVER]
    
    EXTERNAL_MOUNT_BASE = Path("/run/aegis/external-games")
    UDEV_RULES_PATH = Path("/etc/udev/rules.d/99-aegis-game-media.rules")
    
    UPSCALER_BACKENDS = ["fsr1", "fsr2", "fsr3", "anu-neural", "bilinear", "lanczos", "none"]
    QUALITY_PRESETS = ["ultra_quality", "quality", "balanced", "performance", "ultra_performance"]
    RESOLUTION_PRESETS = [
        "3840x2160", "2560x1440", "1920x1080", "1600x900",
        "1280x720", "960x540", "640x360"
    ]
    
    def __init__(self, headless: bool = False):
        self.headless = headless
        self.version = self.VERSION
        
        self.config_dir = Path("/etc/aegis")
        self.data_dir = Path("/var/lib/aegis/games")
        self.log_dir = Path("/var/log/aegis")
        self.cache_dir = Path.home() / ".cache" / "aegis-games"
        self.backup_dir = Path("/var/lib/aegis/backup/game-saves")
        self.profiles_dir = Path.home() / ".config/aegis/gpu-profiles"
        
        self.config_file = self.config_dir / "game-launcher.json"
        self.library_file = self.data_dir / "library.json"
        self.playtime_file = self.data_dir / "playtime.json"
        self.favorites_file = self.data_dir / "favorites.json"
        self.saves_index_file = self.data_dir / "saves-index.json"
        self.license_file = self.config_dir / "license.json"
        self.gpu_profiles_file = self.data_dir / "gpu-profiles.json"
        
        self.home_dir = Path.home()
        self.games: Dict[str, Game] = {}
        self.favorites: List[str] = []
        self.external_devices: Dict[str, dict] = {}
        self.running_games: Dict[str, dict] = {}
        self.gpu_profiles: Dict[str, SplitRenderProfile] = {}
        self.detected_gpus: List[GPUDevice] = []
        
        self.gamemode_available = False
        self.mangohud_available = False
        self.upscaler_available = False
        self.license_tier = LicenseTier.FREEMIUM
        
        self.orchestrator_client = OrchestratorClient()
        self.orchestrator_available = False
        
        self.device_monitor_thread = None
        self.monitoring = False
        self.metrics_thread = None
        self.metrics_running = False
        self.current_metrics: Dict = {}
        
        self.categories: List[str] = ["Action", "RPG", "Strategy", "Simulation", "Sports", "Indie", "Multiplayer"]
        self.performance_reports: List[PerformanceReport] = []
        
        self.ensure_directories()
        self.setup_logging()
        self.check_system_capabilities()
        self.load_license_tier()
        self.load_config()
        self.load_library()
        self.load_favorites()
        self.load_gpu_profiles()
        self.refresh_gpu_list()
        
    def ensure_directories(self):
        """Create required directories"""
        dirs = [
            self.config_dir, self.data_dir, self.log_dir, 
            self.cache_dir, self.backup_dir, self.EXTERNAL_MOUNT_BASE,
            self.profiles_dir
        ]
        for directory in dirs:
            try:
                directory.mkdir(parents=True, exist_ok=True)
            except PermissionError:
                pass
    
    def setup_logging(self):
        """Configure logging"""
        log_file = self.log_dir / "game-launcher.log"
        try:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[
                    logging.FileHandler(log_file),
                    logging.StreamHandler() if not self.headless else logging.NullHandler()
                ]
            )
        except PermissionError:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
                handlers=[logging.StreamHandler()]
            )
        self.logger = logging.getLogger("AegisGameLauncher")
        self.logger.info(f"Starting {self.APP_NAME} v{self.VERSION}")
    
    def check_system_capabilities(self):
        """Check for available gaming tools"""
        self.gamemode_available = shutil.which("gamemoded") is not None or \
                                  shutil.which("gamemode") is not None
        self.mangohud_available = shutil.which("mangohud") is not None
        self.upscaler_available = Path("/usr/local/bin/aegis-upscaler").exists() or \
                                  shutil.which("aegis-upscaler") is not None
        self.gamescope_available = shutil.which("gamescope") is not None
        self.orchestrator_available = self.orchestrator_client.is_available()
        
        self.logger.info(f"GameMode available: {self.gamemode_available}")
        self.logger.info(f"MangoHud available: {self.mangohud_available}")
        self.logger.info(f"ANU Upscaler available: {self.upscaler_available}")
        self.logger.info(f"GameScope available: {self.gamescope_available}")
        self.logger.info(f"Render Orchestrator available: {self.orchestrator_available}")
    
    def load_license_tier(self):
        """Load and determine license tier"""
        try:
            if self.license_file.exists():
                with open(self.license_file, 'r') as f:
                    license_data = json.load(f)
                
                edition = license_data.get('edition', 'freemium').lower()
                tier_map = {
                    'freemium': LicenseTier.FREEMIUM,
                    'basic': LicenseTier.BASIC,
                    'gamer': LicenseTier.GAMER,
                    'gamer-ai': LicenseTier.GAMER_AI,
                    'gamer_ai': LicenseTier.GAMER_AI,
                    'server': LicenseTier.SERVER
                }
                self.license_tier = tier_map.get(edition, LicenseTier.FREEMIUM)
            else:
                marker_files = [
                    ("/etc/aegis-gamer-marker", LicenseTier.GAMER),
                    ("/etc/aegis-gamer-ai-marker", LicenseTier.GAMER_AI),
                    ("/etc/aegis-server-marker", LicenseTier.SERVER),
                    ("/etc/aegis-basic-marker", LicenseTier.BASIC),
                    ("/etc/aegis-freemium-marker", LicenseTier.FREEMIUM),
                ]
                for marker, tier in marker_files:
                    if Path(marker).exists():
                        self.license_tier = tier
                        break
                        
        except Exception as e:
            self.logger.warning(f"Failed to load license tier: {e}")
            self.license_tier = LicenseTier.FREEMIUM
        
        self.logger.info(f"License tier: {self.license_tier.name}")
    
    def is_full_version(self) -> bool:
        """Check if running full version with all features"""
        return self.license_tier in self.FULL_FEATURE_TIERS
    
    def load_config(self):
        """Load launcher configuration"""
        default_config = {
            "auto_scan_on_start": True,
            "auto_mount_external": True,
            "monitor_external_devices": True,
            "gamemode_enabled": True,
            "mangohud_enabled": False,
            "mangohud_config": "fps,frametime,cpu_temp,gpu_temp",
            "low_latency_mode": True,
            "steam_paths": [
                str(self.home_dir / ".steam/steam"),
                str(self.home_dir / ".local/share/Steam")
            ],
            "lutris_path": str(self.home_dir / ".config/lutris"),
            "heroic_path": str(self.home_dir / ".config/heroic"),
            "retroarch_path": str(self.home_dir / ".config/retroarch"),
            "wine_prefix": str(self.home_dir / ".wine"),
            "proton_path": str(self.home_dir / ".steam/steam/compatibilitytools.d"),
            "native_paths": [
                "/usr/share/applications",
                str(self.home_dir / ".local/share/applications")
            ],
            "external_device_types": ["usb", "sdcard", "nvme_external"],
            "save_backup_enabled": True,
            "save_backup_interval": 3600,
            "save_sync_cloud": False,
            "cloud_sync_path": "",
            "sort_by": "name",
            "view_mode": "grid",
            "show_hidden_games": False,
            "last_scan": None,
            "ui_theme": "dark",
            "split_render_enabled": False,
            "default_split_profile": "default",
            "auto_start_orchestrator": True,
            "show_gpu_metrics": True
        }
        
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    self.config = {**default_config, **json.load(f)}
            else:
                self.config = default_config
                self.save_config()
        except (json.JSONDecodeError, Exception) as e:
            self.logger.error(f"Error loading config: {e}")
            self.config = default_config
    
    def save_config(self):
        """Save configuration"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
        except PermissionError:
            self.logger.warning("Cannot save config - permission denied")
    
    def load_library(self):
        """Load game library"""
        try:
            if self.library_file.exists():
                with open(self.library_file, 'r') as f:
                    data = json.load(f)
                    for game_id, game_data in data.get('games', {}).items():
                        if 'split_render_enabled' not in game_data:
                            game_data['split_render_enabled'] = False
                        if 'split_render_profile' not in game_data:
                            game_data['split_render_profile'] = ""
                        self.games[game_id] = Game(**game_data)
        except Exception as e:
            self.logger.error(f"Error loading library: {e}")
    
    def save_library(self):
        """Save game library"""
        try:
            data = {
                'version': self.VERSION,
                'last_updated': datetime.now().isoformat(),
                'games': {gid: asdict(g) for gid, g in self.games.items()}
            }
            with open(self.library_file, 'w') as f:
                json.dump(data, f, indent=2)
        except PermissionError:
            self.logger.warning("Cannot save library - permission denied")
    
    def load_favorites(self):
        """Load favorites list"""
        try:
            if self.favorites_file.exists():
                with open(self.favorites_file, 'r') as f:
                    self.favorites = json.load(f)
        except Exception as e:
            self.logger.error(f"Error loading favorites: {e}")
            self.favorites = []
    
    def save_favorites(self):
        """Save favorites list"""
        try:
            with open(self.favorites_file, 'w') as f:
                json.dump(self.favorites, f, indent=2)
        except PermissionError:
            self.logger.warning("Cannot save favorites - permission denied")
    
    def load_gpu_profiles(self):
        """Load GPU split-render profiles"""
        try:
            if self.gpu_profiles_file.exists():
                with open(self.gpu_profiles_file, 'r') as f:
                    data = json.load(f)
                    for name, profile_data in data.get('profiles', {}).items():
                        self.gpu_profiles[name] = SplitRenderProfile(**profile_data)
            
            if not self.gpu_profiles:
                self.gpu_profiles["default"] = SplitRenderProfile(
                    name="default",
                    description="Default dual-GPU profile",
                    center_radius_pct=60.0,
                    region_blend_px=32,
                    sync_mode="freesync",
                    master_fps=144
                )
                self.save_gpu_profiles()
                
        except Exception as e:
            self.logger.error(f"Error loading GPU profiles: {e}")
            self.gpu_profiles = {
                "default": SplitRenderProfile(name="default", description="Default profile")
            }
    
    def save_gpu_profiles(self):
        """Save GPU split-render profiles"""
        try:
            data = {
                'version': self.VERSION,
                'last_updated': datetime.now().isoformat(),
                'profiles': {name: asdict(p) for name, p in self.gpu_profiles.items()}
            }
            with open(self.gpu_profiles_file, 'w') as f:
                json.dump(data, f, indent=2)
        except PermissionError:
            self.logger.warning("Cannot save GPU profiles - permission denied")
    
    def refresh_gpu_list(self):
        """Refresh the list of detected GPUs from orchestrator"""
        if self.orchestrator_available:
            self.detected_gpus = self.orchestrator_client.enumerate_gpus()
            self.logger.info(f"Detected {len(self.detected_gpus)} GPUs")
        else:
            self.detected_gpus = []
    
    def get_gpu_by_id(self, gpu_id: str) -> Optional[GPUDevice]:
        """Get a GPU device by ID"""
        for gpu in self.detected_gpus:
            if gpu.id == gpu_id:
                return gpu
        return None
    
    def create_gpu_profile(self, name: str, description: str = "") -> SplitRenderProfile:
        """Create a new GPU profile"""
        profile = SplitRenderProfile(
            name=name,
            description=description,
            center_radius_pct=60.0,
            region_blend_px=32,
            sync_mode="freesync",
            master_fps=144
        )
        
        if len(self.detected_gpus) >= 2:
            profile.center_gpu = self.detected_gpus[0].id
            profile.rim_gpu = self.detected_gpus[1].id
        elif len(self.detected_gpus) == 1:
            profile.center_gpu = self.detected_gpus[0].id
            profile.rim_gpu = self.detected_gpus[0].id
        
        self.gpu_profiles[name] = profile
        self.save_gpu_profiles()
        return profile
    
    def update_gpu_profile(self, name: str, **kwargs) -> bool:
        """Update an existing GPU profile"""
        if name not in self.gpu_profiles:
            return False
        
        profile = self.gpu_profiles[name]
        for key, value in kwargs.items():
            if hasattr(profile, key):
                setattr(profile, key, value)
        
        self.save_gpu_profiles()
        return True
    
    def delete_gpu_profile(self, name: str) -> bool:
        """Delete a GPU profile"""
        if name in self.gpu_profiles and name != "default":
            del self.gpu_profiles[name]
            self.save_gpu_profiles()
            return True
        return False
    
    def export_gpu_profile(self, name: str, filepath: Path) -> bool:
        """Export a GPU profile to a file"""
        if name not in self.gpu_profiles:
            return False
        try:
            with open(filepath, 'w') as f:
                json.dump(asdict(self.gpu_profiles[name]), f, indent=2)
            return True
        except Exception as e:
            self.logger.error(f"Error exporting profile: {e}")
            return False
    
    def import_gpu_profile(self, filepath: Path) -> Optional[str]:
        """Import a GPU profile from a file"""
        try:
            with open(filepath, 'r') as f:
                data = json.load(f)
            
            name = data.get('name', filepath.stem)
            if name in self.gpu_profiles:
                name = f"{name}_{datetime.now().strftime('%Y%m%d%H%M%S')}"
            data['name'] = name
            
            profile = SplitRenderProfile(**data)
            self.gpu_profiles[name] = profile
            self.save_gpu_profiles()
            return name
        except Exception as e:
            self.logger.error(f"Error importing profile: {e}")
            return None
    
    def set_game_gpu_profile(self, game_id: str, profile_name: str, enabled: bool = True) -> bool:
        """Assign a GPU profile to a game"""
        if game_id not in self.games:
            return False
        if profile_name and profile_name not in self.gpu_profiles:
            return False
        
        self.games[game_id].split_render_profile = profile_name
        self.games[game_id].split_render_enabled = enabled
        self.save_library()
        return True
    
    def sync_profile_to_orchestrator(self, profile_name: str) -> bool:
        """Sync a local profile to the orchestrator daemon"""
        if not self.orchestrator_available:
            return False
        if profile_name not in self.gpu_profiles:
            return False
        
        profile = self.gpu_profiles[profile_name]
        orchestrator_profile = {
            "name": profile.name,
            "game_id": profile.game_id,
            "description": profile.description,
            "sync_mode": profile.sync_mode,
            "master_fps": profile.master_fps,
            "center_radius_pct": profile.center_radius_pct,
            "region_blend_px": profile.region_blend_px,
            "center_config": {
                "region": "center",
                "gpu_id": profile.center_gpu,
                "render_resolution": profile.center_render_res,
                "output_resolution": profile.center_output_res,
                "upscaler_backend": profile.center_upscaler,
                "upscaler_quality": profile.center_quality,
                "target_fps": profile.center_target_fps
            },
            "rim_config": {
                "region": "rim",
                "gpu_id": profile.rim_gpu,
                "render_resolution": profile.rim_render_res,
                "output_resolution": profile.rim_output_res,
                "upscaler_backend": profile.rim_upscaler,
                "upscaler_quality": profile.rim_quality,
                "target_fps": profile.rim_target_fps
            }
        }
        
        return self.orchestrator_client.save_profile(orchestrator_profile)
    
    def start_split_render_session(self, game_id: str, game_command: List[str]) -> Tuple[bool, str]:
        """Start a split-render session for a game"""
        if not self.orchestrator_available:
            return False, "Render orchestrator not available"
        
        game = self.games.get(game_id)
        if not game:
            return False, "Game not found"
        
        profile_name = game.split_render_profile or self.config.get("default_split_profile", "default")
        
        if profile_name not in self.gpu_profiles:
            return False, f"GPU profile '{profile_name}' not found"
        
        if not self.sync_profile_to_orchestrator(profile_name):
            return False, "Failed to sync profile to orchestrator"
        
        return self.orchestrator_client.start_session(profile_name, game_command)
    
    def stop_split_render_session(self) -> Tuple[bool, str]:
        """Stop the current split-render session"""
        if not self.orchestrator_available:
            return False, "Render orchestrator not available"
        return self.orchestrator_client.stop_session()
    
    def get_orchestrator_status(self) -> Dict:
        """Get the orchestrator daemon status"""
        if not self.orchestrator_available:
            return {"running": False, "error": "Orchestrator not available"}
        return self.orchestrator_client.get_status()
    
    def start_metrics_monitoring(self, callback=None):
        """Start monitoring real-time metrics"""
        if self.metrics_running:
            return
        
        self.metrics_running = True
        
        def metrics_loop():
            while self.metrics_running:
                if self.orchestrator_available:
                    self.current_metrics = self.orchestrator_client.get_metrics()
                    if callback:
                        callback(self.current_metrics)
                time.sleep(0.5)
        
        self.metrics_thread = threading.Thread(target=metrics_loop, daemon=True)
        self.metrics_thread.start()
    
    def stop_metrics_monitoring(self):
        """Stop monitoring real-time metrics"""
        self.metrics_running = False
    
    def detect_external_devices(self) -> List[dict]:
        """Detect connected SD cards and USB drives"""
        devices = []
        
        try:
            result = subprocess.run(
                ['lsblk', '-J', '-o', 'NAME,SIZE,TYPE,MOUNTPOINT,LABEL,HOTPLUG,TRAN,RM'],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                data = json.loads(result.stdout)
                for device in data.get('blockdevices', []):
                    if device.get('rm') == '1' or device.get('hotplug') == '1':
                        tran = device.get('tran', '')
                        if tran in ['usb', 'mmc', 'nvme'] or device.get('rm') == '1':
                            device_info = {
                                'name': device.get('name'),
                                'size': device.get('size'),
                                'type': 'sdcard' if tran == 'mmc' else ('usb' if tran == 'usb' else 'external'),
                                'label': device.get('label', ''),
                                'mountpoint': device.get('mountpoint'),
                                'transport': tran
                            }
                            devices.append(device_info)
                            
                            for child in device.get('children', []):
                                if child.get('type') == 'part':
                                    part_info = {
                                        'name': child.get('name'),
                                        'size': child.get('size'),
                                        'type': device_info['type'],
                                        'label': child.get('label', device.get('label', '')),
                                        'mountpoint': child.get('mountpoint'),
                                        'transport': tran,
                                        'parent': device.get('name')
                                    }
                                    devices.append(part_info)
                                    
        except Exception as e:
            self.logger.error(f"Error detecting external devices: {e}")
        
        return devices
    
    def mount_external_device(self, device_name: str, label: str = "") -> Optional[Path]:
        """Mount an external device for game access"""
        if not self.is_full_version():
            self.logger.warning("External media mounting requires Gamer edition or higher")
            return None
        
        mount_name = label if label else device_name
        mount_name = re.sub(r'[^a-zA-Z0-9_-]', '_', mount_name)
        mount_point = self.EXTERNAL_MOUNT_BASE / mount_name
        
        try:
            mount_point.mkdir(parents=True, exist_ok=True)
            
            result = subprocess.run(
                ['mount', f'/dev/{device_name}', str(mount_point)],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                self.logger.info(f"Mounted {device_name} at {mount_point}")
                self.external_devices[device_name] = {
                    'mount_point': str(mount_point),
                    'label': label,
                    'mounted_at': datetime.now().isoformat()
                }
                return mount_point
            else:
                result = subprocess.run(
                    ['udisksctl', 'mount', '-b', f'/dev/{device_name}'],
                    capture_output=True, text=True, timeout=30
                )
                if result.returncode == 0:
                    mount_line = result.stdout.strip()
                    if 'at' in mount_line:
                        actual_mount = mount_line.split('at')[-1].strip().rstrip('.')
                        self.logger.info(f"Mounted {device_name} at {actual_mount}")
                        self.external_devices[device_name] = {
                            'mount_point': actual_mount,
                            'label': label,
                            'mounted_at': datetime.now().isoformat()
                        }
                        return Path(actual_mount)
                        
        except Exception as e:
            self.logger.error(f"Error mounting {device_name}: {e}")
        
        return None
    
    def unmount_external_device(self, device_name: str) -> bool:
        """Unmount an external device"""
        try:
            if device_name in self.external_devices:
                mount_point = self.external_devices[device_name]['mount_point']
                
                result = subprocess.run(
                    ['umount', mount_point],
                    capture_output=True, text=True, timeout=30
                )
                
                if result.returncode == 0:
                    self.logger.info(f"Unmounted {device_name}")
                    del self.external_devices[device_name]
                    return True
                else:
                    result = subprocess.run(
                        ['udisksctl', 'unmount', '-b', f'/dev/{device_name}'],
                        capture_output=True, text=True, timeout=30
                    )
                    if result.returncode == 0:
                        del self.external_devices[device_name]
                        return True
                        
        except Exception as e:
            self.logger.error(f"Error unmounting {device_name}: {e}")
        
        return False
    
    def scan_external_games(self, mount_point: Path) -> List[Game]:
        """Scan an external device for games with aegis-game.json manifests"""
        games = []
        
        if not self.is_full_version():
            self.logger.warning("External game scanning requires Gamer edition or higher")
            return games
        
        try:
            manifest_files = list(mount_point.rglob("aegis-game.json"))
            
            for manifest_path in manifest_files:
                try:
                    with open(manifest_path, 'r') as f:
                        manifest_data = json.load(f)
                    
                    game_dir = manifest_path.parent
                    game_id = f"external_{hashlib.md5(str(manifest_path).encode()).hexdigest()[:12]}"
                    
                    runner = manifest_data.get('runner', 'native').lower()
                    executable = manifest_data.get('executable', '')
                    exe_path = game_dir / executable if executable else ""
                    
                    icon_path = ""
                    if manifest_data.get('icon'):
                        icon_candidate = game_dir / manifest_data['icon']
                        if icon_candidate.exists():
                            icon_path = str(icon_candidate)
                    
                    game = Game(
                        id=game_id,
                        name=manifest_data.get('name', game_dir.name),
                        platform=f"external_{runner}",
                        executable=str(exe_path) if exe_path else "",
                        install_path=str(game_dir),
                        icon_path=icon_path,
                        runner=runner,
                        proton_version=manifest_data.get('proton_version', ''),
                        save_path=str(game_dir / manifest_data.get('save_path', 'saves')),
                        launch_options=manifest_data.get('launch_options', ''),
                        added_date=datetime.now().isoformat(),
                        is_external=True,
                        external_device=str(mount_point),
                        description=manifest_data.get('description', ''),
                        developer=manifest_data.get('developer', ''),
                        genre=manifest_data.get('genre', '')
                    )
                    
                    games.append(game)
                    self.logger.info(f"Found external game: {game.name} ({runner})")
                    
                except Exception as e:
                    self.logger.warning(f"Error parsing manifest {manifest_path}: {e}")
                    
        except Exception as e:
            self.logger.error(f"Error scanning external games: {e}")
        
        return games
    
    def scan_steam_games(self) -> List[Game]:
        """Scan for Steam games"""
        games = []
        
        for steam_path in self.config.get("steam_paths", []):
            steamapps_path = Path(steam_path) / "steamapps"
            
            if not steamapps_path.exists():
                continue
            
            try:
                for acf_file in steamapps_path.glob("appmanifest_*.acf"):
                    try:
                        game_data = self._parse_acf_file(acf_file)
                        if game_data:
                            game_id = f"steam_{game_data['appid']}"
                            install_dir = steamapps_path / "common" / game_data.get("installdir", "")
                            
                            game = Game(
                                id=game_id,
                                name=game_data.get("name", "Unknown Game"),
                                platform="steam",
                                executable="",
                                install_path=str(install_dir),
                                runner="steam",
                                launch_command=f"steam://rungameid/{game_data['appid']}",
                                added_date=datetime.now().isoformat()
                            )
                            games.append(game)
                            
                    except Exception as e:
                        self.logger.warning(f"Error parsing {acf_file}: {e}")
                        
            except Exception as e:
                self.logger.error(f"Error scanning Steam games: {e}")
        
        return games
    
    def _parse_acf_file(self, acf_path: Path) -> Optional[dict]:
        """Parse a Steam ACF manifest file"""
        try:
            with open(acf_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            data = {}
            for match in re.finditer(r'"(\w+)"\s+"([^"]*)"', content):
                data[match.group(1)] = match.group(2)
            
            if 'appid' in data and 'name' in data:
                return data
            
        except Exception as e:
            self.logger.warning(f"Error parsing ACF file {acf_path}: {e}")
        
        return None
    
    def scan_lutris_games(self) -> List[Game]:
        """Scan for Lutris games"""
        games = []
        lutris_path = Path(self.config.get("lutris_path", ""))
        
        if not lutris_path.exists():
            return games
        
        try:
            games_db = lutris_path / "pga.db"
            if games_db.exists():
                import sqlite3
                conn = sqlite3.connect(str(games_db))
                cursor = conn.cursor()
                cursor.execute("SELECT id, name, slug, runner, directory FROM games WHERE installed = 1")
                
                for row in cursor.fetchall():
                    game_id = f"lutris_{row[0]}"
                    game = Game(
                        id=game_id,
                        name=row[1] or "Unknown",
                        platform="lutris",
                        runner=row[3] or "wine",
                        install_path=row[4] or "",
                        launch_command=f"lutris:rungame/{row[2]}",
                        added_date=datetime.now().isoformat()
                    )
                    games.append(game)
                
                conn.close()
                
        except Exception as e:
            self.logger.warning(f"Error scanning Lutris games: {e}")
        
        return games
    
    def scan_heroic_games(self) -> List[Game]:
        """Scan for Heroic games (Epic/GOG)"""
        games = []
        heroic_path = Path(self.config.get("heroic_path", ""))
        
        if not heroic_path.exists():
            return games
        
        try:
            for store in ["legendary", "gog"]:
                installed_file = heroic_path / store / "installed.json"
                if installed_file.exists():
                    with open(installed_file, 'r') as f:
                        installed = json.load(f)
                    
                    for app_name, app_data in installed.items():
                        game_id = f"heroic_{store}_{app_name}"
                        game = Game(
                            id=game_id,
                            name=app_data.get("title", app_name),
                            platform=f"heroic_{store}",
                            install_path=app_data.get("install_path", ""),
                            runner="wine",
                            launch_command=f"heroic://launch/{store}/{app_name}",
                            added_date=datetime.now().isoformat()
                        )
                        games.append(game)
                        
        except Exception as e:
            self.logger.warning(f"Error scanning Heroic games: {e}")
        
        return games
    
    def scan_native_games(self) -> List[Game]:
        """Scan for native Linux games from desktop entries"""
        games = []
        
        for app_path in self.config.get("native_paths", []):
            path = Path(app_path)
            if not path.exists():
                continue
            
            try:
                for desktop_file in path.glob("*.desktop"):
                    try:
                        game_data = self._parse_desktop_file(desktop_file)
                        if game_data and game_data.get('is_game', False):
                            game_id = f"native_{desktop_file.stem}"
                            game = Game(
                                id=game_id,
                                name=game_data.get("name", desktop_file.stem),
                                platform="native",
                                executable=game_data.get("exec", ""),
                                icon_path=game_data.get("icon", ""),
                                runner="native",
                                added_date=datetime.now().isoformat()
                            )
                            games.append(game)
                    except Exception as e:
                        self.logger.warning(f"Error parsing {desktop_file}: {e}")
                        
            except Exception as e:
                self.logger.error(f"Error scanning native games: {e}")
        
        return games
    
    def _parse_desktop_file(self, desktop_path: Path) -> Optional[dict]:
        """Parse a .desktop file"""
        try:
            data = {'is_game': False}
            with open(desktop_path, 'r', encoding='utf-8', errors='ignore') as f:
                for line in f:
                    line = line.strip()
                    if '=' in line:
                        key, value = line.split('=', 1)
                        if key == 'Name':
                            data['name'] = value
                        elif key == 'Exec':
                            data['exec'] = value.split()[0] if value else ""
                        elif key == 'Icon':
                            data['icon'] = value
                        elif key == 'Categories':
                            if 'Game' in value:
                                data['is_game'] = True
            return data
        except Exception:
            return None
    
    def scan_all_games(self, callback=None) -> dict:
        """Scan all game sources"""
        results = {
            'steam': 0, 'lutris': 0, 'heroic': 0, 
            'native': 0, 'external': 0, 'total': 0, 'errors': []
        }
        
        if callback:
            callback("Scanning Steam games...")
        steam_games = self.scan_steam_games()
        results['steam'] = len(steam_games)
        for game in steam_games:
            self._add_or_update_game(game)
        
        if callback:
            callback("Scanning Lutris games...")
        lutris_games = self.scan_lutris_games()
        results['lutris'] = len(lutris_games)
        for game in lutris_games:
            self._add_or_update_game(game)
        
        if callback:
            callback("Scanning Heroic games...")
        heroic_games = self.scan_heroic_games()
        results['heroic'] = len(heroic_games)
        for game in heroic_games:
            self._add_or_update_game(game)
        
        if callback:
            callback("Scanning native games...")
        native_games = self.scan_native_games()
        results['native'] = len(native_games)
        for game in native_games:
            self._add_or_update_game(game)
        
        if self.is_full_version():
            if callback:
                callback("Scanning external devices...")
            for device in self.detect_external_devices():
                if device.get('mountpoint'):
                    external_games = self.scan_external_games(Path(device['mountpoint']))
                    results['external'] += len(external_games)
                    for game in external_games:
                        self._add_or_update_game(game)
        
        results['total'] = len(self.games)
        self.save_library()
        self.config['last_scan'] = datetime.now().isoformat()
        self.save_config()
        
        return results
    
    def _add_or_update_game(self, game: Game):
        """Add or update a game in the library"""
        if game.id in self.games:
            existing = self.games[game.id]
            game.play_count = existing.play_count
            game.total_playtime = existing.total_playtime
            game.favorite = existing.favorite
            game.last_played = existing.last_played
            game.category = existing.category
            game.upscaler_enabled = existing.upscaler_enabled
            game.upscaler_profile = existing.upscaler_profile
            game.split_render_enabled = existing.split_render_enabled
            game.split_render_profile = existing.split_render_profile
            game.last_session_fps_avg = existing.last_session_fps_avg
            game.last_session_fps_min = existing.last_session_fps_min
            game.last_session_fps_max = existing.last_session_fps_max
        
        self.games[game.id] = game
    
    def get_games(self, search: str = None, platform: str = None, 
                  favorites_only: bool = False, external_only: bool = False,
                  sort_by: str = None) -> List[Game]:
        """Get filtered and sorted games list"""
        games = list(self.games.values())
        
        if not self.config.get("show_hidden_games", False):
            games = [g for g in games if not g.hidden]
        
        if search:
            search_lower = search.lower()
            games = [g for g in games if search_lower in g.name.lower()]
        
        if platform:
            games = [g for g in games if platform in g.platform]
        
        if favorites_only:
            games = [g for g in games if g.id in self.favorites]
        
        if external_only:
            games = [g for g in games if g.is_external]
        
        sort_by = sort_by or self.config.get("sort_by", "name")
        if sort_by == "name":
            games.sort(key=lambda x: x.name.lower())
        elif sort_by == "playtime":
            games.sort(key=lambda x: x.total_playtime, reverse=True)
        elif sort_by == "last_played":
            games.sort(key=lambda x: x.last_played or "", reverse=True)
        elif sort_by == "platform":
            games.sort(key=lambda x: (x.platform, x.name.lower()))
        
        return games
    
    def get_favorites(self) -> List[Game]:
        """Get favorite games"""
        return [self.games[gid] for gid in self.favorites if gid in self.games]
    
    def toggle_favorite(self, game_id: str) -> bool:
        """Toggle favorite status for a game"""
        if game_id in self.favorites:
            self.favorites.remove(game_id)
            if game_id in self.games:
                self.games[game_id].favorite = False
        else:
            self.favorites.append(game_id)
            if game_id in self.games:
                self.games[game_id].favorite = True
        
        self.save_favorites()
        self.save_library()
        return game_id in self.favorites
    
    def build_launch_command(self, game: Game) -> List[str]:
        """Build the launch command for a game"""
        cmd = []
        
        if self.config.get("gamemode_enabled") and self.gamemode_available:
            cmd.append("gamemoderun")
        
        if self.config.get("mangohud_enabled") and self.mangohud_available:
            cmd.append("mangohud")
        
        runner = game.runner.lower()
        
        if runner == "steam":
            return ["xdg-open", game.launch_command]
        
        elif runner == "lutris":
            return ["xdg-open", game.launch_command]
        
        elif runner == "wine":
            wine_cmd = ["wine", game.executable]
            if game.launch_options:
                wine_cmd.extend(game.launch_options.split())
            return cmd + wine_cmd
        
        elif runner == "proton":
            proton_path = self._find_proton(game.proton_version)
            if proton_path:
                env_vars = {
                    'STEAM_COMPAT_DATA_PATH': str(Path(game.install_path) / 'pfx'),
                    'STEAM_COMPAT_CLIENT_INSTALL_PATH': str(Path.home() / '.steam/steam')
                }
                proton_cmd = [str(proton_path / 'proton'), 'run', game.executable]
                if game.launch_options:
                    proton_cmd.extend(game.launch_options.split())
                return cmd + proton_cmd
            else:
                return cmd + ["wine", game.executable]
        
        elif runner == "retroarch":
            retroarch_cmd = ["retroarch"]
            if game.launch_options:
                retroarch_cmd.extend(game.launch_options.split())
            if game.executable:
                retroarch_cmd.append(game.executable)
            return cmd + retroarch_cmd
        
        elif runner == "native":
            if game.executable:
                native_cmd = [game.executable]
                if game.launch_options:
                    native_cmd.extend(game.launch_options.split())
                return cmd + native_cmd
            elif game.launch_command:
                return game.launch_command.split()
        
        return []
    
    def _find_proton(self, version: str = "") -> Optional[Path]:
        """Find Proton installation"""
        proton_base = Path(self.config.get("proton_path", ""))
        
        if version and (proton_base / version).exists():
            return proton_base / version
        
        if proton_base.exists():
            proton_dirs = sorted(proton_base.glob("GE-Proton*"), reverse=True)
            if proton_dirs:
                return proton_dirs[0]
            
            proton_dirs = sorted(proton_base.glob("Proton*"), reverse=True)
            if proton_dirs:
                return proton_dirs[0]
        
        return None
    
    def launch_game(self, game_id: str, callback=None) -> Dict:
        """Launch a game"""
        game = self.games.get(game_id)
        if not game:
            return {"success": False, "error": f"Game '{game_id}' not found"}
        
        if game.is_external and not self.is_full_version():
            return {
                "success": False, 
                "error": "External game launching requires Gamer edition or higher",
                "upgrade_required": True
            }
        
        result = {
            "success": False,
            "game_id": game_id,
            "game_name": game.name,
            "platform": game.platform,
            "start_time": datetime.now().isoformat(),
            "error": None,
            "split_render": False
        }
        
        self.logger.info(f"Launching game: {game.name} ({game.platform})")
        if callback:
            callback(f"Launching {game.name}...")
        
        try:
            launch_cmd = self.build_launch_command(game)
            
            if not launch_cmd:
                result["error"] = "Could not build launch command"
                return result
            
            self.logger.info(f"Launch command: {' '.join(launch_cmd)}")
            
            use_split_render = (
                game.split_render_enabled and 
                self.orchestrator_available and 
                self.is_full_version() and
                len(self.detected_gpus) >= 2
            )
            
            if use_split_render:
                if callback:
                    callback(f"Starting split-render session...")
                success, msg = self.start_split_render_session(game_id, launch_cmd)
                if success:
                    result["split_render"] = True
                    result["success"] = True
                    game.play_count += 1
                    game.last_played = datetime.now().isoformat()
                    self.save_library()
                    self.start_metrics_monitoring()
                    return result
                else:
                    self.logger.warning(f"Split-render failed: {msg}, falling back to normal launch")
            
            env = os.environ.copy()
            
            if self.config.get("low_latency_mode"):
                env['__GL_SYNC_TO_VBLANK'] = '0'
                env['vblank_mode'] = '0'
                env['__GL_THREADED_OPTIMIZATIONS'] = '1'
            
            if self.config.get("mangohud_enabled") and self.mangohud_available:
                env['MANGOHUD'] = '1'
                env['MANGOHUD_CONFIG'] = self.config.get("mangohud_config", "")
            
            if game.runner == "wine" or game.runner == "proton":
                env['WINEESYNC'] = '1'
                env['WINEFSYNC'] = '1'
                env['PROTON_ENABLE_NVAPI'] = '1'
            
            upscaler_env = self.get_upscaler_env_vars(game)
            if upscaler_env:
                env.update(upscaler_env)
                self.logger.info(f"Upscaler enabled: {upscaler_env.get('AEGIS_UPSCALER_BACKEND', 'unknown')}")
                if callback:
                    callback(f"ANU Upscaler: {upscaler_env.get('AEGIS_UPSCALER_QUALITY', 'balanced')}")
            
            if game.upscaler_enabled and self.gamescope_available and not use_split_render:
                gamescope_args = self.get_gamescope_args(game)
                if gamescope_args:
                    launch_cmd = gamescope_args + launch_cmd
                    self.logger.info(f"Using gamescope for upscaling")
            
            if self.config.get("mangohud_enabled") and self.mangohud_available:
                log_path = self.cache_dir / f"mangohud_{game_id}.log"
                env['MANGOHUD_LOG'] = str(log_path)
            
            session_start = datetime.now().isoformat()
            start_time = time.time()
            
            process = subprocess.Popen(
                launch_cmd,
                env=env,
                cwd=game.install_path if game.install_path and Path(game.install_path).exists() else None,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            self.running_games[game_id] = {
                'process': process,
                'start_time': start_time,
                'session_start': session_start,
                'game': game,
                'upscaler_enabled': game.upscaler_enabled,
                'split_render': use_split_render
            }
            
            game.play_count += 1
            game.last_played = datetime.now().isoformat()
            self.save_library()
            
            if self.config.get("save_backup_enabled") and self.is_full_version():
                threading.Thread(target=self._monitor_game_session, args=(game_id,), daemon=True).start()
            
            result["success"] = True
            result["pid"] = process.pid
            
        except Exception as e:
            result["error"] = str(e)
            self.logger.error(f"Error launching {game.name}: {e}")
        
        return result
    
    def _monitor_game_session(self, game_id: str):
        """Monitor a running game and handle save backup"""
        if game_id not in self.running_games:
            return
        
        session = self.running_games[game_id]
        process = session['process']
        game = session['game']
        session_start = session.get('session_start', datetime.now().isoformat())
        use_split_render = session.get('split_render', False)
        
        while process.poll() is None:
            time.sleep(5)
        
        end_time = time.time()
        session_end = datetime.now().isoformat()
        playtime = int(end_time - session['start_time'])
        
        game.total_playtime += playtime
        self.save_library()
        
        if use_split_render:
            self.stop_split_render_session()
            self.stop_metrics_monitoring()
        
        report = self.generate_performance_report(game_id, session_start, session_end, playtime, use_split_render)
        if report:
            self.logger.info(f"Performance report: Avg FPS: {report.avg_fps:.1f}, "
                           f"Min: {report.min_fps:.1f}, Max: {report.max_fps:.1f}")
        
        if game.save_path and Path(game.save_path).exists():
            self.backup_game_saves(game_id)
        
        del self.running_games[game_id]
        self.logger.info(f"Game session ended: {game.name} (played {playtime}s)")
    
    def backup_game_saves(self, game_id: str) -> bool:
        """Backup game saves"""
        if not self.is_full_version():
            self.logger.warning("Save backup requires Gamer edition or higher")
            return False
        
        game = self.games.get(game_id)
        if not game or not game.save_path:
            return False
        
        save_path = Path(game.save_path)
        if not save_path.exists():
            return False
        
        try:
            backup_name = f"{game_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            backup_path = self.backup_dir / backup_name
            
            shutil.copytree(save_path, backup_path)
            
            self.logger.info(f"Backed up saves for {game.name} to {backup_path}")
            
            if self.config.get("save_sync_cloud") and self.config.get("cloud_sync_path"):
                cloud_path = Path(self.config["cloud_sync_path"]) / backup_name
                shutil.copytree(save_path, cloud_path)
                self.logger.info(f"Synced saves to cloud: {cloud_path}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error backing up saves: {e}")
            return False
    
    def restore_game_saves(self, game_id: str, backup_name: str = None) -> bool:
        """Restore game saves from backup"""
        if not self.is_full_version():
            self.logger.warning("Save restore requires Gamer edition or higher")
            return False
        
        game = self.games.get(game_id)
        if not game or not game.save_path:
            return False
        
        try:
            backups = sorted(self.backup_dir.glob(f"{game_id}_*"), reverse=True)
            
            if not backups:
                return False
            
            if backup_name:
                backup_path = self.backup_dir / backup_name
                if not backup_path.exists():
                    return False
            else:
                backup_path = backups[0]
            
            save_path = Path(game.save_path)
            if save_path.exists():
                shutil.rmtree(save_path)
            
            shutil.copytree(backup_path, save_path)
            self.logger.info(f"Restored saves for {game.name} from {backup_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error restoring saves: {e}")
            return False
    
    def toggle_mangohud(self) -> bool:
        """Toggle MangoHud overlay"""
        if not self.mangohud_available:
            return False
        
        self.config["mangohud_enabled"] = not self.config.get("mangohud_enabled", False)
        self.save_config()
        return self.config["mangohud_enabled"]
    
    def toggle_gamemode(self) -> bool:
        """Toggle GameMode"""
        if not self.gamemode_available:
            return False
        
        self.config["gamemode_enabled"] = not self.config.get("gamemode_enabled", False)
        self.save_config()
        return self.config["gamemode_enabled"]
    
    def start_device_monitoring(self):
        """Start monitoring for external device changes"""
        if self.monitoring:
            return
        
        self.monitoring = True
        self.device_monitor_thread = threading.Thread(target=self._device_monitor_loop, daemon=True)
        self.device_monitor_thread.start()
    
    def stop_device_monitoring(self):
        """Stop device monitoring"""
        self.monitoring = False
    
    def _device_monitor_loop(self):
        """Monitor loop for external devices"""
        known_devices = set()
        
        while self.monitoring:
            try:
                current_devices = set()
                for device in self.detect_external_devices():
                    device_key = device.get('name', '')
                    current_devices.add(device_key)
                    
                    if device_key not in known_devices:
                        self.logger.info(f"New external device detected: {device_key}")
                        if self.config.get("auto_mount_external"):
                            mount_point = device.get('mountpoint')
                            if mount_point:
                                games = self.scan_external_games(Path(mount_point))
                                for game in games:
                                    self._add_or_update_game(game)
                                if games:
                                    self.save_library()
                
                removed = known_devices - current_devices
                for device_key in removed:
                    self.logger.info(f"External device removed: {device_key}")
                    games_to_remove = [gid for gid, g in self.games.items() 
                                       if g.is_external and device_key in g.external_device]
                    for gid in games_to_remove:
                        del self.games[gid]
                    if games_to_remove:
                        self.save_library()
                
                known_devices = current_devices
                
            except Exception as e:
                self.logger.error(f"Device monitoring error: {e}")
            
            time.sleep(2)
    
    def format_playtime(self, seconds: int) -> str:
        """Format playtime in human-readable format"""
        if seconds < 60:
            return f"{seconds}s"
        elif seconds < 3600:
            return f"{seconds // 60}m"
        else:
            hours = seconds // 3600
            minutes = (seconds % 3600) // 60
            return f"{hours}h {minutes}m"
    
    def get_upscaler_env_vars(self, game: Game) -> Dict[str, str]:
        """Get environment variables for upscaler integration"""
        env_vars = {}
        
        if not self.upscaler_available or not self.is_full_version():
            return env_vars
        
        if not game.upscaler_enabled:
            return env_vars
        
        upscaler_config_path = Path("/etc/aegis/upscaler-config.json")
        if upscaler_config_path.exists():
            try:
                with open(upscaler_config_path, 'r') as f:
                    upscaler_config = json.load(f)
                
                game_override_key = f"steam_{game.id.split('_')[-1]}" if game.platform == "steam" else game.id
                game_settings = upscaler_config.get("per_game_overrides", {}).get(game_override_key, {})
                
                backend = game_settings.get("backend", upscaler_config.get("defaults", {}).get("backend", "fsr2"))
                quality = game_settings.get("quality_preset", upscaler_config.get("defaults", {}).get("quality_preset", "balanced"))
                
                if backend in ["fsr1", "fsr2", "fsr3"]:
                    env_vars["WINE_FULLSCREEN_FSR"] = "1"
                    
                    quality_map = {
                        "ultra_quality": "0",
                        "quality": "1",
                        "balanced": "2",
                        "performance": "3",
                        "ultra_performance": "4"
                    }
                    env_vars["WINE_FULLSCREEN_FSR_STRENGTH"] = quality_map.get(quality, "2")
                    env_vars["WINE_FULLSCREEN_FSR_MODE"] = quality
                
                env_vars["AEGIS_UPSCALER_BACKEND"] = backend
                env_vars["AEGIS_UPSCALER_QUALITY"] = quality
                env_vars["AEGIS_UPSCALER_ENABLED"] = "1"
                
            except Exception as e:
                self.logger.warning(f"Error loading upscaler config: {e}")
        
        return env_vars
    
    def get_gamescope_args(self, game: Game) -> List[str]:
        """Get gamescope arguments for upscaling a game"""
        if not self.gamescope_available or not game.upscaler_enabled:
            return []
        
        upscaler_config_path = Path("/etc/aegis/upscaler-config.json")
        target_width, target_height = 1920, 1080
        quality = "balanced"
        
        if upscaler_config_path.exists():
            try:
                with open(upscaler_config_path, 'r') as f:
                    config = json.load(f)
                
                game_key = f"steam_{game.id.split('_')[-1]}" if game.platform == "steam" else game.id
                game_settings = config.get("per_game_overrides", {}).get(game_key, {})
                quality = game_settings.get("quality_preset", config.get("defaults", {}).get("quality_preset", "balanced"))
                
            except Exception:
                pass
        
        scale_factors = {
            "ultra_quality": 0.77,
            "quality": 0.67,
            "balanced": 0.58,
            "performance": 0.50,
            "ultra_performance": 0.33
        }
        
        scale = scale_factors.get(quality, 0.58)
        render_width = int(target_width * scale)
        render_height = int(target_height * scale)
        
        render_width = (render_width + 7) & ~7
        render_height = (render_height + 7) & ~7
        
        args = [
            "gamescope",
            "-W", str(target_width),
            "-H", str(target_height),
            "-w", str(render_width),
            "-h", str(render_height),
            "-f",
            "-e",
            "-F", "fsr",
            "--fsr-sharpness", "5",
            "--"
        ]
        
        return args
    
    def generate_performance_report(self, game_id: str, session_start: str, 
                                    session_end: str, playtime: int,
                                    split_render_used: bool = False) -> Optional[PerformanceReport]:
        """Generate post-game performance report"""
        game = self.games.get(game_id)
        if not game:
            return None
        
        report = PerformanceReport(
            game_id=game_id,
            game_name=game.name,
            session_start=session_start,
            session_end=session_end,
            duration_seconds=playtime,
            split_render_used=split_render_used
        )
        
        if split_render_used and game.split_render_profile:
            profile = self.gpu_profiles.get(game.split_render_profile)
            if profile:
                report.center_gpu = profile.center_gpu
                report.rim_gpu = profile.rim_gpu
        
        mangohud_log = self.cache_dir / f"mangohud_{game_id}.log"
        if mangohud_log.exists():
            try:
                fps_values = []
                with open(mangohud_log, 'r') as f:
                    for line in f:
                        if line.strip() and not line.startswith('#'):
                            parts = line.split(',')
                            if len(parts) > 1:
                                try:
                                    fps = float(parts[1])
                                    fps_values.append(fps)
                                except ValueError:
                                    pass
                
                if fps_values:
                    report.avg_fps = sum(fps_values) / len(fps_values)
                    report.min_fps = min(fps_values)
                    report.max_fps = max(fps_values)
                    report.avg_frametime = 1000 / report.avg_fps if report.avg_fps > 0 else 0
                    
                    game.last_session_fps_avg = report.avg_fps
                    game.last_session_fps_min = report.min_fps
                    game.last_session_fps_max = report.max_fps
                    self.save_library()
                    
            except Exception as e:
                self.logger.warning(f"Error parsing MangoHud log: {e}")
        
        if game.upscaler_enabled:
            report.upscaler_used = "ANU FSR"
            report.upscaler_quality = game.upscaler_profile or "balanced"
        
        self.performance_reports.append(report)
        self._save_performance_reports()
        
        return report
    
    def _save_performance_reports(self):
        """Save performance reports"""
        try:
            reports_file = self.data_dir / "performance_reports.json"
            data = [asdict(r) for r in self.performance_reports[-100:]]
            with open(reports_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            self.logger.warning(f"Error saving performance reports: {e}")
    
    def get_recently_played(self, limit: int = 10) -> List[Game]:
        """Get recently played games"""
        played_games = [g for g in self.games.values() if g.last_played]
        return sorted(played_games, key=lambda x: x.last_played, reverse=True)[:limit]
    
    def get_games_by_category(self, category: str) -> List[Game]:
        """Get games in a specific category"""
        return [g for g in self.games.values() if g.category == category]
    
    def set_game_category(self, game_id: str, category: str) -> bool:
        """Set category for a game"""
        if game_id in self.games:
            self.games[game_id].category = category
            self.save_library()
            return True
        return False
    
    def toggle_game_upscaler(self, game_id: str) -> bool:
        """Toggle upscaler for a game"""
        if not self.is_full_version():
            self.logger.warning("Upscaler requires Gamer edition or higher")
            return False
        
        if game_id in self.games:
            self.games[game_id].upscaler_enabled = not self.games[game_id].upscaler_enabled
            self.save_library()
            return self.games[game_id].upscaler_enabled
        return False
    
    def toggle_game_split_render(self, game_id: str) -> bool:
        """Toggle split-render for a game"""
        if not self.is_full_version():
            self.logger.warning("Split-render requires Gamer edition or higher")
            return False
        
        if game_id in self.games:
            self.games[game_id].split_render_enabled = not self.games[game_id].split_render_enabled
            self.save_library()
            return self.games[game_id].split_render_enabled
        return False
    
    def set_game_upscaler_profile(self, game_id: str, profile: str) -> bool:
        """Set upscaler profile for a game"""
        if game_id in self.games:
            self.games[game_id].upscaler_profile = profile
            self.games[game_id].upscaler_enabled = True
            self.save_library()
            return True
        return False
    
    def get_stats(self) -> Dict:
        """Get launcher statistics"""
        total_games = len(self.games)
        total_playtime = sum(g.total_playtime for g in self.games.values())
        favorites_count = len(self.favorites)
        external_count = len([g for g in self.games.values() if g.is_external])
        
        platform_counts = {}
        for game in self.games.values():
            platform_counts[game.platform] = platform_counts.get(game.platform, 0) + 1
        
        most_played = sorted(self.games.values(), key=lambda x: x.total_playtime, reverse=True)[:5]
        recently_played = sorted(
            [g for g in self.games.values() if g.last_played],
            key=lambda x: x.last_played,
            reverse=True
        )[:5]
        
        return {
            "total_games": total_games,
            "total_playtime": total_playtime,
            "total_playtime_formatted": self.format_playtime(total_playtime),
            "favorites_count": favorites_count,
            "external_games": external_count,
            "platform_counts": platform_counts,
            "most_played": [{"name": g.name, "playtime": self.format_playtime(g.total_playtime)} 
                           for g in most_played],
            "recently_played": [{"name": g.name, "last_played": g.last_played} 
                               for g in recently_played],
            "gamemode_available": self.gamemode_available,
            "gamemode_enabled": self.config.get("gamemode_enabled", False),
            "mangohud_available": self.mangohud_available,
            "mangohud_enabled": self.config.get("mangohud_enabled", False),
            "upscaler_available": self.upscaler_available,
            "gamescope_available": self.gamescope_available,
            "orchestrator_available": self.orchestrator_available,
            "games_with_upscaler": len([g for g in self.games.values() if g.upscaler_enabled]),
            "games_with_split_render": len([g for g in self.games.values() if g.split_render_enabled]),
            "gpu_count": len(self.detected_gpus),
            "gpu_profiles_count": len(self.gpu_profiles),
            "categories_used": list(set(g.category for g in self.games.values() if g.category)),
            "heroic_games": len([g for g in self.games.values() if g.platform.startswith("heroic")]),
            "license_tier": self.license_tier.name
        }


class AegisGameLauncherGUI:
    """GUI interface for the game launcher with dual-GPU management"""
    
    def __init__(self, launcher: AegisGameLauncher):
        self.launcher = launcher
        self.root = None
        self.game_frames = {}
        self.selected_game = None
        self.metrics_update_id = None
        self.current_tab = "library"
        
    def run(self):
        """Run the GUI"""
        if not TKINTER_AVAILABLE:
            print("Error: tkinter is not available")
            return
        
        self.root = tk.Tk()
        self.root.title(f"{self.launcher.APP_NAME} v{self.launcher.VERSION}")
        self.root.geometry("1400x900")
        self.root.minsize(1000, 700)
        
        self._setup_styles()
        self._create_widgets()
        self._bind_events()
        
        if self.launcher.config.get("auto_scan_on_start"):
            self.root.after(100, self._initial_scan)
        
        if self.launcher.config.get("monitor_external_devices") and self.launcher.is_full_version():
            self.launcher.start_device_monitoring()
        
        self.root.mainloop()
    
    def _setup_styles(self):
        """Setup ttk styles"""
        style = ttk.Style()
        style.theme_use('clam')
        
        bg_color = '#1a1a2e'
        fg_color = '#eee'
        accent_color = '#e94560'
        secondary_color = '#16213e'
        highlight_color = '#0f3460'
        
        style.configure('TFrame', background=bg_color)
        style.configure('TLabel', background=bg_color, foreground=fg_color)
        style.configure('TButton', background=secondary_color, foreground=fg_color)
        style.configure('Header.TLabel', font=('Helvetica', 16, 'bold'))
        style.configure('Title.TLabel', font=('Helvetica', 12, 'bold'))
        style.configure('Subtitle.TLabel', font=('Helvetica', 10))
        style.configure('Game.TFrame', background=secondary_color)
        style.configure('Favorite.TButton', background=accent_color)
        style.configure('Tab.TButton', background=highlight_color, foreground=fg_color, padding=10)
        style.configure('ActiveTab.TButton', background=accent_color, foreground='white', padding=10)
        style.configure('TNotebook', background=bg_color)
        style.configure('TNotebook.Tab', background=secondary_color, foreground=fg_color, padding=[15, 8])
        style.map('TNotebook.Tab', background=[('selected', accent_color)])
        style.configure('TScale', background=bg_color, troughcolor=secondary_color)
        style.configure('TCombobox', fieldbackground=secondary_color, background=secondary_color)
        
        self.root.configure(bg=bg_color)
        self.bg_color = bg_color
        self.fg_color = fg_color
        self.accent_color = accent_color
        self.secondary_color = secondary_color
        self.highlight_color = highlight_color
    
    def _create_widgets(self):
        """Create GUI widgets"""
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        title_label = ttk.Label(
            header_frame, 
            text=f" {self.launcher.APP_NAME}",
            style='Header.TLabel'
        )
        title_label.pack(side=tk.LEFT)
        
        tier_text = f"[{self.launcher.license_tier.name}]"
        if not self.launcher.is_full_version():
            tier_text += " - Upgrade for full features"
        tier_label = ttk.Label(header_frame, text=tier_text)
        tier_label.pack(side=tk.LEFT, padx=20)
        
        if self.launcher.orchestrator_available:
            gpu_count = len(self.launcher.detected_gpus)
            gpu_label = ttk.Label(header_frame, text=f" {gpu_count} GPU(s) detected")
            gpu_label.pack(side=tk.LEFT, padx=10)
        
        controls_frame = ttk.Frame(header_frame)
        controls_frame.pack(side=tk.RIGHT)
        
        self.search_var = tk.StringVar()
        search_entry = ttk.Entry(controls_frame, textvariable=self.search_var, width=30)
        search_entry.pack(side=tk.LEFT, padx=5)
        search_entry.insert(0, "Search games...")
        search_entry.bind('<FocusIn>', lambda e: e.widget.delete(0, tk.END) if e.widget.get() == "Search games..." else None)
        self.search_var.trace('w', lambda *args: self._filter_games())
        
        scan_btn = ttk.Button(controls_frame, text=" Scan", command=self._scan_games)
        scan_btn.pack(side=tk.LEFT, padx=2)
        
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        self.library_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.library_tab, text=" Game Library")
        
        self.gpu_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.gpu_tab, text=" GPU Setup")
        
        self.metrics_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.metrics_tab, text=" Metrics")
        
        self.settings_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.settings_tab, text=" Settings")
        
        self._create_library_tab()
        self._create_gpu_tab()
        self._create_metrics_tab()
        self._create_settings_tab()
        
        status_frame = ttk.Frame(main_frame)
        status_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.status_var = tk.StringVar(value="Ready")
        status_label = ttk.Label(status_frame, textvariable=self.status_var)
        status_label.pack(side=tk.LEFT)
        
        stats = self.launcher.get_stats()
        stats_text = f"Games: {stats['total_games']} | Playtime: {stats['total_playtime_formatted']}"
        if stats.get('gpu_count', 0) > 0:
            stats_text += f" | GPUs: {stats['gpu_count']}"
        stats_label = ttk.Label(status_frame, text=stats_text)
        stats_label.pack(side=tk.RIGHT)
    
    def _create_library_tab(self):
        """Create the game library tab"""
        content_frame = ttk.Frame(self.library_tab)
        content_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        sidebar_frame = ttk.Frame(content_frame, width=220)
        sidebar_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        sidebar_frame.pack_propagate(False)
        
        ttk.Label(sidebar_frame, text=" Quick Launch", style='Title.TLabel').pack(pady=5)
        
        self.favorites_frame = ttk.Frame(sidebar_frame)
        self.favorites_frame.pack(fill=tk.BOTH, expand=True)
        
        filters_label = ttk.Label(sidebar_frame, text="Filters", style='Title.TLabel')
        filters_label.pack(pady=(20, 5))
        
        self.platform_var = tk.StringVar(value="all")
        platforms = [("All Games", "all"), ("Steam", "steam"), ("Lutris", "lutris"), 
                    ("Native", "native"), ("External", "external")]
        for text, value in platforms:
            rb = ttk.Radiobutton(
                sidebar_frame, text=text, value=value,
                variable=self.platform_var, command=self._filter_games
            )
            rb.pack(anchor=tk.W, padx=10)
        
        self.favorites_only_var = tk.BooleanVar()
        fav_check = ttk.Checkbutton(
            sidebar_frame, text=" Favorites Only",
            variable=self.favorites_only_var, command=self._filter_games
        )
        fav_check.pack(anchor=tk.W, padx=10, pady=10)
        
        self.split_render_only_var = tk.BooleanVar()
        split_check = ttk.Checkbutton(
            sidebar_frame, text=" Split Render Games",
            variable=self.split_render_only_var, command=self._filter_games
        )
        split_check.pack(anchor=tk.W, padx=10)
        
        quick_actions = ttk.LabelFrame(sidebar_frame, text="Quick Actions")
        quick_actions.pack(fill=tk.X, padx=5, pady=10)
        
        if self.launcher.mangohud_available:
            self.mangohud_var = tk.BooleanVar(value=self.launcher.config.get("mangohud_enabled", False))
            mangohud_btn = ttk.Checkbutton(
                quick_actions, text=" MangoHud", 
                variable=self.mangohud_var,
                command=self._toggle_mangohud
            )
            mangohud_btn.pack(anchor=tk.W, padx=5, pady=2)
        
        if self.launcher.gamemode_available:
            self.gamemode_var = tk.BooleanVar(value=self.launcher.config.get("gamemode_enabled", False))
            gamemode_btn = ttk.Checkbutton(
                quick_actions, text=" GameMode",
                variable=self.gamemode_var,
                command=self._toggle_gamemode
            )
            gamemode_btn.pack(anchor=tk.W, padx=5, pady=2)
        
        games_frame = ttk.Frame(content_frame)
        games_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.games_canvas = tk.Canvas(games_frame, bg=self.bg_color, highlightthickness=0)
        scrollbar = ttk.Scrollbar(games_frame, orient=tk.VERTICAL, command=self.games_canvas.yview)
        
        self.games_container = ttk.Frame(self.games_canvas)
        self.games_canvas.create_window((0, 0), window=self.games_container, anchor=tk.NW)
        
        self.games_canvas.configure(yscrollcommand=scrollbar.set)
        
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.games_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.games_container.bind('<Configure>', 
            lambda e: self.games_canvas.configure(scrollregion=self.games_canvas.bbox("all")))
    
    def _create_gpu_tab(self):
        """Create the GPU setup/split render tab"""
        content = ttk.Frame(self.gpu_tab)
        content.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        left_panel = ttk.Frame(content, width=350)
        left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        left_panel.pack_propagate(False)
        
        gpu_info_frame = ttk.LabelFrame(left_panel, text=" Detected GPUs")
        gpu_info_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.gpu_list_frame = ttk.Frame(gpu_info_frame)
        self.gpu_list_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self._refresh_gpu_list_display()
        
        refresh_btn = ttk.Button(gpu_info_frame, text=" Refresh GPUs", command=self._refresh_gpus)
        refresh_btn.pack(pady=5)
        
        profiles_frame = ttk.LabelFrame(left_panel, text=" GPU Profiles")
        profiles_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        self.profile_listbox = tk.Listbox(
            profiles_frame, bg=self.secondary_color, fg=self.fg_color,
            selectmode=tk.SINGLE, height=10
        )
        self.profile_listbox.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.profile_listbox.bind('<<ListboxSelect>>', self._on_profile_select)
        
        self._refresh_profile_list()
        
        profile_btns = ttk.Frame(profiles_frame)
        profile_btns.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(profile_btns, text=" New", command=self._new_profile).pack(side=tk.LEFT, padx=2)
        ttk.Button(profile_btns, text=" Import", command=self._import_profile).pack(side=tk.LEFT, padx=2)
        ttk.Button(profile_btns, text=" Export", command=self._export_profile).pack(side=tk.LEFT, padx=2)
        ttk.Button(profile_btns, text=" Delete", command=self._delete_profile).pack(side=tk.LEFT, padx=2)
        
        right_panel = ttk.Frame(content)
        right_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.profile_editor_frame = ttk.LabelFrame(right_panel, text=" Profile Editor")
        self.profile_editor_frame.pack(fill=tk.BOTH, expand=True)
        
        self._create_profile_editor()
    
    def _create_profile_editor(self):
        """Create the profile editor UI"""
        editor = self.profile_editor_frame
        
        for widget in editor.winfo_children():
            widget.destroy()
        
        basic_frame = ttk.Frame(editor)
        basic_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(basic_frame, text="Profile Name:").grid(row=0, column=0, sticky=tk.W, pady=2)
        self.profile_name_var = tk.StringVar()
        ttk.Entry(basic_frame, textvariable=self.profile_name_var, width=30).grid(row=0, column=1, pady=2, padx=5)
        
        ttk.Label(basic_frame, text="Description:").grid(row=1, column=0, sticky=tk.W, pady=2)
        self.profile_desc_var = tk.StringVar()
        ttk.Entry(basic_frame, textvariable=self.profile_desc_var, width=30).grid(row=1, column=1, pady=2, padx=5)
        
        gpu_assign_frame = ttk.LabelFrame(editor, text="GPU Assignment")
        gpu_assign_frame.pack(fill=tk.X, padx=10, pady=5)
        
        gpu_options = [""] + [f"{gpu.id} - {gpu.name}" for gpu in self.launcher.detected_gpus]
        
        ttk.Label(gpu_assign_frame, text="Center GPU:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        self.center_gpu_var = tk.StringVar()
        self.center_gpu_combo = ttk.Combobox(gpu_assign_frame, textvariable=self.center_gpu_var, 
                                              values=gpu_options, width=40, state='readonly')
        self.center_gpu_combo.grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(gpu_assign_frame, text="Rim GPU:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        self.rim_gpu_var = tk.StringVar()
        self.rim_gpu_combo = ttk.Combobox(gpu_assign_frame, textvariable=self.rim_gpu_var,
                                           values=gpu_options, width=40, state='readonly')
        self.rim_gpu_combo.grid(row=1, column=1, padx=5, pady=2)
        
        region_frame = ttk.LabelFrame(editor, text="Region Settings")
        region_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(region_frame, text="Center Radius (%):").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        self.center_radius_var = tk.DoubleVar(value=60.0)
        self.center_radius_scale = ttk.Scale(region_frame, from_=20, to=80, variable=self.center_radius_var,
                                             orient=tk.HORIZONTAL, length=200)
        self.center_radius_scale.grid(row=0, column=1, padx=5, pady=2)
        self.center_radius_label = ttk.Label(region_frame, text="60%")
        self.center_radius_label.grid(row=0, column=2, padx=5)
        self.center_radius_var.trace('w', lambda *a: self.center_radius_label.config(
            text=f"{self.center_radius_var.get():.0f}%"))
        
        ttk.Label(region_frame, text="Region Blend (px):").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        self.blend_var = tk.IntVar(value=32)
        self.blend_scale = ttk.Scale(region_frame, from_=0, to=64, variable=self.blend_var,
                                     orient=tk.HORIZONTAL, length=200)
        self.blend_scale.grid(row=1, column=1, padx=5, pady=2)
        self.blend_label = ttk.Label(region_frame, text="32px")
        self.blend_label.grid(row=1, column=2, padx=5)
        self.blend_var.trace('w', lambda *a: self.blend_label.config(text=f"{self.blend_var.get()}px"))
        
        regions_notebook = ttk.Notebook(editor)
        regions_notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        center_frame = ttk.Frame(regions_notebook)
        regions_notebook.add(center_frame, text="Center Region")
        self._create_region_config(center_frame, "center")
        
        rim_frame = ttk.Frame(regions_notebook)
        regions_notebook.add(rim_frame, text="Rim Region")
        self._create_region_config(rim_frame, "rim")
        
        sync_frame = ttk.LabelFrame(editor, text="Sync Settings")
        sync_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(sync_frame, text="Sync Mode:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        self.sync_mode_var = tk.StringVar(value="freesync")
        sync_options = ["vsync", "freesync", "gsync", "adaptive", "unlocked"]
        ttk.Combobox(sync_frame, textvariable=self.sync_mode_var, values=sync_options,
                     width=15, state='readonly').grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(sync_frame, text="Master FPS:").grid(row=0, column=2, sticky=tk.W, padx=5, pady=2)
        self.master_fps_var = tk.IntVar(value=144)
        ttk.Spinbox(sync_frame, from_=30, to=360, textvariable=self.master_fps_var,
                    width=8).grid(row=0, column=3, padx=5, pady=2)
        
        buttons_frame = ttk.Frame(editor)
        buttons_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Button(buttons_frame, text=" Save Profile", command=self._save_profile).pack(side=tk.LEFT, padx=5)
        ttk.Button(buttons_frame, text=" Reset", command=self._reset_profile_editor).pack(side=tk.LEFT, padx=5)
        ttk.Button(buttons_frame, text=" Sync to Orchestrator", command=self._sync_profile).pack(side=tk.LEFT, padx=5)
    
    def _create_region_config(self, parent, region: str):
        """Create configuration UI for a render region"""
        prefix = f"{region}_"
        
        frame = ttk.Frame(parent)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        ttk.Label(frame, text="Upscaler Backend:").grid(row=0, column=0, sticky=tk.W, pady=2)
        upscaler_var = tk.StringVar(value="fsr2" if region == "center" else "fsr1")
        setattr(self, f"{prefix}upscaler_var", upscaler_var)
        ttk.Combobox(frame, textvariable=upscaler_var, values=self.launcher.UPSCALER_BACKENDS,
                     width=20, state='readonly').grid(row=0, column=1, padx=5, pady=2)
        
        ttk.Label(frame, text="Quality Preset:").grid(row=1, column=0, sticky=tk.W, pady=2)
        quality_var = tk.StringVar(value="balanced" if region == "center" else "performance")
        setattr(self, f"{prefix}quality_var", quality_var)
        ttk.Combobox(frame, textvariable=quality_var, values=self.launcher.QUALITY_PRESETS,
                     width=20, state='readonly').grid(row=1, column=1, padx=5, pady=2)
        
        ttk.Label(frame, text="Render Resolution:").grid(row=2, column=0, sticky=tk.W, pady=2)
        render_res_var = tk.StringVar(value="1920x1080" if region == "center" else "1280x720")
        setattr(self, f"{prefix}render_res_var", render_res_var)
        ttk.Combobox(frame, textvariable=render_res_var, values=self.launcher.RESOLUTION_PRESETS,
                     width=20, state='readonly').grid(row=2, column=1, padx=5, pady=2)
        
        ttk.Label(frame, text="Output Resolution:").grid(row=3, column=0, sticky=tk.W, pady=2)
        output_res_var = tk.StringVar(value="2560x1440")
        setattr(self, f"{prefix}output_res_var", output_res_var)
        ttk.Combobox(frame, textvariable=output_res_var, values=self.launcher.RESOLUTION_PRESETS,
                     width=20, state='readonly').grid(row=3, column=1, padx=5, pady=2)
        
        ttk.Label(frame, text="Target FPS:").grid(row=4, column=0, sticky=tk.W, pady=2)
        target_fps_var = tk.IntVar(value=144)
        setattr(self, f"{prefix}target_fps_var", target_fps_var)
        ttk.Spinbox(frame, from_=30, to=360, textvariable=target_fps_var,
                    width=8).grid(row=4, column=1, padx=5, pady=2, sticky=tk.W)
    
    def _create_metrics_tab(self):
        """Create the real-time metrics tab"""
        content = ttk.Frame(self.metrics_tab)
        content.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        status_frame = ttk.LabelFrame(content, text="Session Status")
        status_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.session_status_var = tk.StringVar(value="No active session")
        ttk.Label(status_frame, textvariable=self.session_status_var, 
                  style='Title.TLabel').pack(padx=10, pady=10)
        
        session_btns = ttk.Frame(status_frame)
        session_btns.pack(pady=5)
        ttk.Button(session_btns, text=" Stop Session", command=self._stop_session).pack(side=tk.LEFT, padx=5)
        ttk.Button(session_btns, text=" Refresh", command=self._refresh_metrics).pack(side=tk.LEFT, padx=5)
        
        metrics_frame = ttk.Frame(content)
        metrics_frame.pack(fill=tk.BOTH, expand=True)
        
        center_metrics = ttk.LabelFrame(metrics_frame, text=" Center Region")
        center_metrics.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        
        self.center_fps_var = tk.StringVar(value="-- FPS")
        self.center_frametime_var = tk.StringVar(value="-- ms")
        self.center_gpu_usage_var = tk.StringVar(value="GPU: --%")
        self.center_latency_var = tk.StringVar(value="Latency: -- ms")
        
        ttk.Label(center_metrics, textvariable=self.center_fps_var, 
                  font=('Helvetica', 24, 'bold')).pack(pady=10)
        ttk.Label(center_metrics, textvariable=self.center_frametime_var).pack()
        ttk.Label(center_metrics, textvariable=self.center_gpu_usage_var).pack()
        ttk.Label(center_metrics, textvariable=self.center_latency_var).pack()
        
        rim_metrics = ttk.LabelFrame(metrics_frame, text=" Rim Region")
        rim_metrics.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        self.rim_fps_var = tk.StringVar(value="-- FPS")
        self.rim_frametime_var = tk.StringVar(value="-- ms")
        self.rim_gpu_usage_var = tk.StringVar(value="GPU: --%")
        self.rim_latency_var = tk.StringVar(value="Latency: -- ms")
        
        ttk.Label(rim_metrics, textvariable=self.rim_fps_var,
                  font=('Helvetica', 24, 'bold')).pack(pady=10)
        ttk.Label(rim_metrics, textvariable=self.rim_frametime_var).pack()
        ttk.Label(rim_metrics, textvariable=self.rim_gpu_usage_var).pack()
        ttk.Label(rim_metrics, textvariable=self.rim_latency_var).pack()
        
        output_frame = ttk.LabelFrame(content, text=" Composite Output")
        output_frame.pack(fill=tk.X, pady=10)
        
        self.output_fps_var = tk.StringVar(value="Output: -- FPS")
        self.sync_status_var = tk.StringVar(value="Sync: --")
        
        ttk.Label(output_frame, textvariable=self.output_fps_var, 
                  font=('Helvetica', 16, 'bold')).pack(side=tk.LEFT, padx=20, pady=10)
        ttk.Label(output_frame, textvariable=self.sync_status_var).pack(side=tk.LEFT, padx=20, pady=10)
    
    def _create_settings_tab(self):
        """Create the settings tab"""
        content = ttk.Frame(self.settings_tab)
        content.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        general_frame = ttk.LabelFrame(content, text="General Settings")
        general_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.auto_scan_var = tk.BooleanVar(value=self.launcher.config.get("auto_scan_on_start", True))
        ttk.Checkbutton(general_frame, text="Auto-scan games on startup",
                        variable=self.auto_scan_var).pack(anchor=tk.W, padx=10, pady=2)
        
        self.auto_mount_var = tk.BooleanVar(value=self.launcher.config.get("auto_mount_external", True))
        ttk.Checkbutton(general_frame, text="Auto-mount external devices",
                        variable=self.auto_mount_var).pack(anchor=tk.W, padx=10, pady=2)
        
        self.low_latency_var = tk.BooleanVar(value=self.launcher.config.get("low_latency_mode", True))
        ttk.Checkbutton(general_frame, text="Low latency mode",
                        variable=self.low_latency_var).pack(anchor=tk.W, padx=10, pady=2)
        
        split_frame = ttk.LabelFrame(content, text="Split Render Settings")
        split_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.auto_orchestrator_var = tk.BooleanVar(value=self.launcher.config.get("auto_start_orchestrator", True))
        ttk.Checkbutton(split_frame, text="Auto-connect to orchestrator daemon",
                        variable=self.auto_orchestrator_var).pack(anchor=tk.W, padx=10, pady=2)
        
        self.show_metrics_var = tk.BooleanVar(value=self.launcher.config.get("show_gpu_metrics", True))
        ttk.Checkbutton(split_frame, text="Show GPU metrics in game tiles",
                        variable=self.show_metrics_var).pack(anchor=tk.W, padx=10, pady=2)
        
        default_profile_frame = ttk.Frame(split_frame)
        default_profile_frame.pack(fill=tk.X, padx=10, pady=5)
        ttk.Label(default_profile_frame, text="Default GPU Profile:").pack(side=tk.LEFT)
        self.default_profile_var = tk.StringVar(value=self.launcher.config.get("default_split_profile", "default"))
        profile_names = list(self.launcher.gpu_profiles.keys())
        ttk.Combobox(default_profile_frame, textvariable=self.default_profile_var,
                     values=profile_names, width=20, state='readonly').pack(side=tk.LEFT, padx=10)
        
        save_btn = ttk.Button(content, text=" Save Settings", command=self._save_settings)
        save_btn.pack(pady=20)
    
    def _bind_events(self):
        """Bind keyboard and mouse events"""
        self.root.bind('<Control-q>', lambda e: self.root.quit())
        self.root.bind('<Control-r>', lambda e: self._scan_games())
        self.root.bind('<Control-f>', lambda e: self.search_var.set(''))
        
        self.games_canvas.bind('<MouseWheel>', 
            lambda e: self.games_canvas.yview_scroll(int(-1*(e.delta/120)), "units"))
        self.games_canvas.bind('<Button-4>', 
            lambda e: self.games_canvas.yview_scroll(-1, "units"))
        self.games_canvas.bind('<Button-5>', 
            lambda e: self.games_canvas.yview_scroll(1, "units"))
    
    def _refresh_gpu_list_display(self):
        """Refresh the GPU list display"""
        for widget in self.gpu_list_frame.winfo_children():
            widget.destroy()
        
        if not self.launcher.detected_gpus:
            ttk.Label(self.gpu_list_frame, text="No GPUs detected\n(Orchestrator may not be running)").pack()
            return
        
        for gpu in self.launcher.detected_gpus:
            gpu_frame = ttk.Frame(self.gpu_list_frame)
            gpu_frame.pack(fill=tk.X, pady=2)
            
            primary_tag = " [Primary]" if gpu.is_primary else ""
            ttk.Label(gpu_frame, text=f" {gpu.name}{primary_tag}",
                      font=('Helvetica', 10, 'bold')).pack(anchor=tk.W)
            ttk.Label(gpu_frame, text=f"   ID: {gpu.id}").pack(anchor=tk.W)
            ttk.Label(gpu_frame, text=f"   VRAM: {gpu.vram_mb}MB | Driver: {gpu.driver}").pack(anchor=tk.W)
    
    def _refresh_profile_list(self):
        """Refresh the profile listbox"""
        self.profile_listbox.delete(0, tk.END)
        for name in self.launcher.gpu_profiles.keys():
            self.profile_listbox.insert(tk.END, name)
    
    def _on_profile_select(self, event):
        """Handle profile selection"""
        selection = self.profile_listbox.curselection()
        if not selection:
            return
        
        name = self.profile_listbox.get(selection[0])
        profile = self.launcher.gpu_profiles.get(name)
        if not profile:
            return
        
        self.profile_name_var.set(profile.name)
        self.profile_desc_var.set(profile.description)
        
        gpu_options = [""] + [f"{gpu.id} - {gpu.name}" for gpu in self.launcher.detected_gpus]
        center_match = [opt for opt in gpu_options if opt.startswith(profile.center_gpu)]
        rim_match = [opt for opt in gpu_options if opt.startswith(profile.rim_gpu)]
        
        if center_match:
            self.center_gpu_var.set(center_match[0])
        if rim_match:
            self.rim_gpu_var.set(rim_match[0])
        
        self.center_radius_var.set(profile.center_radius_pct)
        self.blend_var.set(profile.region_blend_px)
        self.sync_mode_var.set(profile.sync_mode)
        self.master_fps_var.set(profile.master_fps)
        
        self.center_upscaler_var.set(profile.center_upscaler)
        self.center_quality_var.set(profile.center_quality)
        self.center_render_res_var.set(profile.center_render_res)
        self.center_output_res_var.set(profile.center_output_res)
        self.center_target_fps_var.set(profile.center_target_fps)
        
        self.rim_upscaler_var.set(profile.rim_upscaler)
        self.rim_quality_var.set(profile.rim_quality)
        self.rim_render_res_var.set(profile.rim_render_res)
        self.rim_output_res_var.set(profile.rim_output_res)
        self.rim_target_fps_var.set(profile.rim_target_fps)
    
    def _new_profile(self):
        """Create a new profile"""
        name = f"profile_{len(self.launcher.gpu_profiles) + 1}"
        self.launcher.create_gpu_profile(name, "New GPU profile")
        self._refresh_profile_list()
        
        for i in range(self.profile_listbox.size()):
            if self.profile_listbox.get(i) == name:
                self.profile_listbox.selection_clear(0, tk.END)
                self.profile_listbox.selection_set(i)
                self._on_profile_select(None)
                break
    
    def _save_profile(self):
        """Save the current profile"""
        name = self.profile_name_var.get()
        if not name:
            messagebox.showerror("Error", "Profile name is required")
            return
        
        center_gpu = self.center_gpu_var.get().split(" - ")[0] if self.center_gpu_var.get() else ""
        rim_gpu = self.rim_gpu_var.get().split(" - ")[0] if self.rim_gpu_var.get() else ""
        
        profile = SplitRenderProfile(
            name=name,
            description=self.profile_desc_var.get(),
            center_gpu=center_gpu,
            rim_gpu=rim_gpu,
            center_radius_pct=self.center_radius_var.get(),
            region_blend_px=self.blend_var.get(),
            sync_mode=self.sync_mode_var.get(),
            master_fps=self.master_fps_var.get(),
            center_upscaler=self.center_upscaler_var.get(),
            center_quality=self.center_quality_var.get(),
            center_render_res=self.center_render_res_var.get(),
            center_output_res=self.center_output_res_var.get(),
            center_target_fps=self.center_target_fps_var.get(),
            rim_upscaler=self.rim_upscaler_var.get(),
            rim_quality=self.rim_quality_var.get(),
            rim_render_res=self.rim_render_res_var.get(),
            rim_output_res=self.rim_output_res_var.get(),
            rim_target_fps=self.rim_target_fps_var.get()
        )
        
        self.launcher.gpu_profiles[name] = profile
        self.launcher.save_gpu_profiles()
        self._refresh_profile_list()
        self.status_var.set(f"Profile '{name}' saved")
    
    def _delete_profile(self):
        """Delete the selected profile"""
        selection = self.profile_listbox.curselection()
        if not selection:
            return
        
        name = self.profile_listbox.get(selection[0])
        if name == "default":
            messagebox.showerror("Error", "Cannot delete the default profile")
            return
        
        if messagebox.askyesno("Confirm", f"Delete profile '{name}'?"):
            self.launcher.delete_gpu_profile(name)
            self._refresh_profile_list()
            self._reset_profile_editor()
    
    def _import_profile(self):
        """Import a profile from file"""
        filepath = filedialog.askopenfilename(
            title="Import GPU Profile",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filepath:
            name = self.launcher.import_gpu_profile(Path(filepath))
            if name:
                self._refresh_profile_list()
                self.status_var.set(f"Imported profile: {name}")
            else:
                messagebox.showerror("Error", "Failed to import profile")
    
    def _export_profile(self):
        """Export the selected profile to file"""
        selection = self.profile_listbox.curselection()
        if not selection:
            messagebox.showerror("Error", "Select a profile to export")
            return
        
        name = self.profile_listbox.get(selection[0])
        filepath = filedialog.asksaveasfilename(
            title="Export GPU Profile",
            defaultextension=".json",
            initialfile=f"{name}.json",
            filetypes=[("JSON files", "*.json")]
        )
        if filepath:
            if self.launcher.export_gpu_profile(name, Path(filepath)):
                self.status_var.set(f"Exported profile to: {filepath}")
            else:
                messagebox.showerror("Error", "Failed to export profile")
    
    def _reset_profile_editor(self):
        """Reset the profile editor to defaults"""
        self.profile_name_var.set("")
        self.profile_desc_var.set("")
        self.center_gpu_var.set("")
        self.rim_gpu_var.set("")
        self.center_radius_var.set(60.0)
        self.blend_var.set(32)
        self.sync_mode_var.set("freesync")
        self.master_fps_var.set(144)
    
    def _sync_profile(self):
        """Sync selected profile to orchestrator"""
        selection = self.profile_listbox.curselection()
        if not selection:
            messagebox.showerror("Error", "Select a profile to sync")
            return
        
        name = self.profile_listbox.get(selection[0])
        if self.launcher.sync_profile_to_orchestrator(name):
            self.status_var.set(f"Profile '{name}' synced to orchestrator")
        else:
            messagebox.showerror("Error", "Failed to sync profile")
    
    def _refresh_gpus(self):
        """Refresh GPU list"""
        self.launcher.refresh_gpu_list()
        self._refresh_gpu_list_display()
        
        gpu_options = [""] + [f"{gpu.id} - {gpu.name}" for gpu in self.launcher.detected_gpus]
        self.center_gpu_combo['values'] = gpu_options
        self.rim_gpu_combo['values'] = gpu_options
        
        self.status_var.set(f"Found {len(self.launcher.detected_gpus)} GPUs")
    
    def _stop_session(self):
        """Stop the current split-render session"""
        success, msg = self.launcher.stop_split_render_session()
        if success:
            self.session_status_var.set("Session stopped")
            self.status_var.set("Split-render session stopped")
        else:
            self.status_var.set(f"Error: {msg}")
    
    def _refresh_metrics(self):
        """Refresh metrics display"""
        status = self.launcher.get_orchestrator_status()
        
        if status.get("success") and status.get("data", {}).get("active_session"):
            session = status["data"]["active_session"]
            self.session_status_var.set(f"Active: {session.get('profile', 'Unknown')}")
            
            metrics = status["data"].get("metrics", {})
            
            if "center" in metrics:
                cm = metrics["center"]
                self.center_fps_var.set(f"{cm.get('current_fps', 0):.1f} FPS")
                self.center_frametime_var.set(f"{cm.get('frame_time_ms', 0):.2f} ms")
                self.center_gpu_usage_var.set(f"GPU: {cm.get('gpu_usage_pct', 0)}%")
                self.center_latency_var.set(f"Latency: {cm.get('latency_ms', 0):.1f} ms")
            
            if "rim" in metrics:
                rm = metrics["rim"]
                self.rim_fps_var.set(f"{rm.get('current_fps', 0):.1f} FPS")
                self.rim_frametime_var.set(f"{rm.get('frame_time_ms', 0):.2f} ms")
                self.rim_gpu_usage_var.set(f"GPU: {rm.get('gpu_usage_pct', 0)}%")
                self.rim_latency_var.set(f"Latency: {rm.get('latency_ms', 0):.1f} ms")
        else:
            self.session_status_var.set("No active session")
    
    def _save_settings(self):
        """Save settings"""
        self.launcher.config["auto_scan_on_start"] = self.auto_scan_var.get()
        self.launcher.config["auto_mount_external"] = self.auto_mount_var.get()
        self.launcher.config["low_latency_mode"] = self.low_latency_var.get()
        self.launcher.config["auto_start_orchestrator"] = self.auto_orchestrator_var.get()
        self.launcher.config["show_gpu_metrics"] = self.show_metrics_var.get()
        self.launcher.config["default_split_profile"] = self.default_profile_var.get()
        self.launcher.save_config()
        self.status_var.set("Settings saved")
    
    def _initial_scan(self):
        """Perform initial scan on startup"""
        self._scan_games()
    
    def _scan_games(self):
        """Scan for games"""
        self.status_var.set("Scanning for games...")
        self.root.update()
        
        def scan_callback(msg):
            self.status_var.set(msg)
            self.root.update()
        
        threading.Thread(target=lambda: self._do_scan(scan_callback), daemon=True).start()
    
    def _do_scan(self, callback):
        """Perform scan in background thread"""
        results = self.launcher.scan_all_games(callback)
        self.root.after(0, self._refresh_game_list)
        self.root.after(0, self._update_favorites_bar)
        self.root.after(0, lambda: self.status_var.set(
            f"Found {results['total']} games (Steam: {results['steam']}, "
            f"Lutris: {results['lutris']}, Native: {results['native']}, "
            f"External: {results['external']})"
        ))
    
    def _refresh_game_list(self):
        """Refresh the game list display"""
        for widget in self.games_container.winfo_children():
            widget.destroy()
        self.game_frames.clear()
        
        games = self.launcher.get_games(
            search=self.search_var.get() if self.search_var.get() != "Search games..." else None,
            platform=self.platform_var.get() if self.platform_var.get() != "all" else None,
            favorites_only=self.favorites_only_var.get(),
            external_only=self.platform_var.get() == "external"
        )
        
        if self.split_render_only_var.get():
            games = [g for g in games if g.split_render_enabled]
        
        row = 0
        col = 0
        max_cols = 4
        
        for game in games:
            frame = self._create_game_card(game, row, col)
            self.game_frames[game.id] = frame
            
            col += 1
            if col >= max_cols:
                col = 0
                row += 1
        
        if not games:
            no_games_label = ttk.Label(
                self.games_container,
                text="No games found. Click 'Scan' to search for games.",
                style='Title.TLabel'
            )
            no_games_label.grid(row=0, column=0, pady=50)
    
    def _create_game_card(self, game: Game, row: int, col: int) -> ttk.Frame:
        """Create a game card widget"""
        frame = tk.Frame(
            self.games_container,
            bg=self.secondary_color,
            padx=10, pady=10
        )
        frame.grid(row=row, column=col, padx=5, pady=5, sticky='nsew')
        
        icon_label = tk.Label(frame, text="", font=('Helvetica', 32), 
                             bg=self.secondary_color, fg=self.fg_color)
        icon_label.pack()
        
        name_label = tk.Label(
            frame, text=game.name[:20] + ('...' if len(game.name) > 20 else ''),
            font=('Helvetica', 10, 'bold'),
            bg=self.secondary_color, fg=self.fg_color,
            wraplength=150
        )
        name_label.pack(pady=5)
        
        platform_icons = {
            'steam': '', 'lutris': '', 'native': '',
            'external_wine': '', 'external_proton': '',
            'external_native': '', 'external_retroarch': ''
        }
        platform_icon = platform_icons.get(game.platform, '')
        
        info_text = f"{platform_icon} {game.platform}"
        if game.total_playtime > 0:
            info_text += f" | {self.launcher.format_playtime(game.total_playtime)}"
        
        info_label = tk.Label(
            frame, text=info_text,
            font=('Helvetica', 8),
            bg=self.secondary_color, fg='#aaa'
        )
        info_label.pack()
        
        if game.split_render_enabled:
            split_label = tk.Label(
                frame, text=f" {game.split_render_profile or 'default'}",
                font=('Helvetica', 8),
                bg=self.secondary_color, fg='#88ff88'
            )
            split_label.pack()
        
        buttons_frame = tk.Frame(frame, bg=self.secondary_color)
        buttons_frame.pack(pady=5)
        
        play_btn = tk.Button(
            buttons_frame, text=" Play",
            bg=self.accent_color, fg='white',
            command=lambda g=game: self._launch_game(g)
        )
        play_btn.pack(side=tk.LEFT, padx=2)
        
        fav_text = "" if game.id in self.launcher.favorites else ""
        fav_btn = tk.Button(
            buttons_frame, text=fav_text,
            bg=self.secondary_color, fg='gold',
            command=lambda g=game: self._toggle_favorite(g)
        )
        fav_btn.pack(side=tk.LEFT, padx=2)
        
        gpu_btn = tk.Button(
            buttons_frame, text="",
            bg=self.secondary_color, fg=self.fg_color,
            command=lambda g=game: self._show_game_gpu_menu(g)
        )
        gpu_btn.pack(side=tk.LEFT, padx=2)
        
        frame.bind('<Double-Button-1>', lambda e, g=game: self._launch_game(g))
        frame.bind('<Button-3>', lambda e, g=game: self._show_game_context_menu(e, g))
        
        return frame
    
    def _show_game_context_menu(self, event, game: Game):
        """Show context menu for a game"""
        menu = tk.Menu(self.root, tearoff=0)
        menu.add_command(label=" Play", command=lambda: self._launch_game(game))
        menu.add_separator()
        
        fav_label = "Remove from favorites" if game.id in self.launcher.favorites else "Add to favorites"
        menu.add_command(label=f" {fav_label}", command=lambda: self._toggle_favorite(game))
        
        upscaler_label = "Disable upscaler" if game.upscaler_enabled else "Enable upscaler"
        menu.add_command(label=f" {upscaler_label}", 
                        command=lambda: self._toggle_game_upscaler(game))
        
        split_label = "Disable split-render" if game.split_render_enabled else "Enable split-render"
        menu.add_command(label=f" {split_label}",
                        command=lambda: self._toggle_game_split_render(game))
        
        profile_menu = tk.Menu(menu, tearoff=0)
        for profile_name in self.launcher.gpu_profiles.keys():
            check = " " if game.split_render_profile == profile_name else "  "
            profile_menu.add_command(
                label=f"{check}{profile_name}",
                command=lambda p=profile_name: self._set_game_profile(game, p)
            )
        menu.add_cascade(label=" GPU Profile", menu=profile_menu)
        
        menu.add_separator()
        menu.add_command(label=" Open install folder", 
                        command=lambda: self._open_game_folder(game))
        
        menu.tk_popup(event.x_root, event.y_root)
    
    def _show_game_gpu_menu(self, game: Game):
        """Show GPU profile selection for a game"""
        menu = tk.Menu(self.root, tearoff=0)
        
        split_label = " Split-render enabled" if game.split_render_enabled else "  Split-render disabled"
        menu.add_command(label=split_label, 
                        command=lambda: self._toggle_game_split_render(game))
        menu.add_separator()
        
        for profile_name in self.launcher.gpu_profiles.keys():
            check = " " if game.split_render_profile == profile_name else "  "
            menu.add_command(
                label=f"{check}{profile_name}",
                command=lambda p=profile_name: self._set_game_profile(game, p)
            )
        
        menu.tk_popup(self.root.winfo_pointerx(), self.root.winfo_pointery())
    
    def _set_game_profile(self, game: Game, profile_name: str):
        """Set GPU profile for a game"""
        self.launcher.set_game_gpu_profile(game.id, profile_name, True)
        self._refresh_game_list()
        self.status_var.set(f"Set '{profile_name}' profile for {game.name}")
    
    def _toggle_game_upscaler(self, game: Game):
        """Toggle upscaler for a game"""
        enabled = self.launcher.toggle_game_upscaler(game.id)
        status = "enabled" if enabled else "disabled"
        self.status_var.set(f"Upscaler {status} for {game.name}")
        self._refresh_game_list()
    
    def _toggle_game_split_render(self, game: Game):
        """Toggle split-render for a game"""
        enabled = self.launcher.toggle_game_split_render(game.id)
        status = "enabled" if enabled else "disabled"
        self.status_var.set(f"Split-render {status} for {game.name}")
        self._refresh_game_list()
    
    def _open_game_folder(self, game: Game):
        """Open game install folder"""
        if game.install_path and Path(game.install_path).exists():
            subprocess.Popen(['xdg-open', game.install_path])
    
    def _update_favorites_bar(self):
        """Update the favorites quick launch bar"""
        for widget in self.favorites_frame.winfo_children():
            widget.destroy()
        
        favorites = self.launcher.get_favorites()[:10]
        
        if not favorites:
            ttk.Label(self.favorites_frame, text="No favorites yet").pack(pady=5)
            return
        
        for game in favorites:
            btn = tk.Button(
                self.favorites_frame,
                text=f" {game.name[:15]}...",
                bg=self.secondary_color, fg=self.fg_color,
                anchor='w',
                command=lambda g=game: self._launch_game(g)
            )
            btn.pack(fill=tk.X, pady=2)
    
    def _filter_games(self, *args):
        """Filter games based on current criteria"""
        self._refresh_game_list()
    
    def _launch_game(self, game: Game):
        """Launch a game"""
        self.status_var.set(f"Launching {game.name}...")
        self.root.update()
        
        result = self.launcher.launch_game(game.id)
        
        if result["success"]:
            if result.get("split_render"):
                self.status_var.set(f"Launched {game.name} with split-render")
                self.notebook.select(self.metrics_tab)
                self._refresh_metrics()
            else:
                self.status_var.set(f"Launched {game.name}")
        else:
            self.status_var.set(f"Failed: {result.get('error', 'Unknown error')}")
            if result.get("upgrade_required"):
                messagebox.showinfo(
                    "Upgrade Required",
                    "External game launching requires Aegis OS Gamer edition or higher.\n\n"
                    "Visit https://aegis-os.com to upgrade."
                )
    
    def _toggle_favorite(self, game: Game):
        """Toggle game favorite status"""
        self.launcher.toggle_favorite(game.id)
        self._refresh_game_list()
        self._update_favorites_bar()
    
    def _toggle_mangohud(self):
        """Toggle MangoHud"""
        self.launcher.toggle_mangohud()
        status = "enabled" if self.launcher.config.get("mangohud_enabled") else "disabled"
        self.status_var.set(f"MangoHud {status}")
    
    def _toggle_gamemode(self):
        """Toggle GameMode"""
        self.launcher.toggle_gamemode()
        status = "enabled" if self.launcher.config.get("gamemode_enabled") else "disabled"
        self.status_var.set(f"GameMode {status}")


class AegisGameLauncherCLI:
    """CLI interface for the game launcher"""
    
    def __init__(self, launcher: AegisGameLauncher):
        self.launcher = launcher
    
    def run(self, args):
        """Run CLI commands"""
        parser = argparse.ArgumentParser(
            description=f"{self.launcher.APP_NAME} v{self.launcher.VERSION}",
            formatter_class=argparse.RawDescriptionHelpFormatter
        )
        
        subparsers = parser.add_subparsers(dest='command', help='Commands')
        
        subparsers.add_parser('list', help='List all games')
        subparsers.add_parser('scan', help='Scan for games')
        
        launch_parser = subparsers.add_parser('launch', help='Launch a game')
        launch_parser.add_argument('game_id', help='Game ID or name')
        launch_parser.add_argument('--split-render', action='store_true', help='Force split-render mode')
        launch_parser.add_argument('--profile', help='GPU profile to use')
        
        subparsers.add_parser('favorites', help='Show favorite games')
        
        fav_parser = subparsers.add_parser('favorite', help='Toggle favorite')
        fav_parser.add_argument('game_id', help='Game ID')
        
        subparsers.add_parser('stats', help='Show statistics')
        subparsers.add_parser('devices', help='List external devices')
        
        subparsers.add_parser('gpus', help='List detected GPUs')
        subparsers.add_parser('profiles', help='List GPU profiles')
        
        profile_parser = subparsers.add_parser('create-profile', help='Create GPU profile')
        profile_parser.add_argument('name', help='Profile name')
        profile_parser.add_argument('--center-gpu', help='Center GPU ID')
        profile_parser.add_argument('--rim-gpu', help='Rim GPU ID')
        profile_parser.add_argument('--sync', default='freesync', help='Sync mode')
        profile_parser.add_argument('--fps', type=int, default=144, help='Target FPS')
        
        set_profile_parser = subparsers.add_parser('set-profile', help='Assign GPU profile to game')
        set_profile_parser.add_argument('game_id', help='Game ID')
        set_profile_parser.add_argument('profile', help='Profile name')
        
        subparsers.add_parser('orchestrator-status', help='Show orchestrator status')
        subparsers.add_parser('stop-session', help='Stop split-render session')
        
        subparsers.add_parser('mangohud', help='Toggle MangoHud overlay')
        subparsers.add_parser('gamemode', help='Toggle GameMode')
        subparsers.add_parser('gui', help='Launch GUI mode')
        subparsers.add_parser('status', help='Show launcher status')
        
        parsed_args = parser.parse_args(args)
        
        if not parsed_args.command:
            parser.print_help()
            return
        
        if parsed_args.command == 'list':
            self._list_games()
        elif parsed_args.command == 'scan':
            self._scan_games()
        elif parsed_args.command == 'launch':
            self._launch_game(parsed_args.game_id, parsed_args.split_render, parsed_args.profile)
        elif parsed_args.command == 'favorites':
            self._show_favorites()
        elif parsed_args.command == 'favorite':
            self._toggle_favorite(parsed_args.game_id)
        elif parsed_args.command == 'stats':
            self._show_stats()
        elif parsed_args.command == 'devices':
            self._list_devices()
        elif parsed_args.command == 'gpus':
            self._list_gpus()
        elif parsed_args.command == 'profiles':
            self._list_profiles()
        elif parsed_args.command == 'create-profile':
            self._create_profile(parsed_args.name, parsed_args.center_gpu, 
                                parsed_args.rim_gpu, parsed_args.sync, parsed_args.fps)
        elif parsed_args.command == 'set-profile':
            self._set_game_profile(parsed_args.game_id, parsed_args.profile)
        elif parsed_args.command == 'orchestrator-status':
            self._orchestrator_status()
        elif parsed_args.command == 'stop-session':
            self._stop_session()
        elif parsed_args.command == 'mangohud':
            self._toggle_mangohud()
        elif parsed_args.command == 'gamemode':
            self._toggle_gamemode()
        elif parsed_args.command == 'gui':
            self._launch_gui()
        elif parsed_args.command == 'status':
            self._show_status()
    
    def _print_header(self, text: str):
        """Print a header"""
        print(f"\n{'='*60}")
        print(f" {text}")
        print(f"{'='*60}")
    
    def _list_games(self):
        """List all games"""
        self._print_header("Game Library")
        
        games = self.launcher.get_games()
        
        if not games:
            print("\nNo games found. Run 'scan' to search for games.")
            return
        
        platform_groups = {}
        for game in games:
            platform = game.platform
            if platform not in platform_groups:
                platform_groups[platform] = []
            platform_groups[platform].append(game)
        
        for platform, platform_games in platform_groups.items():
            icon = {'steam': '', 'lutris': '', 'native': ''}.get(platform, '')
            print(f"\n{icon} {platform.upper()} ({len(platform_games)} games)")
            print("-" * 40)
            
            for game in platform_games[:20]:
                fav = "" if game.id in self.launcher.favorites else "  "
                split = "" if game.split_render_enabled else "  "
                playtime = self.launcher.format_playtime(game.total_playtime) if game.total_playtime else "-"
                print(f"  {fav}{split} {game.name[:28]:<28} [{playtime:>8}]")
            
            if len(platform_games) > 20:
                print(f"  ... and {len(platform_games) - 20} more")
        
        print(f"\nTotal: {len(games)} games")
    
    def _scan_games(self):
        """Scan for games"""
        self._print_header("Scanning for Games")
        
        def callback(msg):
            print(f"  {msg}")
        
        results = self.launcher.scan_all_games(callback)
        
        print(f"\n Scan Complete!")
        print(f"   Steam:    {results['steam']}")
        print(f"   Lutris:   {results['lutris']}")
        print(f"   Native:   {results['native']}")
        print(f"   External: {results['external']}")
        print(f"   Total:    {results['total']}")
    
    def _launch_game(self, game_id: str, force_split: bool = False, profile: str = None):
        """Launch a game"""
        games = self.launcher.get_games()
        game = None
        for g in games:
            if g.id == game_id or game_id.lower() in g.name.lower():
                game = g
                break
        
        if not game:
            print(f" Game not found: {game_id}")
            return
        
        if profile:
            self.launcher.set_game_gpu_profile(game.id, profile, True)
        elif force_split:
            game.split_render_enabled = True
        
        print(f"\n Launching: {game.name}")
        print(f"   Platform: {game.platform}")
        print(f"   Runner: {game.runner}")
        
        if game.split_render_enabled:
            print(f"    Split-Render: {game.split_render_profile or 'default'}")
        
        result = self.launcher.launch_game(game.id)
        
        if result["success"]:
            print(f"\n Game launched successfully!")
            if result.get("split_render"):
                print("   Split-render session active")
        else:
            print(f"\n Launch failed: {result.get('error', 'Unknown error')}")
    
    def _list_gpus(self):
        """List detected GPUs"""
        self._print_header("Detected GPUs")
        
        self.launcher.refresh_gpu_list()
        
        if not self.launcher.detected_gpus:
            print("\nNo GPUs detected (orchestrator may not be running)")
            return
        
        for gpu in self.launcher.detected_gpus:
            primary = " [PRIMARY]" if gpu.is_primary else ""
            print(f"\n   {gpu.name}{primary}")
            print(f"     ID:     {gpu.id}")
            print(f"     Vendor: {gpu.vendor}")
            print(f"     VRAM:   {gpu.vram_mb} MB")
            print(f"     Driver: {gpu.driver}")
    
    def _list_profiles(self):
        """List GPU profiles"""
        self._print_header("GPU Profiles")
        
        if not self.launcher.gpu_profiles:
            print("\nNo GPU profiles configured")
            return
        
        for name, profile in self.launcher.gpu_profiles.items():
            print(f"\n   {name}")
            print(f"     Center GPU: {profile.center_gpu or 'auto'}")
            print(f"     Rim GPU:    {profile.rim_gpu or 'auto'}")
            print(f"     Sync Mode:  {profile.sync_mode}")
            print(f"     Target FPS: {profile.master_fps}")
            print(f"     Center:     {profile.center_radius_pct}%")
    
    def _create_profile(self, name: str, center_gpu: str, rim_gpu: str, sync: str, fps: int):
        """Create a GPU profile"""
        profile = self.launcher.create_gpu_profile(name)
        
        if center_gpu:
            profile.center_gpu = center_gpu
        if rim_gpu:
            profile.rim_gpu = rim_gpu
        profile.sync_mode = sync
        profile.master_fps = fps
        
        self.launcher.gpu_profiles[name] = profile
        self.launcher.save_gpu_profiles()
        
        print(f"\n Created GPU profile: {name}")
    
    def _set_game_profile(self, game_id: str, profile: str):
        """Set GPU profile for a game"""
        games = self.launcher.get_games()
        game = None
        for g in games:
            if g.id == game_id or game_id.lower() in g.name.lower():
                game = g
                break
        
        if not game:
            print(f" Game not found: {game_id}")
            return
        
        if self.launcher.set_game_gpu_profile(game.id, profile, True):
            print(f" Set profile '{profile}' for {game.name}")
        else:
            print(f" Failed to set profile")
    
    def _orchestrator_status(self):
        """Show orchestrator status"""
        self._print_header("Orchestrator Status")
        
        status = self.launcher.get_orchestrator_status()
        
        if not status.get("success"):
            print(f"\n {status.get('error', 'Could not connect to orchestrator')}")
            return
        
        data = status.get("data", {})
        print(f"\n  Running: {data.get('running', False)}")
        print(f"  GPUs: {len(data.get('gpus', []))}")
        print(f"  Profiles: {', '.join(data.get('profiles', []))}")
        
        if data.get("active_session"):
            session = data["active_session"]
            print(f"\n  Active Session:")
            print(f"    Profile: {session.get('profile')}")
            print(f"    Started: {session.get('started')}")
    
    def _stop_session(self):
        """Stop split-render session"""
        success, msg = self.launcher.stop_split_render_session()
        if success:
            print(" Session stopped")
        else:
            print(f" {msg}")
    
    def _show_favorites(self):
        """Show favorite games"""
        self._print_header("Favorites")
        favorites = self.launcher.get_favorites()
        if not favorites:
            print("\nNo favorites yet")
            return
        for game in favorites:
            print(f"   {game.name}")
    
    def _toggle_favorite(self, game_id: str):
        """Toggle favorite"""
        result = self.launcher.toggle_favorite(game_id)
        status = "added to" if result else "removed from"
        print(f"Game {status} favorites")
    
    def _show_stats(self):
        """Show statistics"""
        self._print_header("Statistics")
        stats = self.launcher.get_stats()
        print(f"\n  Total Games: {stats['total_games']}")
        print(f"  Total Playtime: {stats['total_playtime_formatted']}")
        print(f"  Favorites: {stats['favorites_count']}")
        print(f"  External Games: {stats['external_games']}")
        print(f"  Split-Render Games: {stats.get('games_with_split_render', 0)}")
        print(f"  GPUs Detected: {stats.get('gpu_count', 0)}")
        print(f"  GPU Profiles: {stats.get('gpu_profiles_count', 0)}")
        print(f"  License: {stats['license_tier']}")
    
    def _list_devices(self):
        """List external devices"""
        self._print_header("External Devices")
        devices = self.launcher.detect_external_devices()
        if not devices:
            print("\nNo external devices detected")
            return
        for dev in devices:
            print(f"\n   {dev['name']}")
            print(f"     Size: {dev['size']}")
            print(f"     Type: {dev['type']}")
            print(f"     Mount: {dev.get('mountpoint', 'Not mounted')}")
    
    def _toggle_mangohud(self):
        """Toggle MangoHud"""
        result = self.launcher.toggle_mangohud()
        status = "enabled" if result else "disabled"
        print(f"MangoHud {status}")
    
    def _toggle_gamemode(self):
        """Toggle GameMode"""
        result = self.launcher.toggle_gamemode()
        status = "enabled" if result else "disabled"
        print(f"GameMode {status}")
    
    def _launch_gui(self):
        """Launch GUI"""
        gui = AegisGameLauncherGUI(self.launcher)
        gui.run()
    
    def _show_status(self):
        """Show launcher status"""
        self._print_header("Launcher Status")
        print(f"\n  Version: {self.launcher.VERSION}")
        print(f"  License: {self.launcher.license_tier.name}")
        print(f"  GameMode: {'' if self.launcher.gamemode_available else ''}")
        print(f"  MangoHud: {'' if self.launcher.mangohud_available else ''}")
        print(f"  Upscaler: {'' if self.launcher.upscaler_available else ''}")
        print(f"  GameScope: {'' if self.launcher.gamescope_available else ''}")
        print(f"  Orchestrator: {'' if self.launcher.orchestrator_available else ''}")
        print(f"  GPUs: {len(self.launcher.detected_gpus)}")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--gui', action='store_true', help='Launch GUI mode')
    parser.add_argument('--headless', action='store_true', help='Run in headless mode')
    
    args, remaining = parser.parse_known_args()
    
    launcher = AegisGameLauncher(headless=args.headless)
    
    if args.gui or (not remaining and not args.headless and TKINTER_AVAILABLE):
        gui = AegisGameLauncherGUI(launcher)
        gui.run()
    else:
        cli = AegisGameLauncherCLI(launcher)
        cli.run(remaining)


if __name__ == "__main__":
    main()
