name: Build Aegis OS ISOs

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      edition:
        description: 'Edition to build'
        required: true
        default: 'freemium'
        type: choice
        options:
          - freemium
          - basic
          - gamer
          - workplace
          - aidev
          - gamer-ai
          - server
          - all

jobs:
  validate:
    name: Validate Build System
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Validate Python files
        run: |
          echo "=== Validating Python syntax ==="
          errors=0
          while IFS= read -r f; do
            if python3 -m py_compile "$f" 2>/dev/null; then
              echo "OK: $f"
            else
              echo "ERROR: $f"
              errors=$((errors + 1))
            fi
          done < <(find . -name "*.py" -type f -not -path "./.cache/*" -not -path "./.pythonlibs/*")
          if [ "$errors" -gt 0 ]; then
            echo "Found $errors Python syntax errors"
            exit 1
          fi
      
      - name: Run simulation test
        run: |
          cd build-system
          python3 build-aegis.py --edition freemium --simulate --verbose

  build-iso:
    name: Build ${{ matrix.edition }} ISO
    needs: validate
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
      options: --privileged
    strategy:
      fail-fast: false
      matrix:
        edition: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.edition == 'all' && fromJSON('["freemium", "basic", "gamer", "workplace", "aidev", "gamer-ai", "server"]') || fromJSON(format('["{0}"]', github.event.inputs.edition || 'freemium')) }}
    
    steps:
      - name: Initialize pacman and enable multilib
        run: |
          set -e
          echo "=== Initializing pacman keyring ==="
          pacman-key --init
          pacman-key --populate archlinux
          
          # Update keyring first
          pacman -Sy --noconfirm archlinux-keyring
          
          # Enable multilib repository in container's pacman.conf
          # This is needed so mkarchiso can find lib32-* packages
          echo "=== Enabling multilib repository ==="
          cp /etc/pacman.conf /etc/pacman.conf.orig
          
          # Uncomment [multilib] section
          sed -i '/^#\[multilib\]/,/^#Include/ s/^#//' /etc/pacman.conf
          
          # Verify multilib is enabled
          echo "=== Verifying multilib is enabled ==="
          grep -A1 "\[multilib\]" /etc/pacman.conf || echo "WARNING: multilib section not found"
          
          # Full system upgrade with new repos
          echo "=== Syncing package databases ==="
          pacman -Syy --noconfirm
          
      - name: Install build dependencies
        run: |
          set -e
          echo "=== Installing build dependencies ==="
          pacman -S --needed --noconfirm \
            git \
            python \
            archiso \
            squashfs-tools \
            libisoburn \
            dosfstools \
            e2fsprogs \
            mtools \
            grub \
            efibootmgr \
            rsync \
            wget \
            curl \
            gnupg
      
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup archiso profile
        run: |
          set -e
          echo "=== Setting up ${{ matrix.edition }} profile ==="
          EDITION="${{ matrix.edition }}"
          PROFILE_DIR="/tmp/aegis-${EDITION}"
          REPO_DIR="${GITHUB_WORKSPACE}"
          
          # Copy base releng profile from archiso
          cp -r /usr/share/archiso/configs/releng "${PROFILE_DIR}"
          
          # CRITICAL: Copy the container's pacman.conf (with multilib enabled) to the profile
          # This ensures mkarchiso uses the same repos when installing packages into airootfs
          echo "=== Copying pacman.conf with multilib to profile ==="
          cp /etc/pacman.conf "${PROFILE_DIR}/pacman.conf"
          
          # Also ensure mirrorlist is available
          mkdir -p "${PROFILE_DIR}/airootfs/etc/pacman.d"
          cp /etc/pacman.d/mirrorlist "${PROFILE_DIR}/airootfs/etc/pacman.d/mirrorlist"
          
          # Create Aegis directories
          mkdir -p "${PROFILE_DIR}/airootfs/etc/aegis"
          echo "aegis-${EDITION}" > "${PROFILE_DIR}/airootfs/etc/hostname"
          echo "{\"edition\": \"${EDITION}\", \"version\": \"1.0.0\"}" > "${PROFILE_DIR}/airootfs/etc/aegis/edition.json"
          
          # Copy common overlays using rsync
          if [ -d "${REPO_DIR}/build-system/overlays/common" ]; then
            echo "Copying common overlays..."
            rsync -av "${REPO_DIR}/build-system/overlays/common/" "${PROFILE_DIR}/airootfs/"
          else
            echo "WARNING: No common overlays found"
          fi
          
          # Copy pro overlays for paid editions
          if [ "$EDITION" != "freemium" ] && [ -d "${REPO_DIR}/build-system/overlays/pro" ]; then
            echo "Copying pro overlays for paid edition..."
            rsync -av "${REPO_DIR}/build-system/overlays/pro/" "${PROFILE_DIR}/airootfs/"
          fi
          
          # Copy pro-productivity overlays for appropriate editions
          if [ "$EDITION" = "basic" ] || [ "$EDITION" = "workplace" ]; then
            if [ -d "${REPO_DIR}/build-system/overlays/pro-productivity" ]; then
              echo "Copying pro-productivity overlays..."
              rsync -av "${REPO_DIR}/build-system/overlays/pro-productivity/" "${PROFILE_DIR}/airootfs/"
            fi
          fi
          
          # Copy edition-specific overlays
          if [ -d "${REPO_DIR}/build-system/overlays/${EDITION}" ]; then
            echo "Copying ${EDITION} overlays..."
            rsync -av "${REPO_DIR}/build-system/overlays/${EDITION}/" "${PROFILE_DIR}/airootfs/"
          else
            echo "WARNING: No ${EDITION}-specific overlays found"
          fi
          
          # Set executable permissions on all scripts
          find "${PROFILE_DIR}/airootfs/usr/local/bin/" -type f -exec chmod +x {} \; 2>/dev/null || true
          
          # Debug: show what was copied
          echo "=== Overlay contents ==="
          ls -la "${PROFILE_DIR}/airootfs/usr/local/bin/" 2>/dev/null || echo "No tools in usr/local/bin"
          ls -la "${PROFILE_DIR}/airootfs/etc/aegis/" 2>/dev/null || echo "No aegis config"
          
          # Add base packages - these are available in standard repos
          cat >> "${PROFILE_DIR}/packages.x86_64" << 'EOF'
xfce4
xfce4-goodies
lightdm
lightdm-gtk-greeter
firefox
vlc
libreoffice-fresh
ttf-dejavu
ttf-liberation
networkmanager
network-manager-applet
pipewire
pipewire-pulse
pipewire-alsa
wireplumber
pavucontrol
gvfs
gvfs-mtp
thunar-volman
xdg-user-dirs
fastfetch
EOF
          
          # Add edition-specific packages
          case "$EDITION" in
            gamer|gamer-ai)
              cat >> "${PROFILE_DIR}/packages.x86_64" << 'EOF'
steam
lutris
gamemode
lib32-gamemode
mangohud
lib32-mangohud
lib32-mesa
lib32-vulkan-icd-loader
lib32-gnutls
lib32-libpulse
wine
wine-gecko
wine-mono
winetricks
EOF
              ;;
          esac
          
          case "$EDITION" in
            aidev|gamer-ai)
              cat >> "${PROFILE_DIR}/packages.x86_64" << 'EOF'
python
python-pip
python-virtualenv
jupyterlab
docker
podman
EOF
              ;;
          esac
          
          case "$EDITION" in
            workplace)
              cat >> "${PROFILE_DIR}/packages.x86_64" << 'EOF'
remmina
freerdp
thunderbird
evolution
EOF
              ;;
          esac
          
          case "$EDITION" in
            server)
              cat >> "${PROFILE_DIR}/packages.x86_64" << 'EOF'
docker
podman
nginx
mariadb
postgresql
redis
EOF
              ;;
          esac
          
          # Remove duplicate packages and blank lines
          grep -v '^$' "${PROFILE_DIR}/packages.x86_64" | sort -u > "${PROFILE_DIR}/packages.x86_64.tmp"
          mv "${PROFILE_DIR}/packages.x86_64.tmp" "${PROFILE_DIR}/packages.x86_64"
          
          echo "=== Final package list ($(wc -l < "${PROFILE_DIR}/packages.x86_64") packages) ==="
          cat "${PROFILE_DIR}/packages.x86_64"
          
          echo "PROFILE_DIR=${PROFILE_DIR}" >> $GITHUB_ENV

      - name: Validate packages exist
        run: |
          set -e
          echo "=== Validating all packages exist in repos ==="
          PROFILE_DIR="${{ env.PROFILE_DIR }}"
          missing_pkgs=()
          
          while IFS= read -r pkg; do
            # Skip empty lines and comments
            [[ -z "$pkg" || "$pkg" =~ ^# ]] && continue
            
            # Check if package exists
            if ! pacman -Si "$pkg" &>/dev/null; then
              echo "WARNING: Package not found: $pkg"
              missing_pkgs+=("$pkg")
            fi
          done < "${PROFILE_DIR}/packages.x86_64"
          
          if [ "${#missing_pkgs[@]}" -gt 0 ]; then
            echo ""
            echo "=== Missing packages detected ==="
            printf '%s\n' "${missing_pkgs[@]}"
            echo ""
            echo "Removing missing packages from list..."
            for pkg in "${missing_pkgs[@]}"; do
              sed -i "/^${pkg}$/d" "${PROFILE_DIR}/packages.x86_64"
            done
            echo "Continuing build without missing packages..."
          else
            echo "All packages validated successfully!"
          fi

      - name: Build ISO
        run: |
          set -e
          echo "=== Building ${{ matrix.edition }} ISO ==="
          EDITION="${{ matrix.edition }}"
          PROFILE_DIR="${{ env.PROFILE_DIR }}"
          OUTPUT_DIR="/tmp/aegis-output"
          WORK_DIR="/tmp/work-${EDITION}"
          
          mkdir -p "${OUTPUT_DIR}" "${WORK_DIR}"
          
          # Clean any previous work directory
          rm -rf "${WORK_DIR:?}"/*
          
          echo "=== Starting mkarchiso ==="
          echo "Profile: ${PROFILE_DIR}"
          echo "Work dir: ${WORK_DIR}"
          echo "Output: ${OUTPUT_DIR}"
          
          # Build the ISO
          mkarchiso -v -w "${WORK_DIR}" -o "${OUTPUT_DIR}" "${PROFILE_DIR}"
          
          # Rename and create checksum
          ISO_FILE=$(ls "${OUTPUT_DIR}"/*.iso 2>/dev/null | head -1)
          if [ -n "$ISO_FILE" ]; then
            FINAL_NAME="aegis-os-${EDITION}-1.0.0-x86_64.iso"
            mv "$ISO_FILE" "${OUTPUT_DIR}/${FINAL_NAME}"
            echo "ISO_PATH=${OUTPUT_DIR}/${FINAL_NAME}" >> $GITHUB_ENV
            
            sha256sum "${OUTPUT_DIR}/${FINAL_NAME}" > "${OUTPUT_DIR}/${FINAL_NAME}.sha256"
            echo "SHA256_PATH=${OUTPUT_DIR}/${FINAL_NAME}.sha256" >> $GITHUB_ENV
            
            echo "=== ISO Build Complete ==="
            ls -lh "${OUTPUT_DIR}/${FINAL_NAME}"
            cat "${OUTPUT_DIR}/${FINAL_NAME}.sha256"
          else
            echo "ERROR: No ISO file was produced!"
            echo "=== Work directory contents ==="
            ls -la "${WORK_DIR}/" || true
            echo "=== Output directory contents ==="
            ls -la "${OUTPUT_DIR}/" || true
            exit 1
          fi

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: aegis-os-${{ matrix.edition }}-iso
          path: |
            /tmp/aegis-output/*.iso
            /tmp/aegis-output/*.sha256
          retention-days: 30
          compression-level: 0

  release:
    name: Create Release
    needs: build-iso
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            artifacts/**/*.iso
            artifacts/**/*.sha256
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
