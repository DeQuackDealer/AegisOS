name: Build Aegis OS ISOs

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      edition:
        description: 'Edition to build'
        required: true
        default: 'freemium'
        type: choice
        options:
          - freemium
          - basic
          - gamer
          - workplace
          - aidev
          - gamer-ai
          - server
          - all

jobs:
  determine-matrix:
    name: Determine Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Set matrix
        id: set-matrix
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.edition }}" = "all" ]; then
            echo 'matrix=["freemium","basic","gamer","workplace","aidev","gamer-ai","server"]' >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo 'matrix=["${{ github.event.inputs.edition }}"]' >> $GITHUB_OUTPUT
          else
            echo 'matrix=["freemium"]' >> $GITHUB_OUTPUT
          fi

  validate:
    name: Validate Build System
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Validate Python files
        run: |
          echo "=== Validating Python syntax ==="
          errors=0
          for f in $(find . -name "*.py" -type f -not -path "./.cache/*" -not -path "./.pythonlibs/*"); do
            if python3 -m py_compile "$f" 2>/dev/null; then
              echo "OK: $f"
            else
              echo "ERROR: $f"
              errors=$((errors + 1))
            fi
          done
          if [ "$errors" -gt 0 ]; then
            echo "Found $errors Python syntax errors"
            exit 1
          fi
      
      - name: Run simulation test
        run: |
          cd build-system
          python3 build-aegis.py --edition freemium --simulate --verbose

  build-iso:
    name: Build ${{ matrix.edition }} ISO
    needs: [determine-matrix, validate]
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
      options: --privileged
    strategy:
      fail-fast: false
      matrix:
        edition: ${{ fromJson(needs.determine-matrix.outputs.matrix) }}
    
    steps:
      - name: Initialize pacman and enable multilib + Chaotic-AUR
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          set -e
          echo "=== Initializing pacman keyring ==="
          pacman-key --init
          pacman-key --populate archlinux
          pacman -Sy --noconfirm archlinux-keyring
          echo "=== Enabling multilib repository ==="
          cp /etc/pacman.conf /etc/pacman.conf.orig
          sed -i '/^#\[multilib\]/,/^#Include/ s/^#//' /etc/pacman.conf
          echo "=== Verifying multilib is enabled ==="
          grep -A1 "\[multilib\]" /etc/pacman.conf || echo "WARNING: multilib section not found"
          
          echo "=== Adding Chaotic-AUR repository for AUR packages ==="
          pacman-key --recv-key 3056513887B78AEB --keyserver keyserver.ubuntu.com
          pacman-key --lsign-key 3056513887B78AEB
          pacman -U --noconfirm 'https://cdn-mirror.chaotic.cx/chaotic-aur/chaotic-keyring.pkg.tar.zst'
          pacman -U --noconfirm 'https://cdn-mirror.chaotic.cx/chaotic-aur/chaotic-mirrorlist.pkg.tar.zst'
          
          echo "" >> /etc/pacman.conf
          echo "[chaotic-aur]" >> /etc/pacman.conf
          echo "Include = /etc/pacman.d/chaotic-mirrorlist" >> /etc/pacman.conf
          
          echo "=== Syncing package databases ==="
          pacman -Syy --noconfirm
          
      - name: Install build dependencies
        run: |
          set -e
          echo "=== Installing build dependencies ==="
          pacman -S --needed --noconfirm git python archiso squashfs-tools libisoburn dosfstools e2fsprogs mtools grub syslinux efibootmgr rsync wget curl gnupg qemu-system-x86 qemu-ui-gtk edk2-ovmf
      
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Setup archiso profile
        run: |
          set -e
          echo "=== Setting up ${{ matrix.edition }} profile ==="
          EDITION="${{ matrix.edition }}"
          PROFILE_DIR="/tmp/aegis-${EDITION}"
          REPO_DIR="${GITHUB_WORKSPACE}"
          VERSION="1.0.0"
          BUILD_DATE=$(date +%Y.%m.%d)
          
          cp -r /usr/share/archiso/configs/releng "${PROFILE_DIR}"
          
          # Use default install_dir to match releng boot configs - no modifications needed
          echo "=== Using default install_dir='arch' to match releng boot configs ==="
          echo "--- syslinux configs: ---"
          ls -la "${PROFILE_DIR}/syslinux/" 2>/dev/null || echo "No syslinux dir"
          echo "--- efiboot configs: ---"
          ls -la "${PROFILE_DIR}/efiboot/" 2>/dev/null || echo "No efiboot dir"
          
          echo "=== Copying pacman.conf with multilib and Chaotic-AUR to profile ==="
          cp /etc/pacman.conf "${PROFILE_DIR}/pacman.conf"
          
          echo "=== Configuring pacman to ignore Chaotic-AUR provider conflicts ==="
          sed -i '/\[options\]/a IgnorePkg = dashbinsh nvidia-340xx-utils' "${PROFILE_DIR}/pacman.conf"
          mkdir -p "${PROFILE_DIR}/airootfs/etc/pacman.d"
          
          # CRITICAL: Copy pacman.conf to airootfs/etc/ for the installed system
          cp "${PROFILE_DIR}/pacman.conf" "${PROFILE_DIR}/airootfs/etc/pacman.conf"
          
          cp /etc/pacman.d/mirrorlist "${PROFILE_DIR}/airootfs/etc/pacman.d/mirrorlist"
          cp /etc/pacman.d/chaotic-mirrorlist "${PROFILE_DIR}/airootfs/etc/pacman.d/chaotic-mirrorlist" 2>/dev/null || true
          mkdir -p "${PROFILE_DIR}/airootfs/etc/aegis"
          echo "aegis-${EDITION}" > "${PROFILE_DIR}/airootfs/etc/hostname"
          echo "{\"edition\": \"${EDITION}\", \"version\": \"${VERSION}\"}" > "${PROFILE_DIR}/airootfs/etc/aegis/edition.json"
          
          echo "=== Patching profiledef.sh with Aegis branding (preserving original releng bootmodes) ==="
          EDITION_NAME=$(echo "$EDITION" | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g')
          
          # Patch only specific variables in the original releng profiledef.sh
          # This preserves bootmodes, arch, and all other archiso configurations
          sed -i "s/^iso_name=.*/iso_name=\"aegis-os-${EDITION}\"/" "${PROFILE_DIR}/profiledef.sh"
          sed -i "s/^iso_label=.*/iso_label=\"AEGIS_\$(date --date=\"@\${SOURCE_DATE_EPOCH:-\$(date +%s)}\" +%Y%m)\"/" "${PROFILE_DIR}/profiledef.sh"
          sed -i "s/^iso_publisher=.*/iso_publisher=\"Aegis OS <https:\/\/aegis-os.com>\"/" "${PROFILE_DIR}/profiledef.sh"
          sed -i "s/^iso_application=.*/iso_application=\"Aegis OS ${EDITION_NAME} Edition Live\/Install\"/" "${PROFILE_DIR}/profiledef.sh"
          sed -i "s/^iso_version=.*/iso_version=\"${VERSION}\"/" "${PROFILE_DIR}/profiledef.sh"
          
          # Add Aegis-specific file permissions to the existing file_permissions array
          # Append before the closing parenthesis of file_permissions
          if grep -q 'file_permissions=(' "${PROFILE_DIR}/profiledef.sh"; then
            sed -i '/file_permissions=(/,/)/ {
              /)/ i\  ["/etc/sudoers.d/aegis"]="0:0:440"\n  ["/usr/local/bin/*"]="0:0:755"\n  ["/home/aegis"]="1000:1000:755"
            }' "${PROFILE_DIR}/profiledef.sh" 2>/dev/null || true
          fi
          
          chmod +x "${PROFILE_DIR}/profiledef.sh"
          echo "=== Patched profiledef.sh (original bootmodes preserved) ==="
          cat "${PROFILE_DIR}/profiledef.sh"
          
          echo "=== Creating custom /etc/os-release ==="
          cat > "${PROFILE_DIR}/airootfs/etc/os-release" << OSRELEASE
          NAME="Aegis OS"
          PRETTY_NAME="Aegis OS ${VERSION} (${EDITION_NAME})"
          ID=aegis
          ID_LIKE=arch
          VERSION="${VERSION}"
          VERSION_ID="${VERSION}"
          VERSION_CODENAME="${EDITION}"
          BUILD_ID="${BUILD_DATE}"
          HOME_URL="https://aegis-os.com/"
          DOCUMENTATION_URL="https://aegis-os.com/docs/"
          SUPPORT_URL="https://aegis-os.com/support/"
          BUG_REPORT_URL="https://github.com/aegis-os/aegis-os/issues"
          LOGO=aegis-logo
          ANSI_COLOR="0;36"
          OSRELEASE
          
          echo "=== Creating LightDM configuration ==="
          mkdir -p "${PROFILE_DIR}/airootfs/etc/lightdm"
          cat > "${PROFILE_DIR}/airootfs/etc/lightdm/lightdm.conf" << 'LIGHTDM'
          [Seat:*]
          greeter-session=lightdm-gtk-greeter
          user-session=xfce
          autologin-user=aegis
          autologin-session=xfce
          LIGHTDM
          
          cat > "${PROFILE_DIR}/airootfs/etc/lightdm/lightdm-gtk-greeter.conf" << 'GREETER'
          [greeter]
          theme-name=Aegis-Win10
          icon-theme-name=Papirus
          font-name=Noto Sans 10
          background=/usr/share/backgrounds/aegis/default.jpg
          user-background=false
          position=50%,center 50%,center
          indicators=~host;~spacer;~clock;~spacer;~session;~a11y;~power
          clock-format=%A, %B %d  %H:%M
          GREETER
          
          echo "=== Creating Plymouth configuration ==="
          mkdir -p "${PROFILE_DIR}/airootfs/etc/plymouth"
          cat > "${PROFILE_DIR}/airootfs/etc/plymouth/plymouthd.conf" << 'PLYMOUTH'
          [Daemon]
          Theme=spinner
          ShowDelay=0
          DeviceTimeout=8
          PLYMOUTH
          
          echo "=== Creating custom Aegis Plymouth theme with spinner fallback ==="
          mkdir -p "${PROFILE_DIR}/airootfs/usr/share/plymouth/themes/aegis"
          cat > "${PROFILE_DIR}/airootfs/usr/share/plymouth/themes/aegis/aegis.plymouth" << 'AEGISPLYMOUTH'
          [Plymouth Theme]
          Name=Aegis OS
          Description=Aegis OS boot splash with spinner animation
          ModuleName=script
          
          [script]
          ImageDir=/usr/share/plymouth/themes/aegis
          ScriptFile=/usr/share/plymouth/themes/aegis/aegis.script
          AEGISPLYMOUTH
          
          cat > "${PROFILE_DIR}/airootfs/usr/share/plymouth/themes/aegis/aegis.script" << 'AEGISSCRIPT'
          Window.SetBackgroundTopColor(0.10, 0.10, 0.18);
          Window.SetBackgroundBottomColor(0.09, 0.13, 0.24);
          
          message_sprite = Sprite();
          message_sprite.SetPosition(Window.GetWidth() * 0.5 - 100, Window.GetHeight() * 0.7, 1);
          
          fun message_callback(text) {
              my_image = Image.Text(text, 1, 1, 1);
              message_sprite.SetImage(my_image);
          }
          
          Plymouth.SetMessageFunction(message_callback);
          
          fun display_normal_callback() {
              global.status = "normal";
          }
          
          fun display_password_callback(prompt, bullets) {
              global.status = "password";
          }
          
          Plymouth.SetDisplayNormalFunction(display_normal_callback);
          Plymouth.SetDisplayPasswordFunction(display_password_callback);
          AEGISSCRIPT
          
          echo "=== Creating default user configuration ==="
          mkdir -p "${PROFILE_DIR}/airootfs/etc/skel/.config"
          
          echo "=== Creating custom fastfetch configuration ==="
          mkdir -p "${PROFILE_DIR}/airootfs/etc/skel/.config/fastfetch"
          cat > "${PROFILE_DIR}/airootfs/etc/skel/.config/fastfetch/config.jsonc" << 'FASTFETCH'
          {
            "$schema": "https://github.com/fastfetch-cli/fastfetch/raw/dev/doc/json_schema.json",
            "logo": {
              "type": "builtin",
              "source": "arch"
            },
            "display": {
              "separator": "  "
            },
            "modules": [
              {
                "type": "title",
                "format": "{user-name}@{host-name}"
              },
              "break",
              {
                "type": "os",
                "key": "OS",
                "format": "Aegis OS {version} ({codename})"
              },
              {
                "type": "kernel",
                "key": "Kernel"
              },
              {
                "type": "uptime",
                "key": "Uptime"
              },
              {
                "type": "packages",
                "key": "Packages"
              },
              {
                "type": "shell",
                "key": "Shell"
              },
              {
                "type": "de",
                "key": "Desktop"
              },
              {
                "type": "wm",
                "key": "WM"
              },
              {
                "type": "terminal",
                "key": "Terminal"
              },
              {
                "type": "cpu",
                "key": "CPU"
              },
              {
                "type": "gpu",
                "key": "GPU"
              },
              {
                "type": "memory",
                "key": "Memory"
              },
              "break",
              "colors"
            ]
          }
          FASTFETCH
          
          echo "=== Creating aegis user for autologin ==="
          mkdir -p "${PROFILE_DIR}/airootfs/etc"
          
          cat >> "${PROFILE_DIR}/airootfs/etc/passwd" << 'PASSWD'
          aegis:x:1000:1000:Aegis User:/home/aegis:/bin/bash
          PASSWD
          
          cat >> "${PROFILE_DIR}/airootfs/etc/shadow" << 'SHADOW'
          aegis:$6$rounds=656000$aegis$8iJnYLuJuq5pGQ6xGDZY6NqQ4aVXX.yQQ9dYcR0DfHZJZNvZ3ZZcW0ZZZoZZZcZZZJZZpZZZmZZZnZZZvZZZsZZZxZZZ:19000:0:99999:7:::
          SHADOW
          
          cat >> "${PROFILE_DIR}/airootfs/etc/group" << 'GROUP'
          aegis:x:1000:
          GROUP
          
          cat >> "${PROFILE_DIR}/airootfs/etc/gshadow" << 'GSHADOW'
          aegis:!::
          GSHADOW
          
          mkdir -p "${PROFILE_DIR}/airootfs/home/aegis"
          mkdir -p "${PROFILE_DIR}/airootfs/home/aegis/.config"
          
          echo "=== Copying skel to aegis home ==="
          cp -r "${PROFILE_DIR}/airootfs/etc/skel/." "${PROFILE_DIR}/airootfs/home/aegis/" 2>/dev/null || true
          
          echo "=== Setting ownership via file_permissions in profiledef ==="
          
          echo "=== Configuring sudo for aegis user ==="
          mkdir -p "${PROFILE_DIR}/airootfs/etc/sudoers.d"
          echo "aegis ALL=(ALL) NOPASSWD: ALL" > "${PROFILE_DIR}/airootfs/etc/sudoers.d/aegis"
          chmod 440 "${PROFILE_DIR}/airootfs/etc/sudoers.d/aegis"
          
          echo "=== Creating user setup script ==="
          mkdir -p "${PROFILE_DIR}/airootfs/usr/lib/systemd/system"
          cat > "${PROFILE_DIR}/airootfs/usr/lib/systemd/system/aegis-setup.service" << 'SETUPSVC'
          [Unit]
          Description=Aegis OS First Boot Setup
          After=network.target
          ConditionPathExists=!/var/lib/aegis/setup-complete
          
          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/aegis-first-boot
          RemainAfterExit=yes
          
          [Install]
          WantedBy=multi-user.target
          SETUPSVC
          
          cat > "${PROFILE_DIR}/airootfs/usr/local/bin/aegis-first-boot" << 'FIRSTBOOT'
          #!/bin/bash
          mkdir -p /var/lib/aegis
          chown -R aegis:aegis /home/aegis
          usermod -aG wheel,audio,video,storage,optical,network,power aegis 2>/dev/null || true
          touch /var/lib/aegis/setup-complete
          FIRSTBOOT
          chmod +x "${PROFILE_DIR}/airootfs/usr/local/bin/aegis-first-boot"
          
          echo "=== Setting up systemd services ==="
          mkdir -p "${PROFILE_DIR}/airootfs/etc/systemd/system/multi-user.target.wants"
          mkdir -p "${PROFILE_DIR}/airootfs/etc/systemd/system/graphical.target.wants"
          
          ln -sf /usr/lib/systemd/system/NetworkManager.service \
            "${PROFILE_DIR}/airootfs/etc/systemd/system/multi-user.target.wants/NetworkManager.service" 2>/dev/null || true
          ln -sf /usr/lib/systemd/system/lightdm.service \
            "${PROFILE_DIR}/airootfs/etc/systemd/system/graphical.target.wants/lightdm.service" 2>/dev/null || true
          ln -sf /usr/lib/systemd/system/aegis-setup.service \
            "${PROFILE_DIR}/airootfs/etc/systemd/system/multi-user.target.wants/aegis-setup.service" 2>/dev/null || true
          
          if [ -d "${REPO_DIR}/build-system/overlays/common" ]; then
            echo "Copying common overlays..."
            rsync -av "${REPO_DIR}/build-system/overlays/common/" "${PROFILE_DIR}/airootfs/"
          fi
          if [ "$EDITION" != "freemium" ] && [ -d "${REPO_DIR}/build-system/overlays/pro" ]; then
            echo "Copying pro overlays..."
            rsync -av "${REPO_DIR}/build-system/overlays/pro/" "${PROFILE_DIR}/airootfs/"
          fi
          if [ "$EDITION" = "basic" ] || [ "$EDITION" = "workplace" ]; then
            if [ -d "${REPO_DIR}/build-system/overlays/pro-productivity" ]; then
              echo "Copying pro-productivity overlays..."
              rsync -av "${REPO_DIR}/build-system/overlays/pro-productivity/" "${PROFILE_DIR}/airootfs/"
            fi
          fi
          if [ -d "${REPO_DIR}/build-system/overlays/${EDITION}" ]; then
            echo "Copying ${EDITION} overlays..."
            rsync -av "${REPO_DIR}/build-system/overlays/${EDITION}/" "${PROFILE_DIR}/airootfs/"
          fi
          find "${PROFILE_DIR}/airootfs/usr/local/bin/" -type f -exec chmod +x {} \; 2>/dev/null || true
          
          echo "=== Stripping heredoc indentation from generated files ==="
          # CRITICAL: YAML heredocs preserve leading whitespace - must strip it
          # Note: profiledef.sh is patched via sed, not created via heredoc
          for f in \
            "${PROFILE_DIR}/airootfs/etc/os-release" \
            "${PROFILE_DIR}/airootfs/etc/lightdm/lightdm.conf" \
            "${PROFILE_DIR}/airootfs/etc/lightdm/lightdm-gtk-greeter.conf" \
            "${PROFILE_DIR}/airootfs/etc/plymouth/plymouthd.conf" \
            "${PROFILE_DIR}/airootfs/usr/share/plymouth/themes/aegis/aegis.plymouth" \
            "${PROFILE_DIR}/airootfs/usr/share/plymouth/themes/aegis/aegis.script" \
            "${PROFILE_DIR}/airootfs/etc/skel/.config/fastfetch/config.jsonc" \
            "${PROFILE_DIR}/airootfs/etc/passwd" \
            "${PROFILE_DIR}/airootfs/etc/shadow" \
            "${PROFILE_DIR}/airootfs/etc/group" \
            "${PROFILE_DIR}/airootfs/etc/gshadow" \
            "${PROFILE_DIR}/airootfs/usr/lib/systemd/system/aegis-setup.service" \
            "${PROFILE_DIR}/airootfs/usr/local/bin/aegis-first-boot"; do
            [ -f "$f" ] && sed -i 's/^[[:space:]]*//' "$f"
          done
          
          echo "=== Overlay contents ==="
          ls -la "${PROFILE_DIR}/airootfs/usr/local/bin/" 2>/dev/null || echo "No tools in usr/local/bin"
          echo "=== Profiledef contents ==="
          cat "${PROFILE_DIR}/profiledef.sh"
          echo "=== OS-Release contents ==="
          cat "${PROFILE_DIR}/airootfs/etc/os-release"
          echo "PROFILE_DIR=${PROFILE_DIR}" >> $GITHUB_ENV

      - name: Create package list
        run: |
          set -e
          EDITION="${{ matrix.edition }}"
          PROFILE_DIR="${{ env.PROFILE_DIR }}"
          
          # Base packages for all editions
          cat > "${PROFILE_DIR}/packages.x86_64" << 'BASEPKGS'
          base
          linux
          linux-firmware
          syslinux
          mkinitcpio
          mkinitcpio-archiso
          efibootmgr
          grub
          bash
          libglvnd
          iptables-nft
          pipewire-jack
          xdg-desktop-portal-gtk
          lib32-libglvnd
          chaotic-keyring
          chaotic-mirrorlist
          xfce4
          xfce4-goodies
          lightdm
          lightdm-gtk-greeter
          firefox
          vlc
          libreoffice-fresh
          ttf-dejavu
          ttf-liberation
          noto-fonts
          papirus-icon-theme
          plymouth
          networkmanager
          network-manager-applet
          pipewire
          pipewire-pulse
          pipewire-alsa
          wireplumber
          pavucontrol
          gvfs
          gvfs-mtp
          thunar-volman
          xdg-user-dirs
          fastfetch
          sudo
          bash-completion
          BASEPKGS
          
          # Edition-specific packages
          case "$EDITION" in
            gamer|gamer-ai)
              cat >> "${PROFILE_DIR}/packages.x86_64" << 'GAMERPKGS'
          steam
          lutris
          heroic-games-launcher-bin
          gamemode
          lib32-gamemode
          mangohud
          lib32-mangohud
          gamescope
          vulkan-tools
          lib32-pipewire-jack
          lib32-mesa
          lib32-vulkan-icd-loader
          lib32-gnutls
          lib32-libpulse
          lib32-openal
          lib32-vkd3d
          lib32-libva
          lib32-speex
          lib32-libtheora
          lib32-libvdpau
          lib32-gst-plugins-base-libs
          lib32-libjpeg-turbo
          lib32-libgudev
          lib32-mpg123
          lib32-openssl
          lib32-libusb
          lib32-alsa-lib
          lib32-alsa-plugins
          lib32-libxcomposite
          lib32-libxinerama
          lib32-ncurses
          lib32-ocl-icd
          lib32-libxslt
          lib32-libpng
          lib32-sdl2
          wine
          wine-gecko
          wine-mono
          winetricks
          vkd3d
          wireguard-tools
          obs-studio
          xdotool
          ffmpeg
          game-devices-udev
          retroarch
          mpv
          python-pillow
          GAMERPKGS
              ;;
          esac
          
          case "$EDITION" in
            aidev|gamer-ai)
              cat >> "${PROFILE_DIR}/packages.x86_64" << 'AIDEVPKGS'
          python
          python-pip
          python-virtualenv
          jupyterlab
          docker
          podman
          AIDEVPKGS
              ;;
          esac
          
          [ "$EDITION" = "workplace" ] && cat >> "${PROFILE_DIR}/packages.x86_64" << 'WORKPKGS'
          remmina
          freerdp
          thunderbird
          evolution
          WORKPKGS
          
          [ "$EDITION" = "server" ] && cat >> "${PROFILE_DIR}/packages.x86_64" << 'SERVERPKGS'
          docker
          podman
          nginx
          mariadb
          postgresql
          redis
          SERVERPKGS
          
          # Sort, dedupe, strip whitespace, remove empty lines
          sed 's/^[[:space:]]*//' "${PROFILE_DIR}/packages.x86_64" | sort -u | grep -v '^$' > "${PROFILE_DIR}/packages.x86_64.tmp"
          mv "${PROFILE_DIR}/packages.x86_64.tmp" "${PROFILE_DIR}/packages.x86_64"
          echo "=== Final package list ($(wc -l < "${PROFILE_DIR}/packages.x86_64") packages) ==="
          cat "${PROFILE_DIR}/packages.x86_64"

      - name: Validate packages exist
        run: |
          echo "=== Validating packages exist in repos ==="
          PROFILE_DIR="${{ env.PROFILE_DIR }}"
          
          # Batch validate: pacman -Sp with all packages at once, capture stderr for missing ones
          if pacman -Sp $(cat "${PROFILE_DIR}/packages.x86_64" | tr '\n' ' ') >/dev/null 2>/tmp/pkg_errors.txt; then
            echo "All $(wc -l < "${PROFILE_DIR}/packages.x86_64") packages validated successfully!"
          else
            echo "=== Some packages not found, identifying... ==="
            missing_pkgs=()
            while IFS= read -r pkg; do
              [ -z "$pkg" ] && continue
              if ! pacman -Sp "$pkg" >/dev/null 2>&1; then
                echo "WARNING: $pkg not found"
                missing_pkgs+=("$pkg")
              fi
            done < "${PROFILE_DIR}/packages.x86_64"
            
            if [ "${#missing_pkgs[@]}" -gt 0 ]; then
              echo "Removing ${#missing_pkgs[@]} missing packages..."
              for pkg in "${missing_pkgs[@]}"; do
                sed -i "/^${pkg}$/d" "${PROFILE_DIR}/packages.x86_64"
              done
              echo "Updated: $(wc -l < "${PROFILE_DIR}/packages.x86_64") packages remaining"
            fi
          fi

      - name: Build ISO
        run: |
          set -e
          echo "=== Building ${{ matrix.edition }} ISO ==="
          EDITION="${{ matrix.edition }}"
          PROFILE_DIR="${{ env.PROFILE_DIR }}"
          OUTPUT_DIR="${GITHUB_WORKSPACE}/output"
          WORK_DIR="/tmp/work-${EDITION}"
          
          # Clean output folder - delete any existing ISOs
          rm -rf "${OUTPUT_DIR}"
          mkdir -p "${OUTPUT_DIR}" "${WORK_DIR}"
          
          echo "=== Starting mkarchiso ==="
          echo "Profile: ${PROFILE_DIR}"
          echo "Work dir: ${WORK_DIR}"
          echo "Output: ${OUTPUT_DIR}"
          
          echo "=== Verifying boot configuration files ==="
          echo "--- archiso version ---"
          pacman -Qi archiso | grep -E "^(Name|Version)" || echo "WARNING: archiso not installed"
          echo "--- profiledef.sh bootmodes ---"
          grep -E "bootmodes|install_dir" "${PROFILE_DIR}/profiledef.sh" || echo "WARNING: Could not find bootmodes"
          echo "--- syslinux directory ---"
          ls -la "${PROFILE_DIR}/syslinux/" 2>/dev/null || echo "WARNING: No syslinux directory found"
          echo "--- syslinux config contents ---"
          cat "${PROFILE_DIR}/syslinux/syslinux.cfg" 2>/dev/null | head -20 || echo "INFO: No syslinux.cfg found"
          echo "--- efiboot directory ---"
          ls -laR "${PROFILE_DIR}/efiboot/" 2>/dev/null || echo "WARNING: No efiboot directory found"
          echo "--- efiboot loader.conf ---"
          cat "${PROFILE_DIR}/efiboot/loader/loader.conf" 2>/dev/null || echo "INFO: No loader.conf found"
          echo "--- syslinux package installed ---"
          pacman -Qi syslinux | head -3 || echo "WARNING: syslinux not installed"
          echo "--- /usr/lib/syslinux/bios/ contents ---"
          ls /usr/lib/syslinux/bios/*.bin 2>/dev/null | head -5 || echo "WARNING: No syslinux bios files found"
          
          # Run mkarchiso
          mkarchiso -v -w "${WORK_DIR}" -o "${OUTPUT_DIR}" "${PROFILE_DIR}"
          
          # Find and checksum the ISO
          ISO_FILE=$(ls "${OUTPUT_DIR}"/*.iso 2>/dev/null | head -1)
          if [ -n "$ISO_FILE" ]; then
            sha256sum "${ISO_FILE}" > "${ISO_FILE}.sha256"
            echo "=== ISO Build Complete ==="
            ls -lh "${OUTPUT_DIR}/"
            cat "${ISO_FILE}.sha256"
            
            echo "=== Verifying ISO boot structure ==="
            # Check ISO has MBR boot record
            echo "--- First 512 bytes (MBR area) ---"
            hexdump -C "${ISO_FILE}" | head -33 | tail -4 || echo "hexdump not available"
            
            # Mount and inspect ISO boot files
            mkdir -p /tmp/iso-inspect
            mount -o loop,ro "${ISO_FILE}" /tmp/iso-inspect 2>/dev/null || true
            if [ -d /tmp/iso-inspect ]; then
              echo "--- ISO root contents ---"
              ls -la /tmp/iso-inspect/ 2>/dev/null || true
              echo "--- Boot directory ---"
              ls -la /tmp/iso-inspect/boot/ 2>/dev/null || true
              echo "--- Syslinux directory ---"
              ls -la /tmp/iso-inspect/boot/syslinux/ 2>/dev/null || true
              echo "--- GRUB directory ---"
              ls -la /tmp/iso-inspect/EFI/ 2>/dev/null || true
              echo "--- Install directory (aegis) ---"
              ls -la /tmp/iso-inspect/aegis/ 2>/dev/null || true
              umount /tmp/iso-inspect 2>/dev/null || true
            else
              echo "Could not mount ISO for inspection (this is OK in unprivileged environments)"
            fi
          else
            echo "ERROR: No ISO file was produced!"
            ls -la "${OUTPUT_DIR}/" || true
            exit 1
          fi
          
          # Store ISO path for subsequent steps
          echo "ISO_FILE=${ISO_FILE}" >> $GITHUB_ENV

      - name: Verify ISO boot capability
        run: |
          set -e
          echo "=== Verifying ISO boot capability ==="
          ISO_FILE="${{ env.ISO_FILE }}"
          
          if [ -z "$ISO_FILE" ] || [ ! -f "$ISO_FILE" ]; then
            echo "ERROR: ISO file not found"
            exit 1
          fi
          
          ERRORS=0
          
          # Mount ISO for inspection
          mkdir -p /tmp/iso-verify
          mount -o loop,ro "${ISO_FILE}" /tmp/iso-verify
          
          # Check for required boot files
          echo "=== Checking required boot files ==="
          
          # Check syslinux boot files (BIOS)
          if [ -f /tmp/iso-verify/boot/syslinux/ldlinux.c32 ]; then
            echo "OK: /boot/syslinux/ldlinux.c32 found"
          else
            echo "ERROR: /boot/syslinux/ldlinux.c32 NOT found - BIOS boot will fail"
            ERRORS=$((ERRORS + 1))
          fi
          
          # Check EFI boot file (case-insensitive - file may be BOOTx64.EFI or BOOTX64.EFI)
          EFI_BOOT=$(find /tmp/iso-verify/EFI/BOOT -iname "bootx64.efi" 2>/dev/null | head -1)
          if [ -n "$EFI_BOOT" ]; then
            echo "OK: EFI boot file found at $EFI_BOOT"
          else
            echo "ERROR: /EFI/BOOT/BOOTX64.EFI NOT found - UEFI boot will fail"
            ERRORS=$((ERRORS + 1))
          fi
          
          # List boot directories for debugging
          echo "=== Boot directory structure ==="
          find /tmp/iso-verify/boot -type f 2>/dev/null | head -30 || true
          find /tmp/iso-verify/EFI -type f 2>/dev/null | head -20 || true
          
          umount /tmp/iso-verify
          
          # Verify MBR signature (55 AA at bytes 510-511)
          # Note: Hybrid ISOs (like those from mkarchiso) may have different boot structures
          echo "=== Checking MBR boot signature ==="
          # Read bytes 510-511 and check for boot signature
          MBR_SIG=$(dd if="${ISO_FILE}" bs=1 skip=510 count=2 2>/dev/null | hexdump -e '2/1 "%02x"')
          echo "MBR signature bytes: $MBR_SIG"
          if [ "$MBR_SIG" = "55aa" ]; then
            echo "OK: MBR signature valid (55 AA)"
          else
            # For hybrid ISOs, this might not be present - warn but don't fail
            echo "WARNING: MBR signature not standard (got: $MBR_SIG)"
            echo "This may be expected for hybrid ISO images - checking if ISO is bootable via other methods"
            # Check if it's an El Torito bootable ISO instead
            if file "${ISO_FILE}" | grep -qi "bootable"; then
              echo "OK: ISO is marked as bootable"
            else
              echo "WARNING: Could not confirm ISO bootability"
            fi
          fi
          
          # Fail if any critical checks failed
          if [ "$ERRORS" -gt 0 ]; then
            echo "=== BOOT VERIFICATION FAILED: $ERRORS errors ==="
            exit 1
          fi
          
          echo "=== All boot verification checks passed ==="

      - name: QEMU boot smoke test
        run: |
          echo "=== QEMU Boot Smoke Test (informational) ==="
          ISO_FILE="${{ env.ISO_FILE }}"
          
          if [ -z "$ISO_FILE" ] || [ ! -f "$ISO_FILE" ]; then
            echo "WARNING: ISO file not found, skipping smoke test"
            exit 0
          fi
          
          echo "=== Testing BIOS boot ==="
          timeout 60 qemu-system-x86_64 -nographic -m 2048 -cdrom "${ISO_FILE}" -boot d -serial mon:stdio 2>&1 | tee /tmp/qemu-bios.log || true
          
          echo ""
          echo "=== Testing EFI boot ==="
          if [ -f /usr/share/edk2-ovmf/x64/OVMF.fd ]; then
            timeout 60 qemu-system-x86_64 -nographic -m 2048 -cdrom "${ISO_FILE}" -boot d -bios /usr/share/edk2-ovmf/x64/OVMF.fd -serial mon:stdio 2>&1 | tee /tmp/qemu-uefi.log || true
          else
            echo "WARNING: OVMF not found at expected path, checking alternatives..."
            OVMF_PATH=$(find /usr/share -name "OVMF*.fd" 2>/dev/null | head -1)
            if [ -n "$OVMF_PATH" ]; then
              echo "Using OVMF at: $OVMF_PATH"
              timeout 60 qemu-system-x86_64 -nographic -m 2048 -cdrom "${ISO_FILE}" -boot d -bios "$OVMF_PATH" -serial mon:stdio 2>&1 | tee /tmp/qemu-uefi.log || true
            else
              echo "WARNING: No OVMF firmware found, skipping EFI test"
            fi
          fi
          
          echo ""
          echo "=== Analyzing boot logs ==="
          
          # Check BIOS boot log for kernel loading
          echo "--- BIOS boot analysis ---"
          if grep -qi "linux" /tmp/qemu-bios.log 2>/dev/null; then
            echo "OK: Kernel loading detected in BIOS boot"
          else
            echo "INFO: No kernel loading messages detected in BIOS boot (may need longer timeout)"
          fi
          
          if grep -qi "syslinux\|isolinux" /tmp/qemu-bios.log 2>/dev/null; then
            echo "OK: Bootloader activity detected in BIOS boot"
          else
            echo "INFO: No bootloader messages in BIOS log"
          fi
          
          # Check EFI boot log
          echo "--- EFI boot analysis ---"
          if [ -f /tmp/qemu-uefi.log ]; then
            if grep -qi "linux\|kernel" /tmp/qemu-uefi.log 2>/dev/null; then
              echo "OK: Kernel loading detected in EFI boot"
            else
              echo "INFO: No kernel loading messages detected in EFI boot"
            fi
            
            if grep -qi "systemd-boot\|loader" /tmp/qemu-uefi.log 2>/dev/null; then
              echo "OK: EFI bootloader activity detected"
            else
              echo "INFO: No EFI bootloader messages in log"
            fi
          fi
          
          echo ""
          echo "=== Smoke test complete (informational only) ==="
          echo "Note: QEMU tests run for 60 seconds max; full boot may require more time"

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: aegis-os-${{ matrix.edition }}-iso
          path: |
            output/*.iso
            output/*.sha256
          retention-days: 30
          compression-level: 0

  release:
    name: Create Release
    needs: build-iso
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            artifacts/**/*.iso
            artifacts/**/*.sha256
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
