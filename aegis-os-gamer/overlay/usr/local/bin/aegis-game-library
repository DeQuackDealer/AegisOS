#!/usr/bin/env python3
"""
Aegis Game Library - Unified Game Launcher
Detects and manages games from Steam, GOG, Epic, Heroic, and native Linux
"""

import os
import sys
import json
import subprocess
import threading
from pathlib import Path
from datetime import datetime

try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, Gdk, GdkPixbuf, GLib, Pango
except ImportError:
    print("GTK3 not found. Install with: sudo pacman -S python-gobject gtk3")
    sys.exit(1)

CONFIG_DIR = Path.home() / ".config" / "aegis-games"
CACHE_DIR = Path.home() / ".cache" / "aegis-games"
PROFILES_DIR = Path("/etc/aegis/game-profiles")
SYSTEM_PROFILES = Path("/usr/share/aegis/game-profiles")
OPTIMIZATION_CONFIG = CONFIG_DIR / "optimization.json"

class OptimizationSettings:
    DEFAULT_SETTINGS = {
        "performance": {
            "ram_guardian": False,
            "kernel_profile": "balanced",
            "cpu_governor": "schedutil"
        },
        "input_display": {
            "input_optimizer": False,
            "vrr_freesync": False,
            "hdr": False,
            "integer_scaling": False,
            "frame_generation": "off"
        },
        "audio": {
            "audio_profile": "balanced",
            "spatial_audio": False,
            "spatial_mode": "5.1",
            "noise_suppression": False,
            "noise_strength": 0.7
        },
        "streaming": {
            "replay_buffer": False,
            "replay_duration": 120,
            "ndi_streaming": False,
            "multitrack_audio": False
        }
    }
    
    def __init__(self):
        self.settings = self.load()
    
    def load(self):
        if OPTIMIZATION_CONFIG.exists():
            try:
                with open(OPTIMIZATION_CONFIG) as f:
                    loaded = json.load(f)
                merged = self.DEFAULT_SETTINGS.copy()
                for category in merged:
                    if category in loaded:
                        merged[category].update(loaded[category])
                return merged
            except Exception:
                pass
        return self.DEFAULT_SETTINGS.copy()
    
    def save(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        with open(OPTIMIZATION_CONFIG, "w") as f:
            json.dump(self.settings, f, indent=2)
    
    def get(self, category, key):
        return self.settings.get(category, {}).get(key)
    
    def set(self, category, key, value):
        if category not in self.settings:
            self.settings[category] = {}
        self.settings[category][key] = value
        self.save()
    
    def apply_quick_optimize(self):
        self.settings = {
            "performance": {
                "ram_guardian": True,
                "kernel_profile": "gaming",
                "cpu_governor": "performance"
            },
            "input_display": {
                "input_optimizer": True,
                "vrr_freesync": True,
                "hdr": False,
                "integer_scaling": False,
                "frame_generation": "off"
            },
            "audio": {
                "audio_profile": "competitive",
                "spatial_audio": True,
                "spatial_mode": "hrtf",
                "noise_suppression": True,
                "noise_strength": 0.85
            },
            "streaming": {
                "replay_buffer": True,
                "replay_duration": 120,
                "ndi_streaming": False,
                "multitrack_audio": True
            }
        }
        self.save()
    
    def apply_optimizations(self):
        """Apply gaming optimizations via environment variables.
        
        Note: System services (RAM Guardian, Kernel Optimizer, etc.) should be
        enabled/started via systemd at boot time or via Aegis Settings app.
        This method only sets environment variables for game processes.
        """
        env = {}
        p = self.settings.get("performance", {})
        i = self.settings.get("input_display", {})
        a = self.settings.get("audio", {})
        s = self.settings.get("streaming", {})
        
        if p.get("ram_guardian"):
            env["AEGIS_RAM_GUARDIAN"] = "1"
        
        kernel_profile = p.get("kernel_profile", "balanced")
        env["AEGIS_KERNEL_PROFILE"] = kernel_profile
        
        env["AEGIS_CPU_GOVERNOR"] = p.get("cpu_governor", "schedutil")
        
        if i.get("input_optimizer"):
            env["AEGIS_INPUT_8000HZ"] = "1"
            env["AEGIS_FLAT_ACCEL"] = "1"
        
        if i.get("vrr_freesync"):
            env["ENABLE_VRR"] = "1"
            env["vblank_mode"] = "0"
        
        if i.get("hdr"):
            env["DXVK_HDR"] = "1"
            env["ENABLE_HDR_WSI"] = "1"
        
        fg = i.get("frame_generation", "off")
        if fg == "fsr3":
            env["ENABLE_FSR3_FG"] = "1"
        elif fg == "afmf":
            env["AMD_AFMF"] = "1"
        elif fg == "dlss_fg":
            env["ENABLE_DLSS_FG"] = "1"
        
        audio_profile = a.get("audio_profile", "balanced")
        audio_quantums = {"competitive": "128", "balanced": "512", "quality": "1024", "streaming": "256"}
        env["PIPEWIRE_QUANTUM"] = audio_quantums.get(audio_profile, "512")
        
        if a.get("spatial_audio"):
            env["AEGIS_SPATIAL_AUDIO"] = a.get("spatial_mode", "5.1")
        
        if a.get("noise_suppression"):
            env["AEGIS_NOISE_SUPPRESSION"] = str(a.get("noise_strength", 0.7))
        
        if s.get("replay_buffer"):
            env["AEGIS_REPLAY_BUFFER"] = "1"
            env["AEGIS_REPLAY_DURATION"] = str(s.get("replay_duration", 120))
        
        if s.get("ndi_streaming"):
            env["AEGIS_NDI_STREAMING"] = "1"
        
        if s.get("multitrack_audio"):
            env["AEGIS_MULTITRACK_AUDIO"] = "1"
        
        return env
    
    def is_optimization_enabled(self, category, key):
        """Check if an optimization setting is enabled."""
        return bool(self.settings.get(category, {}).get(key))


class OptimizationSettingsDialog(Gtk.Dialog):
    def __init__(self, parent, settings):
        super().__init__(title="Optimization Settings", transient_for=parent, modal=True)
        self.settings = settings
        self.set_default_size(700, 550)
        self.add_button("Close", Gtk.ResponseType.CLOSE)
        
        self.apply_dialog_css()
        
        content = self.get_content_area()
        content.set_margin_start(20)
        content.set_margin_end(20)
        content.set_margin_top(15)
        content.set_margin_bottom(15)
        
        header_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=15)
        header_box.set_margin_bottom(15)
        
        title_label = Gtk.Label()
        title_label.set_markup('<span font="16" weight="bold" foreground="#3b82f6">Gaming Optimization Settings</span>')
        header_box.pack_start(title_label, False, False, 0)
        
        quick_btn = Gtk.Button(label="‚ö° Quick Optimize")
        quick_btn.get_style_context().add_class("quick-optimize-btn")
        quick_btn.connect("clicked", self.on_quick_optimize)
        quick_btn.set_tooltip_text("Apply recommended gaming settings")
        header_box.pack_end(quick_btn, False, False, 0)
        
        content.pack_start(header_box, False, False, 0)
        
        notebook = Gtk.Notebook()
        notebook.set_tab_pos(Gtk.PositionType.TOP)
        
        notebook.append_page(self.create_performance_tab(), Gtk.Label(label="Performance"))
        notebook.append_page(self.create_input_display_tab(), Gtk.Label(label="Input & Display"))
        notebook.append_page(self.create_audio_tab(), Gtk.Label(label="Audio"))
        notebook.append_page(self.create_streaming_tab(), Gtk.Label(label="Streaming"))
        
        content.pack_start(notebook, True, True, 0)
        self.show_all()
    
    def apply_dialog_css(self):
        css = b"""
        .settings-section {
            background-color: #1e293b;
            border-radius: 8px;
            padding: 15px;
            margin: 8px 0;
        }
        .section-title {
            color: #3b82f6;
            font-weight: bold;
            font-size: 13px;
        }
        .setting-label {
            color: #e2e8f0;
            font-size: 12px;
        }
        .status-active {
            color: #22c55e;
        }
        .status-inactive {
            color: #64748b;
        }
        .quick-optimize-btn {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            padding: 8px 15px;
        }
        .quick-optimize-btn:hover {
            background: linear-gradient(135deg, #d97706, #b45309);
        }
        notebook tab {
            background-color: #1e293b;
            color: #94a3b8;
            padding: 8px 15px;
        }
        notebook tab:checked {
            background-color: #334155;
            color: #3b82f6;
        }
        """
        provider = Gtk.CssProvider()
        provider.load_from_data(css)
        Gtk.StyleContext.add_provider_for_screen(
            Gdk.Screen.get_default(),
            provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION + 1
        )
    
    def create_status_indicator(self, active):
        label = Gtk.Label()
        if active:
            label.set_markup('<span foreground="#22c55e">‚óè</span>')
        else:
            label.set_markup('<span foreground="#64748b">‚óè</span>')
        return label
    
    def create_section(self, title):
        frame = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        frame.get_style_context().add_class("settings-section")
        
        title_label = Gtk.Label()
        title_label.set_markup(f'<span weight="bold" foreground="#3b82f6">{title}</span>')
        title_label.set_halign(Gtk.Align.START)
        frame.pack_start(title_label, False, False, 0)
        
        return frame
    
    def create_toggle_row(self, label_text, category, key, description=""):
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        row.set_margin_top(5)
        
        active = self.settings.get(category, key) or False
        status = self.create_status_indicator(active)
        row.pack_start(status, False, False, 0)
        
        label_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        label = Gtk.Label(label=label_text)
        label.set_halign(Gtk.Align.START)
        label.get_style_context().add_class("setting-label")
        label_box.pack_start(label, False, False, 0)
        
        if description:
            desc = Gtk.Label()
            desc.set_markup(f'<span font="10" foreground="#64748b">{description}</span>')
            desc.set_halign(Gtk.Align.START)
            label_box.pack_start(desc, False, False, 0)
        
        row.pack_start(label_box, True, True, 0)
        
        switch = Gtk.Switch()
        switch.set_active(active)
        switch.set_valign(Gtk.Align.CENTER)
        switch.connect("state-set", self.on_toggle_changed, category, key, status)
        row.pack_end(switch, False, False, 0)
        
        return row
    
    def create_combo_row(self, label_text, category, key, options, description=""):
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        row.set_margin_top(5)
        
        label_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        label = Gtk.Label(label=label_text)
        label.set_halign(Gtk.Align.START)
        label.get_style_context().add_class("setting-label")
        label_box.pack_start(label, False, False, 0)
        
        if description:
            desc = Gtk.Label()
            desc.set_markup(f'<span font="10" foreground="#64748b">{description}</span>')
            desc.set_halign(Gtk.Align.START)
            label_box.pack_start(desc, False, False, 0)
        
        row.pack_start(label_box, True, True, 0)
        
        combo = Gtk.ComboBoxText()
        current = self.settings.get(category, key)
        active_idx = 0
        for i, (value, display) in enumerate(options):
            combo.append(value, display)
            if value == current:
                active_idx = i
        combo.set_active(active_idx)
        combo.connect("changed", self.on_combo_changed, category, key)
        row.pack_end(combo, False, False, 0)
        
        return row
    
    def create_slider_row(self, label_text, category, key, min_val, max_val, step, description=""):
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        row.set_margin_top(5)
        
        label_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        label = Gtk.Label(label=label_text)
        label.set_halign(Gtk.Align.START)
        label.get_style_context().add_class("setting-label")
        label_box.pack_start(label, False, False, 0)
        
        if description:
            desc = Gtk.Label()
            desc.set_markup(f'<span font="10" foreground="#64748b">{description}</span>')
            desc.set_halign(Gtk.Align.START)
            label_box.pack_start(desc, False, False, 0)
        
        row.pack_start(label_box, True, True, 0)
        
        current = self.settings.get(category, key) or min_val
        
        value_label = Gtk.Label(label=str(int(current) if step >= 1 else f"{current:.1f}"))
        value_label.set_width_chars(6)
        
        adjustment = Gtk.Adjustment(value=current, lower=min_val, upper=max_val, step_increment=step)
        scale = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL, adjustment=adjustment)
        scale.set_draw_value(False)
        scale.set_size_request(150, -1)
        scale.connect("value-changed", self.on_slider_changed, category, key, value_label, step)
        
        row.pack_end(value_label, False, False, 0)
        row.pack_end(scale, False, False, 5)
        
        return row
    
    def create_performance_tab(self):
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_start(15)
        box.set_margin_end(15)
        box.set_margin_top(15)
        box.set_margin_bottom(15)
        
        ram_section = self.create_section("RAM Guardian")
        ram_section.pack_start(
            self.create_toggle_row("RAM Guardian", "performance", "ram_guardian", 
                                   "Auto-clear memory caches for maximum game RAM"),
            False, False, 0
        )
        box.pack_start(ram_section, False, False, 0)
        
        kernel_section = self.create_section("Kernel Optimizer")
        kernel_section.pack_start(
            self.create_combo_row("Optimization Profile", "performance", "kernel_profile", [
                ("gaming", "Gaming - High performance"),
                ("competitive", "Competitive - Maximum FPS"),
                ("balanced", "Balanced - Normal use"),
                ("power_saving", "Power Saving - Battery mode")
            ], "Core isolation, tickless mode, scheduler tuning"),
            False, False, 0
        )
        box.pack_start(kernel_section, False, False, 0)
        
        cpu_section = self.create_section("CPU Governor")
        cpu_section.pack_start(
            self.create_combo_row("CPU Frequency Governor", "performance", "cpu_governor", [
                ("performance", "Performance - Max frequency"),
                ("schedutil", "Schedutil - Dynamic scaling"),
                ("powersave", "Powersave - Min frequency")
            ], "Controls CPU frequency scaling behavior"),
            False, False, 0
        )
        box.pack_start(cpu_section, False, False, 0)
        
        scroll.add(box)
        return scroll
    
    def create_input_display_tab(self):
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_start(15)
        box.set_margin_end(15)
        box.set_margin_top(15)
        box.set_margin_bottom(15)
        
        input_section = self.create_section("Input Optimizer")
        input_section.pack_start(
            self.create_toggle_row("Input Optimizer", "input_display", "input_optimizer",
                                   "8000Hz USB polling, flat mouse acceleration"),
            False, False, 0
        )
        box.pack_start(input_section, False, False, 0)
        
        display_section = self.create_section("Display Optimizer")
        display_section.pack_start(
            self.create_toggle_row("VRR / FreeSync", "input_display", "vrr_freesync",
                                   "Variable Refresh Rate for tear-free gaming"),
            False, False, 0
        )
        display_section.pack_start(
            self.create_toggle_row("HDR", "input_display", "hdr",
                                   "High Dynamic Range output"),
            False, False, 0
        )
        display_section.pack_start(
            self.create_toggle_row("Integer Scaling", "input_display", "integer_scaling",
                                   "Pixel-perfect scaling for retro games"),
            False, False, 0
        )
        box.pack_start(display_section, False, False, 0)
        
        fg_section = self.create_section("Frame Generation")
        fg_section.pack_start(
            self.create_combo_row("Technology", "input_display", "frame_generation", [
                ("off", "Off - Disabled"),
                ("fsr3", "FSR 3 Frame Generation"),
                ("afmf", "AMD AFMF (Driver-level)"),
                ("dlss_fg", "DLSS Frame Generation")
            ], "AI-powered frame interpolation"),
            False, False, 0
        )
        box.pack_start(fg_section, False, False, 0)
        
        scroll.add(box)
        return scroll
    
    def create_audio_tab(self):
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_start(15)
        box.set_margin_end(15)
        box.set_margin_top(15)
        box.set_margin_bottom(15)
        
        latency_section = self.create_section("Audio Latency Profile")
        latency_section.pack_start(
            self.create_combo_row("Profile", "audio", "audio_profile", [
                ("competitive", "Competitive - 2.7ms latency"),
                ("balanced", "Balanced - 10.7ms latency"),
                ("quality", "Quality - 21.3ms latency"),
                ("streaming", "Streaming - 5.3ms latency")
            ], "PipeWire quantum/buffer size"),
            False, False, 0
        )
        box.pack_start(latency_section, False, False, 0)
        
        spatial_section = self.create_section("Spatial Audio")
        spatial_section.pack_start(
            self.create_toggle_row("Spatial Audio", "audio", "spatial_audio",
                                   "Virtual surround sound for headphones"),
            False, False, 0
        )
        spatial_section.pack_start(
            self.create_combo_row("Spatial Mode", "audio", "spatial_mode", [
                ("5.1", "Virtual 5.1 Surround"),
                ("7.1", "Virtual 7.1 Surround"),
                ("hrtf", "HRTF Binaural")
            ], "Surround sound rendering method"),
            False, False, 0
        )
        box.pack_start(spatial_section, False, False, 0)
        
        noise_section = self.create_section("AI Noise Suppression")
        noise_section.pack_start(
            self.create_toggle_row("Noise Suppression", "audio", "noise_suppression",
                                   "RNNoise AI-powered microphone cleanup"),
            False, False, 0
        )
        noise_section.pack_start(
            self.create_slider_row("Suppression Strength", "audio", "noise_strength", 
                                   0.1, 1.0, 0.1, "0.1 = light, 1.0 = aggressive"),
            False, False, 0
        )
        box.pack_start(noise_section, False, False, 0)
        
        scroll.add(box)
        return scroll
    
    def create_streaming_tab(self):
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box.set_margin_start(15)
        box.set_margin_end(15)
        box.set_margin_top(15)
        box.set_margin_bottom(15)
        
        replay_section = self.create_section("StreamForge Replay Buffer")
        replay_section.pack_start(
            self.create_toggle_row("Replay Buffer", "streaming", "replay_buffer",
                                   "Always-on recording with hotkey save (F9)"),
            False, False, 0
        )
        replay_section.pack_start(
            self.create_slider_row("Buffer Duration (seconds)", "streaming", "replay_duration",
                                   30, 300, 30, "30s - 5 minutes of replay history"),
            False, False, 0
        )
        box.pack_start(replay_section, False, False, 0)
        
        ndi_section = self.create_section("NDI Streaming")
        ndi_section.pack_start(
            self.create_toggle_row("NDI Network Streaming", "streaming", "ndi_streaming",
                                   "Stream to second PC for dual-PC setup"),
            False, False, 0
        )
        box.pack_start(ndi_section, False, False, 0)
        
        audio_section = self.create_section("Multi-Track Audio")
        audio_section.pack_start(
            self.create_toggle_row("Multi-Track Recording", "streaming", "multitrack_audio",
                                   "Separate audio tracks for game/voice/music"),
            False, False, 0
        )
        box.pack_start(audio_section, False, False, 0)
        
        scroll.add(box)
        return scroll
    
    def on_toggle_changed(self, switch, state, category, key, status_indicator):
        self.settings.set(category, key, state)
        if state:
            status_indicator.set_markup('<span foreground="#22c55e">‚óè</span>')
        else:
            status_indicator.set_markup('<span foreground="#64748b">‚óè</span>')
        return False
    
    def on_combo_changed(self, combo, category, key):
        value = combo.get_active_id()
        if value:
            self.settings.set(category, key, value)
    
    def on_slider_changed(self, scale, category, key, value_label, step):
        value = scale.get_value()
        self.settings.set(category, key, value)
        if step >= 1:
            value_label.set_text(str(int(value)))
        else:
            value_label.set_text(f"{value:.1f}")
    
    def on_quick_optimize(self, button):
        self.settings.apply_quick_optimize()
        dialog = Gtk.MessageDialog(
            transient_for=self,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.OK,
            text="Quick Optimize Applied!"
        )
        dialog.format_secondary_text(
            "Recommended gaming settings have been applied:\n\n"
            "‚Ä¢ RAM Guardian: Enabled\n"
            "‚Ä¢ Kernel Profile: Gaming\n"
            "‚Ä¢ CPU Governor: Performance\n"
            "‚Ä¢ Input Optimizer: Enabled (8000Hz)\n"
            "‚Ä¢ VRR/FreeSync: Enabled\n"
            "‚Ä¢ Audio: Competitive (2.7ms)\n"
            "‚Ä¢ Spatial Audio: HRTF\n"
            "‚Ä¢ Noise Suppression: Enabled\n"
            "‚Ä¢ Replay Buffer: 2 minutes\n\n"
            "Close and reopen settings to see updated values."
        )
        dialog.run()
        dialog.destroy()
        self.destroy()


class GameProfile:
    def __init__(self, game_id):
        self.game_id = game_id
        self.profile = self.load_profile()
    
    def load_profile(self):
        for profile_dir in [PROFILES_DIR, SYSTEM_PROFILES, CONFIG_DIR / "profiles"]:
            profile_file = profile_dir / f"{self.game_id}.json"
            if profile_file.exists():
                with open(profile_file) as f:
                    return json.load(f)
        return self.default_profile()
    
    def default_profile(self):
        return {
            "name": "Default",
            "gamemode": True,
            "mangohud": True,
            "fsync": True,
            "esync": True,
            "shader_cache": True,
            "cpu_governor": "performance",
            "priority": "high",
            "env": {}
        }
    
    def get_env(self):
        env = os.environ.copy()
        p = self.profile
        
        if p.get("gamemode"):
            env["ENABLE_GAMEMODE"] = "1"
        if p.get("mangohud"):
            env["MANGOHUD"] = "1"
            env["MANGOHUD_CONFIG"] = "cpu_stats,gpu_stats,fps,frametime,frame_timing"
        if p.get("fsync"):
            env["WINEFSYNC"] = "1"
        if p.get("esync"):
            env["WINEESYNC"] = "1"
        if p.get("shader_cache"):
            env["DXVK_STATE_CACHE"] = "1"
            env["VKD3D_SHADER_CACHE"] = "1"
        
        env["__GL_THREADED_OPTIMIZATIONS"] = "1"
        env["mesa_glthread"] = "true"
        env["RADV_PERFTEST"] = "gpl"
        
        env.update(p.get("env", {}))
        return env

class Game:
    def __init__(self, name, exe_path, source, icon=None, appid=None):
        self.name = name
        self.exe_path = exe_path
        self.source = source
        self.icon = icon
        self.appid = appid
        self.last_played = None
        self.play_time = 0
        self.profile = None
    
    def to_dict(self):
        return {
            "name": self.name,
            "exe_path": str(self.exe_path),
            "source": self.source,
            "icon": self.icon,
            "appid": self.appid,
            "last_played": self.last_played,
            "play_time": self.play_time
        }
    
    @classmethod
    def from_dict(cls, data):
        game = cls(
            data["name"],
            data["exe_path"],
            data["source"],
            data.get("icon"),
            data.get("appid")
        )
        game.last_played = data.get("last_played")
        game.play_time = data.get("play_time", 0)
        return game

class GameScanner:
    def __init__(self):
        self.games = []
    
    def scan_steam(self):
        steam_paths = [
            Path.home() / ".steam/steam/steamapps",
            Path.home() / ".local/share/Steam/steamapps",
            Path("/home") / os.environ.get("USER", "") / ".steam/steam/steamapps"
        ]
        
        for steam_path in steam_paths:
            if not steam_path.exists():
                continue
            
            for acf in steam_path.glob("appmanifest_*.acf"):
                try:
                    with open(acf) as f:
                        content = f.read()
                    
                    appid = self._parse_vdf_value(content, "appid")
                    name = self._parse_vdf_value(content, "name")
                    installdir = self._parse_vdf_value(content, "installdir")
                    
                    if name and installdir:
                        game_path = steam_path / "common" / installdir
                        icon = f"steam_icon_{appid}" if appid else None
                        
                        self.games.append(Game(
                            name=name,
                            exe_path=str(game_path),
                            source="Steam",
                            icon=icon,
                            appid=appid
                        ))
                except Exception:
                    pass
    
    def scan_heroic(self):
        heroic_path = Path.home() / ".config/heroic/GamesConfig"
        installed_path = Path.home() / ".config/heroic/lib-cache/library.json"
        
        if installed_path.exists():
            try:
                with open(installed_path) as f:
                    data = json.load(f)
                
                for game in data.get("library", []):
                    if game.get("is_installed"):
                        self.games.append(Game(
                            name=game.get("title", "Unknown"),
                            exe_path=game.get("install_path", ""),
                            source="Epic/Heroic",
                            appid=game.get("app_name")
                        ))
            except Exception:
                pass
    
    def scan_lutris(self):
        lutris_db = Path.home() / ".local/share/lutris/pga.db"
        if not lutris_db.exists():
            return
        
        try:
            import sqlite3
            conn = sqlite3.connect(str(lutris_db))
            cursor = conn.cursor()
            cursor.execute("SELECT name, slug, directory, runner FROM games WHERE installed = 1")
            
            for name, slug, directory, runner in cursor.fetchall():
                self.games.append(Game(
                    name=name,
                    exe_path=directory or "",
                    source=f"Lutris ({runner})",
                    appid=slug
                ))
            conn.close()
        except Exception:
            pass
    
    def scan_gog(self):
        gog_path = Path.home() / "GOG Games"
        if gog_path.exists():
            for game_dir in gog_path.iterdir():
                if game_dir.is_dir():
                    start_script = game_dir / "start.sh"
                    if start_script.exists():
                        self.games.append(Game(
                            name=game_dir.name.replace("_", " "),
                            exe_path=str(start_script),
                            source="GOG"
                        ))
    
    def scan_native(self):
        native_paths = [
            Path.home() / "Games",
            Path.home() / ".local/share/applications"
        ]
        
        for path in native_paths:
            if not path.exists():
                continue
            
            for desktop in path.glob("*.desktop"):
                try:
                    with open(desktop) as f:
                        content = f.read()
                    
                    if "Game" in content or "game" in content.lower():
                        name = self._parse_desktop_value(content, "Name")
                        exe = self._parse_desktop_value(content, "Exec")
                        icon = self._parse_desktop_value(content, "Icon")
                        
                        if name and exe:
                            self.games.append(Game(
                                name=name,
                                exe_path=exe,
                                source="Native",
                                icon=icon
                            ))
                except Exception:
                    pass
    
    def scan_sdcard(self):
        """Scan SD cards and external drives for games"""
        sd_paths = self._detect_removable_drives()
        
        for mount_point in sd_paths:
            self._scan_steam_library(mount_point)
            self._scan_portable_games(mount_point)
    
    def _detect_removable_drives(self):
        """Detect mounted SD cards and USB drives"""
        removable = []
        
        media_paths = [
            Path("/run/media") / os.environ.get("USER", ""),
            Path("/media") / os.environ.get("USER", ""),
            Path("/media"),
            Path("/mnt")
        ]
        
        for media_path in media_paths:
            if media_path.exists():
                for drive in media_path.iterdir():
                    if drive.is_dir() and drive.name not in ["cdrom", "floppy"]:
                        removable.append(drive)
        
        return removable
    
    def _scan_steam_library(self, mount_point):
        """Scan for Steam library on external drive"""
        steam_paths = [
            mount_point / "SteamLibrary/steamapps",
            mount_point / "steam/steamapps",
            mount_point / "Steam/steamapps"
        ]
        
        for steam_path in steam_paths:
            if steam_path.exists():
                for acf in steam_path.glob("appmanifest_*.acf"):
                    try:
                        with open(acf) as f:
                            content = f.read()
                        
                        appid = self._parse_vdf_value(content, "appid")
                        name = self._parse_vdf_value(content, "name")
                        installdir = self._parse_vdf_value(content, "installdir")
                        
                        if name and installdir:
                            game_path = steam_path / "common" / installdir
                            self.games.append(Game(
                                name=f"{name} [SD]",
                                exe_path=str(game_path),
                                source="Steam (SD Card)",
                                appid=appid
                            ))
                    except Exception:
                        pass
    
    def _scan_portable_games(self, mount_point):
        """Scan for portable games on external drive"""
        game_folders = [
            mount_point / "Games",
            mount_point / "PortableGames",
            mount_point / "ROMs"
        ]
        
        for folder in game_folders:
            if folder.exists():
                for item in folder.iterdir():
                    if item.is_dir():
                        exe_files = list(item.glob("*.sh")) + list(item.glob("*.AppImage"))
                        for exe in exe_files:
                            self.games.append(Game(
                                name=f"{item.name} [SD]",
                                exe_path=str(exe),
                                source="Portable (SD Card)"
                            ))
    
    def scan_all(self):
        self.games = []
        self.scan_steam()
        self.scan_heroic()
        self.scan_lutris()
        self.scan_gog()
        self.scan_native()
        self.scan_sdcard()
        return self.games
    
    def _parse_vdf_value(self, content, key):
        import re
        match = re.search(rf'"{key}"\s+"([^"]+)"', content, re.IGNORECASE)
        return match.group(1) if match else None
    
    def _parse_desktop_value(self, content, key):
        for line in content.split("\n"):
            if line.startswith(f"{key}="):
                return line.split("=", 1)[1].strip()
        return None

class AegisGameLibrary(Gtk.Window):
    def __init__(self):
        super().__init__(title="Aegis Game Library")
        self.set_default_size(1200, 800)
        self.set_position(Gtk.WindowPosition.CENTER)
        
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        
        self.games = []
        self.scanner = GameScanner()
        self.current_filter = "all"
        self.running_game = None
        self.optimization_settings = OptimizationSettings()
        
        self.setup_css()
        self.setup_ui()
        self.load_games()
    
    def setup_css(self):
        css = b"""
        window {
            background-color: #0f172a;
        }
        .sidebar {
            background-color: #1e293b;
        }
        .game-card {
            background-color: #1e293b;
            border-radius: 8px;
            padding: 10px;
        }
        .game-card:hover {
            background-color: #334155;
        }
        .game-title {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
        .game-source {
            color: #64748b;
            font-size: 11px;
        }
        .play-button {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 20px;
            font-weight: bold;
        }
        .play-button:hover {
            background: linear-gradient(135deg, #16a34a, #15803d);
        }
        .header-bar {
            background-color: #0f172a;
            border-bottom: 1px solid #334155;
        }
        .search-entry {
            background-color: #1e293b;
            color: white;
            border: 1px solid #334155;
            border-radius: 6px;
            padding: 8px;
        }
        .filter-button {
            background-color: transparent;
            color: #94a3b8;
            border: none;
            padding: 10px 15px;
        }
        .filter-button:checked {
            color: #3b82f6;
            border-bottom: 2px solid #3b82f6;
        }
        .stats-label {
            color: #64748b;
            font-size: 12px;
        }
        .settings-button {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 15px;
            font-weight: bold;
            margin-right: 10px;
        }
        .settings-button:hover {
            background: linear-gradient(135deg, #4f46e5, #4338ca);
        }
        """
        provider = Gtk.CssProvider()
        provider.load_from_data(css)
        Gtk.StyleContext.add_provider_for_screen(
            Gdk.Screen.get_default(),
            provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )
    
    def setup_ui(self):
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.add(main_box)
        
        header = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=15)
        header.set_margin_start(20)
        header.set_margin_end(20)
        header.set_margin_top(15)
        header.set_margin_bottom(15)
        header.get_style_context().add_class("header-bar")
        
        logo = Gtk.Label(label="AEGIS GAME LIBRARY")
        logo.set_markup('<span font="18" weight="bold" foreground="#3b82f6">AEGIS</span> <span font="18" foreground="white">GAME LIBRARY</span>')
        header.pack_start(logo, False, False, 0)
        
        self.search = Gtk.Entry()
        self.search.set_placeholder_text("Search games...")
        self.search.set_width_chars(30)
        self.search.get_style_context().add_class("search-entry")
        self.search.connect("changed", self.on_search_changed)
        header.pack_start(self.search, True, True, 50)
        
        settings_btn = Gtk.Button(label="‚öôÔ∏è Settings")
        settings_btn.get_style_context().add_class("settings-button")
        settings_btn.connect("clicked", self.on_settings_clicked)
        header.pack_end(settings_btn, False, False, 0)
        
        scan_btn = Gtk.Button(label="Scan Games")
        scan_btn.connect("clicked", self.on_scan_clicked)
        header.pack_end(scan_btn, False, False, 0)
        
        main_box.pack_start(header, False, False, 0)
        
        filter_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        filter_box.set_margin_start(20)
        filter_box.set_margin_bottom(10)
        
        filters = [("All", "all"), ("Steam", "Steam"), ("Epic/Heroic", "Epic"), 
                   ("Lutris", "Lutris"), ("GOG", "GOG"), ("Native", "Native")]
        
        self.filter_buttons = {}
        for label, source in filters:
            btn = Gtk.ToggleButton(label=label)
            btn.get_style_context().add_class("filter-button")
            btn.connect("toggled", self.on_filter_toggled, source)
            filter_box.pack_start(btn, False, False, 0)
            self.filter_buttons[source] = btn
        
        self.filter_buttons["all"].set_active(True)
        
        self.stats_label = Gtk.Label()
        self.stats_label.get_style_context().add_class("stats-label")
        filter_box.pack_end(self.stats_label, False, False, 20)
        
        main_box.pack_start(filter_box, False, False, 0)
        
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        
        self.games_grid = Gtk.FlowBox()
        self.games_grid.set_valign(Gtk.Align.START)
        self.games_grid.set_max_children_per_line(6)
        self.games_grid.set_min_children_per_line(2)
        self.games_grid.set_selection_mode(Gtk.SelectionMode.NONE)
        self.games_grid.set_homogeneous(True)
        self.games_grid.set_column_spacing(15)
        self.games_grid.set_row_spacing(15)
        self.games_grid.set_margin_start(20)
        self.games_grid.set_margin_end(20)
        self.games_grid.set_margin_bottom(20)
        
        scroll.add(self.games_grid)
        main_box.pack_start(scroll, True, True, 0)
    
    def load_games(self):
        cache_file = CACHE_DIR / "games.json"
        if cache_file.exists():
            try:
                with open(cache_file) as f:
                    data = json.load(f)
                self.games = [Game.from_dict(g) for g in data]
                self.refresh_grid()
            except Exception:
                self.scan_games()
        else:
            self.scan_games()
    
    def save_games(self):
        cache_file = CACHE_DIR / "games.json"
        with open(cache_file, "w") as f:
            json.dump([g.to_dict() for g in self.games], f, indent=2)
    
    def scan_games(self):
        def do_scan():
            self.games = self.scanner.scan_all()
            GLib.idle_add(self.on_scan_complete)
        
        threading.Thread(target=do_scan, daemon=True).start()
    
    def on_scan_complete(self):
        self.save_games()
        self.refresh_grid()
    
    def refresh_grid(self):
        for child in self.games_grid.get_children():
            self.games_grid.remove(child)
        
        search_text = self.search.get_text().lower()
        filtered = []
        
        for game in self.games:
            if search_text and search_text not in game.name.lower():
                continue
            if self.current_filter != "all" and self.current_filter not in game.source:
                continue
            filtered.append(game)
        
        filtered.sort(key=lambda g: g.name.lower())
        
        for game in filtered:
            card = self.create_game_card(game)
            self.games_grid.add(card)
        
        self.games_grid.show_all()
        self.stats_label.set_text(f"{len(filtered)} games")
    
    def create_game_card(self, game):
        card = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        card.get_style_context().add_class("game-card")
        card.set_size_request(180, 220)
        
        icon_box = Gtk.Box()
        icon_box.set_size_request(160, 120)
        icon_box.set_halign(Gtk.Align.CENTER)
        
        icon_label = Gtk.Label()
        icon_label.set_markup(f'<span font="48" foreground="#3b82f6">üéÆ</span>')
        icon_box.add(icon_label)
        card.pack_start(icon_box, False, False, 0)
        
        title = Gtk.Label(label=game.name)
        title.get_style_context().add_class("game-title")
        title.set_ellipsize(Pango.EllipsizeMode.END)
        title.set_max_width_chars(20)
        title.set_halign(Gtk.Align.START)
        card.pack_start(title, False, False, 0)
        
        source = Gtk.Label(label=game.source)
        source.get_style_context().add_class("game-source")
        source.set_halign(Gtk.Align.START)
        card.pack_start(source, False, False, 0)
        
        play_btn = Gtk.Button(label="‚ñ∂ PLAY")
        play_btn.get_style_context().add_class("play-button")
        play_btn.connect("clicked", self.on_play_clicked, game)
        card.pack_end(play_btn, False, False, 5)
        
        return card
    
    def on_play_clicked(self, button, game):
        self.launch_game(game)
    
    def launch_game(self, game):
        profile = GameProfile(game.appid or game.name.lower().replace(" ", "_"))
        env = profile.get_env()
        
        optimization_env = self.optimization_settings.apply_optimizations()
        env.update(optimization_env)
        
        subprocess.run(["systemctl", "--user", "start", "aegis-gaming-mode.target"], 
                       capture_output=True)
        
        if game.source == "Steam" and game.appid:
            cmd = ["steam", f"steam://rungameid/{game.appid}"]
        elif game.source == "Epic/Heroic":
            cmd = ["heroic", "--no-gui", game.appid or game.exe_path]
        elif os.path.isfile(game.exe_path):
            cmd = [game.exe_path]
        else:
            cmd = ["xdg-open", game.exe_path]
        
        try:
            if profile.profile.get("gamemode"):
                cmd = ["gamemoderun"] + cmd
            
            subprocess.Popen(cmd, env=env, start_new_session=True)
            
            game.last_played = datetime.now().isoformat()
            self.save_games()
        except Exception as e:
            dialog = Gtk.MessageDialog(
                transient_for=self,
                flags=0,
                message_type=Gtk.MessageType.ERROR,
                buttons=Gtk.ButtonsType.OK,
                text=f"Failed to launch game: {e}"
            )
            dialog.run()
            dialog.destroy()
    
    def on_search_changed(self, entry):
        self.refresh_grid()
    
    def on_filter_toggled(self, button, source):
        if button.get_active():
            for s, btn in self.filter_buttons.items():
                if s != source:
                    btn.set_active(False)
            self.current_filter = source
            self.refresh_grid()
    
    def on_settings_clicked(self, button):
        dialog = OptimizationSettingsDialog(self, self.optimization_settings)
        dialog.run()
        dialog.destroy()
        self.optimization_settings = OptimizationSettings()
    
    def on_scan_clicked(self, button):
        button.set_sensitive(False)
        button.set_label("Scanning...")
        
        def do_scan():
            self.games = self.scanner.scan_all()
            GLib.idle_add(finish_scan)
        
        def finish_scan():
            self.save_games()
            self.refresh_grid()
            button.set_sensitive(True)
            button.set_label("Scan Games")
        
        threading.Thread(target=do_scan, daemon=True).start()

class ConsoleMode(Gtk.Window):
    """Fullscreen console mode with controller support (like Steam Big Picture)"""
    
    def __init__(self, games):
        super().__init__(title="Aegis Game Library - Console Mode")
        self.games = games
        self.selected_index = 0
        self.controller_thread = None
        self.running = True
        self.optimization_settings = OptimizationSettings()
        
        self.fullscreen()
        self.set_decorated(False)
        self.apply_console_css()
        self.setup_console_ui()
        self.setup_keyboard_controls()
        self.start_controller_input()
        
        self.connect("destroy", self.on_exit)
    
    def apply_console_css(self):
        css = """
        .console-bg {
            background: linear-gradient(180deg, #0a0e1a 0%, #1a1f2e 50%, #0f1320 100%);
        }
        .console-title {
            font-size: 48px;
            font-weight: bold;
            color: #3b82f6;
            margin: 40px;
        }
        .game-tile {
            background: linear-gradient(135deg, #1e293b, #334155);
            border-radius: 16px;
            border: 3px solid transparent;
            padding: 20px;
            min-width: 280px;
            min-height: 200px;
            margin: 15px;
        }
        .game-tile:selected, .game-tile.selected {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #1e3a5f, #2d4a6f);
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
        }
        .game-tile-title {
            font-size: 24px;
            font-weight: bold;
            color: white;
        }
        .game-tile-source {
            font-size: 16px;
            color: #94a3b8;
        }
        .console-hint {
            font-size: 18px;
            color: #64748b;
            margin: 20px;
        }
        .play-hint {
            font-size: 32px;
            color: #22c55e;
            font-weight: bold;
        }
        """
        provider = Gtk.CssProvider()
        provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_screen(
            Gdk.Screen.get_default(),
            provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )
    
    def setup_console_ui(self):
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        main_box.get_style_context().add_class("console-bg")
        self.add(main_box)
        
        header = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        header.set_margin_top(30)
        header.set_margin_start(50)
        header.set_margin_end(50)
        
        title = Gtk.Label()
        title.set_markup('<span font="36" weight="bold" foreground="#3b82f6">AEGIS</span> <span font="36" foreground="white">GAME LIBRARY</span>')
        header.pack_start(title, False, False, 0)
        
        exit_hint = Gtk.Label()
        exit_hint.set_markup('<span foreground="#64748b">Press ESC or SELECT+START to exit</span>')
        header.pack_end(exit_hint, False, False, 0)
        
        main_box.pack_start(header, False, False, 0)
        
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        
        self.games_box = Gtk.FlowBox()
        self.games_box.set_valign(Gtk.Align.START)
        self.games_box.set_max_children_per_line(5)
        self.games_box.set_min_children_per_line(3)
        self.games_box.set_selection_mode(Gtk.SelectionMode.SINGLE)
        self.games_box.set_homogeneous(True)
        self.games_box.set_column_spacing(20)
        self.games_box.set_row_spacing(20)
        self.games_box.set_margin_start(50)
        self.games_box.set_margin_end(50)
        self.games_box.set_margin_top(30)
        self.games_box.set_margin_bottom(50)
        
        self.game_tiles = []
        for i, game in enumerate(self.games):
            tile = self.create_game_tile(game, i)
            self.games_box.add(tile)
            self.game_tiles.append(tile)
        
        scroll.add(self.games_box)
        main_box.pack_start(scroll, True, True, 0)
        
        footer = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=50)
        footer.set_halign(Gtk.Align.CENTER)
        footer.set_margin_bottom(30)
        
        hints = [
            ("D-Pad / Arrow Keys", "Navigate"),
            ("A / Enter", "Play Game"),
            ("B / Backspace", "Back"),
            ("Y / F", "Favorite"),
            ("Start / ESC", "Exit")
        ]
        
        for button, action in hints:
            hint_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
            btn_label = Gtk.Label()
            btn_label.set_markup(f'<span foreground="#3b82f6" font="14">[{button}]</span>')
            action_label = Gtk.Label()
            action_label.set_markup(f'<span foreground="#94a3b8" font="14">{action}</span>')
            hint_box.pack_start(btn_label, False, False, 0)
            hint_box.pack_start(action_label, False, False, 0)
            footer.pack_start(hint_box, False, False, 0)
        
        main_box.pack_end(footer, False, False, 0)
        
        if self.game_tiles:
            self.update_selection(0)
    
    def create_game_tile(self, game, index):
        tile = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        tile.get_style_context().add_class("game-tile")
        tile.set_size_request(280, 200)
        
        icon = Gtk.Label()
        icon.set_markup('<span font="64">üéÆ</span>')
        tile.pack_start(icon, True, True, 0)
        
        name = Gtk.Label(label=game.name[:25] + "..." if len(game.name) > 25 else game.name)
        name.get_style_context().add_class("game-tile-title")
        tile.pack_start(name, False, False, 0)
        
        source = Gtk.Label(label=game.source)
        source.get_style_context().add_class("game-tile-source")
        tile.pack_start(source, False, False, 0)
        
        tile.game = game
        tile.index = index
        
        return tile
    
    def update_selection(self, new_index):
        if not self.game_tiles:
            return
        
        new_index = max(0, min(new_index, len(self.game_tiles) - 1))
        
        for tile in self.game_tiles:
            tile.get_style_context().remove_class("selected")
        
        self.selected_index = new_index
        self.game_tiles[new_index].get_style_context().add_class("selected")
        
        child = self.games_box.get_child_at_index(new_index)
        if child:
            self.games_box.select_child(child)
            child.grab_focus()
    
    def setup_keyboard_controls(self):
        self.connect("key-press-event", self.on_key_press)
    
    def on_key_press(self, widget, event):
        key = Gdk.keyval_name(event.keyval)
        
        cols = 5
        
        if key in ["Up", "w", "W"]:
            self.update_selection(self.selected_index - cols)
        elif key in ["Down", "s", "S"]:
            self.update_selection(self.selected_index + cols)
        elif key in ["Left", "a", "A"]:
            self.update_selection(self.selected_index - 1)
        elif key in ["Right", "d", "D"]:
            self.update_selection(self.selected_index + 1)
        elif key in ["Return", "space"]:
            self.launch_selected()
        elif key == "Escape":
            self.exit_console_mode()
        elif key in ["f", "F"]:
            pass
        
        return True
    
    def start_controller_input(self):
        """Start controller input thread using evdev"""
        def controller_loop():
            try:
                import evdev
                from evdev import ecodes
                
                devices = [evdev.InputDevice(path) for path in evdev.list_devices()]
                gamepads = [d for d in devices if ecodes.EV_ABS in d.capabilities()]
                
                if not gamepads:
                    return
                
                gamepad = gamepads[0]
                
                select_pressed = False
                start_pressed = False
                
                for event in gamepad.read_loop():
                    if not self.running:
                        break
                    
                    if event.type == ecodes.EV_KEY:
                        if event.code == ecodes.BTN_SOUTH and event.value == 1:
                            GLib.idle_add(self.launch_selected)
                        elif event.code == ecodes.BTN_EAST and event.value == 1:
                            GLib.idle_add(self.exit_console_mode)
                        elif event.code == ecodes.BTN_SELECT:
                            select_pressed = event.value == 1
                        elif event.code == ecodes.BTN_START:
                            start_pressed = event.value == 1
                        
                        if select_pressed and start_pressed:
                            GLib.idle_add(self.exit_console_mode)
                    
                    elif event.type == ecodes.EV_ABS:
                        if event.code == ecodes.ABS_HAT0Y:
                            if event.value == -1:
                                GLib.idle_add(self.update_selection, self.selected_index - 5)
                            elif event.value == 1:
                                GLib.idle_add(self.update_selection, self.selected_index + 5)
                        elif event.code == ecodes.ABS_HAT0X:
                            if event.value == -1:
                                GLib.idle_add(self.update_selection, self.selected_index - 1)
                            elif event.value == 1:
                                GLib.idle_add(self.update_selection, self.selected_index + 1)
            except ImportError:
                pass
            except Exception:
                pass
        
        self.controller_thread = threading.Thread(target=controller_loop, daemon=True)
        self.controller_thread.start()
    
    def launch_selected(self):
        if self.game_tiles and 0 <= self.selected_index < len(self.game_tiles):
            game = self.game_tiles[self.selected_index].game
            profile = GameProfile(game.appid or game.name.lower().replace(" ", "_"))
            env = profile.get_env()
            
            optimization_env = self.optimization_settings.apply_optimizations()
            env.update(optimization_env)
            
            subprocess.run(["systemctl", "--user", "start", "aegis-gaming-mode.target"], 
                           capture_output=True)
            
            if game.source.startswith("Steam") and game.appid:
                cmd = ["steam", f"steam://rungameid/{game.appid}"]
            elif "Heroic" in game.source or "Epic" in game.source:
                cmd = ["heroic", "--no-gui", game.appid or game.exe_path]
            elif os.path.isfile(game.exe_path):
                cmd = [game.exe_path]
            else:
                cmd = ["xdg-open", game.exe_path]
            
            try:
                if profile.profile.get("gamemode"):
                    cmd = ["gamemoderun"] + cmd
                subprocess.Popen(cmd, env=env, start_new_session=True)
            except Exception as e:
                print(f"Launch error: {e}")
    
    def exit_console_mode(self):
        self.running = False
        self.unfullscreen()
        self.destroy()
    
    def on_exit(self, widget):
        self.running = False


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Aegis Game Library")
    parser.add_argument("--console", "-c", action="store_true", 
                        help="Launch in console/fullscreen mode (controller-friendly)")
    parser.add_argument("--autostart", action="store_true",
                        help="Enable autostart on boot for console mode")
    args = parser.parse_args()
    
    if args.autostart:
        autostart_dir = Path.home() / ".config/autostart"
        autostart_dir.mkdir(parents=True, exist_ok=True)
        desktop_entry = autostart_dir / "aegis-game-library-console.desktop"
        desktop_entry.write_text("""[Desktop Entry]
Type=Application
Name=Aegis Game Library (Console Mode)
Exec=aegis-game-library --console
Hidden=false
X-GNOME-Autostart-enabled=true
""")
        print("Console mode autostart enabled!")
        return
    
    scanner = GameScanner()
    games = scanner.scan_all()
    
    if args.console:
        app = ConsoleMode(games)
    else:
        app = AegisGameLibrary()
    
    app.connect("destroy", Gtk.main_quit)
    app.show_all()
    Gtk.main()

if __name__ == "__main__":
    main()
