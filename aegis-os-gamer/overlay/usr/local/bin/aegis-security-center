#!/usr/bin/env python3
"""
Aegis OS Security Center - All-in-One Security Dashboard
Provides antivirus, firewall, AI security, and system security monitoring
"""

import os
import sys
import json
import subprocess
import logging
import shutil
from datetime import datetime
from pathlib import Path

try:
    import tkinter as tk
    from tkinter import ttk, messagebox, scrolledtext
    TKINTER_AVAILABLE = True
except ImportError:
    TKINTER_AVAILABLE = False

try:
    sys.path.insert(0, '/usr/share/aegis/security')
    from aegis_ai_security import AISecurityTier, AISecurityAnalyzer
    AI_SECURITY_AVAILABLE = True
except ImportError:
    AI_SECURITY_AVAILABLE = False

TIER_LIMIT = "gamer"  # "freemium" or "full" - controls feature availability

SUBPROCESS_TIMEOUT_SHORT = 10
SUBPROCESS_TIMEOUT_MEDIUM = 30
SCAN_TIMEOUT_QUICK = 300
SCAN_TIMEOUT_FULL = 3600

class AegisSecurityCenter:
    def __init__(self):
        self.version = "1.0.1"
        self.config_dir = Path("/etc/aegis")
        self.data_dir = Path("/var/lib/aegis/security")
        self.log_dir = Path("/var/log/aegis")
        self.config_file = self.config_dir / "security-config.json"
        self.events_file = self.data_dir / "security-events.json"
        
        self.ensure_directories()
        self.setup_logging()
        self.load_config()
        
    def ensure_directories(self):
        """Create required directories with proper error handling"""
        for directory in [self.config_dir, self.data_dir, self.log_dir]:
            try:
                directory.mkdir(parents=True, exist_ok=True)
            except PermissionError:
                pass
            except OSError as e:
                print(f"Warning: Could not create directory {directory}: {e}", file=sys.stderr)
    
    def setup_logging(self):
        """Configure logging with fallback to console-only if file logging fails"""
        log_file = self.log_dir / "aegis-security.log"
        handlers = [logging.StreamHandler()]
        
        try:
            if self.log_dir.exists() and os.access(str(self.log_dir), os.W_OK):
                handlers.insert(0, logging.FileHandler(log_file))
        except (OSError, PermissionError):
            pass
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=handlers
        )
        self.logger = logging.getLogger("AegisSecurity")
    
    def load_config(self):
        """Load security configuration with fallback defaults"""
        default_config = {
            "auto_scan_enabled": True,
            "scan_schedule": "daily",
            "firewall_enabled": True,
            "realtime_protection": False,
            "scan_paths": ["/home", "/tmp", "/var/tmp"],
            "excluded_paths": ["/home/*/.cache"],
            "quarantine_dir": "/var/lib/aegis/quarantine",
            "last_scan": None,
            "threats_found": 0
        }
        
        self.config = default_config.copy()
        
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    self.config.update(loaded_config)
        except (FileNotFoundError, json.JSONDecodeError, OSError, PermissionError) as e:
            pass
    
    def save_config(self):
        """Save configuration with error handling"""
        try:
            if self.config_dir.exists() and os.access(str(self.config_dir), os.W_OK):
                with open(self.config_file, 'w') as f:
                    json.dump(self.config, f, indent=2)
        except (OSError, PermissionError, IOError):
            pass
    
    def log_event(self, event_type, message, severity="info"):
        """Log a security event with error handling"""
        events = self.load_events()
        event = {
            "timestamp": datetime.now().isoformat(),
            "type": event_type,
            "message": message,
            "severity": severity
        }
        events.append(event)
        events = events[-1000:]
        
        try:
            if self.data_dir.exists() and os.access(str(self.data_dir), os.W_OK):
                with open(self.events_file, 'w') as f:
                    json.dump(events, f, indent=2)
        except (OSError, PermissionError, IOError):
            pass
        
        self.logger.info(f"[{event_type}] {message}")
    
    def load_events(self):
        """Load security events"""
        try:
            with open(self.events_file, 'r') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            return []
    
    def check_clamav_status(self):
        """Check ClamAV antivirus status"""
        status = {
            "installed": False,
            "running": False,
            "version": "Not installed",
            "database_date": "N/A",
            "definitions": 0
        }
        
        try:
            result = subprocess.run(
                ["clamscan", "--version"], 
                capture_output=True, text=True, 
                timeout=SUBPROCESS_TIMEOUT_SHORT
            )
            if result.returncode == 0:
                status["installed"] = True
                version_line = result.stdout.strip().split('\n')[0] if result.stdout else ""
                status["version"] = version_line if version_line else "Unknown version"
        except FileNotFoundError:
            status["version"] = "Not installed"
        except subprocess.TimeoutExpired:
            status["version"] = "Check timed out"
        except (OSError, subprocess.SubprocessError) as e:
            self.logger.debug(f"ClamAV version check failed: {e}")
        
        try:
            result = subprocess.run(
                ["systemctl", "is-active", "clamav-freshclam"],
                capture_output=True, text=True, 
                timeout=SUBPROCESS_TIMEOUT_SHORT
            )
            status["running"] = result.stdout.strip() == "active"
        except FileNotFoundError:
            pass
        except subprocess.TimeoutExpired:
            pass
        except (OSError, subprocess.SubprocessError) as e:
            self.logger.debug(f"ClamAV service check failed: {e}")
        
        try:
            for db_name in ["daily.cvd", "daily.cld", "main.cvd", "main.cld"]:
                db_path = Path(f"/var/lib/clamav/{db_name}")
                if db_path.exists():
                    mtime = datetime.fromtimestamp(db_path.stat().st_mtime)
                    status["database_date"] = mtime.strftime("%Y-%m-%d %H:%M")
                    break
        except (OSError, ValueError) as e:
            self.logger.debug(f"Database date check failed: {e}")
        
        return status
    
    def check_firewall_status(self):
        """Check firewall status (UFW or iptables)"""
        status = {
            "enabled": False,
            "type": "none",
            "rules_count": 0,
            "incoming_policy": "unknown",
            "outgoing_policy": "unknown"
        }
        
        try:
            result = subprocess.run(
                ["ufw", "status", "verbose"],
                capture_output=True, text=True, 
                timeout=SUBPROCESS_TIMEOUT_SHORT
            )
            if result.returncode == 0:
                output = result.stdout
                status["type"] = "ufw"
                status["enabled"] = "Status: active" in output
                
                if "Default: deny (incoming)" in output:
                    status["incoming_policy"] = "deny"
                elif "Default: allow (incoming)" in output:
                    status["incoming_policy"] = "allow"
                
                if "Default: allow (outgoing)" in output:
                    status["outgoing_policy"] = "allow"
                elif "Default: deny (outgoing)" in output:
                    status["outgoing_policy"] = "deny"
                
                lines = [l for l in output.split('\n') if l.strip() and not l.startswith('Status:') and not l.startswith('Default:') and not l.startswith('Logging:')]
                status["rules_count"] = max(0, len(lines) - 2)
        except FileNotFoundError:
            try:
                result = subprocess.run(
                    ["iptables", "-L", "-n"],
                    capture_output=True, text=True, 
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                if result.returncode == 0:
                    status["type"] = "iptables"
                    status["enabled"] = True
                    non_empty_lines = [l for l in result.stdout.split('\n') if l.strip()]
                    status["rules_count"] = len(non_empty_lines)
            except FileNotFoundError:
                pass
            except subprocess.TimeoutExpired:
                self.logger.debug("iptables check timed out")
            except (OSError, subprocess.SubprocessError) as e:
                self.logger.debug(f"iptables check failed: {e}")
        except subprocess.TimeoutExpired:
            self.logger.debug("UFW status check timed out")
        except (OSError, subprocess.SubprocessError) as e:
            self.logger.debug(f"UFW status check failed: {e}")
        
        return status
    
    def check_system_integrity(self):
        """Check system integrity using various tools"""
        checks = {
            "rkhunter": {"installed": False, "last_run": "Never", "status": "unknown"},
            "aide": {"installed": False, "last_run": "Never", "status": "unknown"},
            "chkrootkit": {"installed": False, "last_run": "Never", "status": "unknown"}
        }
        
        for tool in checks.keys():
            try:
                checks[tool]["installed"] = shutil.which(tool) is not None
            except (OSError, ValueError) as e:
                self.logger.debug(f"Tool check failed for {tool}: {e}")
        
        return checks
    
    def check_failed_logins(self):
        """Check for failed login attempts"""
        failed_logins = []
        
        try:
            auth_log = Path("/var/log/auth.log")
            if auth_log.exists():
                result = subprocess.run(
                    ["grep", "-i", "failed", str(auth_log)],
                    capture_output=True, text=True, 
                    timeout=SUBPROCESS_TIMEOUT_MEDIUM
                )
                if result.stdout:
                    lines = result.stdout.strip().split('\n')[-10:]
                    for line in lines:
                        if line.strip():
                            failed_logins.append(line)
        except FileNotFoundError:
            pass
        except subprocess.TimeoutExpired:
            self.logger.debug("Auth log search timed out")
        except (OSError, subprocess.SubprocessError) as e:
            self.logger.debug(f"Failed login check error: {e}")
        
        try:
            result = subprocess.run(
                ["journalctl", "-u", "sshd", "--since", "24 hours ago", 
                 "--grep", "Failed", "--no-pager", "-n", "10"],
                capture_output=True, text=True, 
                timeout=SUBPROCESS_TIMEOUT_MEDIUM
            )
            if result.returncode == 0 and result.stdout:
                for line in result.stdout.strip().split('\n'):
                    if line.strip() and line not in failed_logins:
                        failed_logins.append(line)
        except FileNotFoundError:
            pass
        except subprocess.TimeoutExpired:
            self.logger.debug("Journalctl search timed out")
        except (OSError, subprocess.SubprocessError) as e:
            self.logger.debug(f"Journalctl check error: {e}")
        
        return failed_logins[-10:]
    
    def check_open_ports(self):
        """Check for open network ports"""
        open_ports = []
        
        try:
            result = subprocess.run(
                ["ss", "-tuln"],
                capture_output=True, text=True, 
                timeout=SUBPROCESS_TIMEOUT_SHORT
            )
            if result.returncode == 0 and result.stdout:
                lines = result.stdout.strip().split('\n')[1:]
                for line in lines:
                    parts = line.split()
                    if len(parts) >= 5:
                        proto = parts[0]
                        local_addr = parts[4]
                        open_ports.append({
                            "protocol": proto,
                            "address": local_addr
                        })
        except FileNotFoundError:
            try:
                result = subprocess.run(
                    ["netstat", "-tuln"],
                    capture_output=True, text=True, 
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                if result.returncode == 0 and result.stdout:
                    lines = result.stdout.strip().split('\n')[2:]
                    for line in lines:
                        parts = line.split()
                        if len(parts) >= 4:
                            proto = parts[0]
                            local_addr = parts[3]
                            open_ports.append({
                                "protocol": proto,
                                "address": local_addr
                            })
            except (FileNotFoundError, subprocess.TimeoutExpired, OSError, subprocess.SubprocessError):
                pass
        except subprocess.TimeoutExpired:
            self.logger.debug("Port check timed out")
        except (OSError, subprocess.SubprocessError) as e:
            self.logger.debug(f"Port check error: {e}")
        
        return open_ports
    
    def run_quick_scan(self, path="/home", timeout=None):
        """Run a quick antivirus scan with proper error handling and timeout"""
        if TIER_LIMIT == "freemium":
            self.log_event("scan", "Antivirus scanning requires full edition", "warning")
            return {
                "status": "tier_restricted",
                "path": path,
                "files_scanned": 0,
                "threats_found": 0,
                "threats": [],
                "duration": 0,
                "timestamp": datetime.now().isoformat(),
                "error": "‚ö†Ô∏è Antivirus scanning is a premium feature. Upgrade to unlock ClamAV scanning, real-time protection, and threat detection."
            }
        
        self.log_event("scan", f"Starting quick scan of {path}", "info")
        
        if timeout is None:
            timeout = SCAN_TIMEOUT_FULL if path == "/" else SCAN_TIMEOUT_QUICK
        
        results = {
            "status": "completed",
            "path": path,
            "files_scanned": 0,
            "threats_found": 0,
            "threats": [],
            "duration": 0,
            "timestamp": datetime.now().isoformat()
        }
        
        if not shutil.which("clamscan"):
            results["status"] = "error"
            results["error"] = "ClamAV not installed. Install with: sudo apt install clamav"
            self.log_event("scan", "Scan failed: ClamAV not installed", "error")
            return results
        
        scan_path = Path(path)
        if not scan_path.exists():
            results["status"] = "error"
            results["error"] = f"Scan path does not exist: {path}"
            self.log_event("scan", f"Scan failed: Path not found: {path}", "error")
            return results
        
        try:
            start_time = datetime.now()
            
            result = subprocess.run(
                ["clamscan", "-r", "--infected", path],
                capture_output=True, text=True, 
                timeout=timeout
            )
            end_time = datetime.now()
            results["duration"] = int((end_time - start_time).total_seconds())
            
            output = result.stdout if result.stdout else ""
            stderr = result.stderr if result.stderr else ""
            
            for line in output.split('\n'):
                if "FOUND" in line and ": " in line:
                    results["threats_found"] += 1
                    results["threats"].append(line.strip())
                elif "Scanned files:" in line:
                    try:
                        results["files_scanned"] = int(line.split(':')[1].strip())
                    except (ValueError, IndexError):
                        pass
                elif "Known viruses:" in line:
                    try:
                        results["definitions"] = int(line.split(':')[1].strip())
                    except (ValueError, IndexError):
                        pass
            
            if result.returncode == 1 and results["threats_found"] > 0:
                results["status"] = "threats_detected"
            elif result.returncode == 2:
                results["status"] = "error"
                error_msg = stderr.strip() if stderr.strip() else "Some files could not be scanned"
                results["error"] = error_msg
                self.log_event("scan", f"Scan completed with errors: {error_msg}", "warning")
            elif result.returncode != 0 and result.returncode != 1:
                results["status"] = "error"
                results["error"] = stderr.strip() if stderr.strip() else f"ClamAV exited with code {result.returncode}"
                self.log_event("scan", f"Scan error: exit code {result.returncode}", "error")
            
            try:
                self.config["last_scan"] = results["timestamp"]
                self.config["threats_found"] = results["threats_found"]
                self.save_config()
            except (OSError, PermissionError) as e:
                self.logger.debug(f"Could not save scan config: {e}")
            
            severity = "warning" if results["threats_found"] > 0 else "info"
            self.log_event("scan", 
                          f"Scan complete: {results['files_scanned']} files, "
                          f"{results['threats_found']} threats, {results['duration']}s", 
                          severity)
            
        except subprocess.TimeoutExpired as e:
            results["status"] = "timeout"
            timeout_min = timeout // 60
            results["error"] = f"Scan timed out after {timeout_min} minutes. Try scanning a smaller directory."
            results["duration"] = timeout
            self.log_event("scan", f"Scan timed out after {timeout_min} minutes", "warning")
        except PermissionError as e:
            results["status"] = "error"
            results["error"] = f"Permission denied scanning {path}. Try running with sudo."
            self.log_event("scan", f"Scan permission denied: {e}", "error")
        except OSError as e:
            results["status"] = "error"
            results["error"] = f"System error during scan: {e}"
            self.log_event("scan", f"Scan system error: {e}", "error")
        except subprocess.SubprocessError as e:
            results["status"] = "error"
            results["error"] = f"Subprocess error: {e}"
            self.log_event("scan", f"Scan subprocess error: {e}", "error")
        
        return results
    
    def enable_firewall(self):
        """Enable the firewall with proper error handling"""
        if TIER_LIMIT == "freemium":
            self.log_event("firewall", "Firewall control requires full edition", "warning")
            return False
        
        ufw_available = shutil.which("ufw") is not None
        
        if ufw_available:
            try:
                result = subprocess.run(
                    ["sudo", "ufw", "--force", "enable"], 
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_MEDIUM
                )
                if result.returncode == 0:
                    self.config["firewall_enabled"] = True
                    try:
                        self.save_config()
                    except (OSError, PermissionError):
                        pass
                    self.log_event("firewall", "UFW firewall enabled", "info")
                    return True
                else:
                    error_msg = result.stderr.strip() if result.stderr else "Unknown error"
                    self.log_event("firewall", f"UFW enable failed: {error_msg}", "error")
                    return False
            except subprocess.TimeoutExpired:
                self.log_event("firewall", "UFW enable command timed out", "error")
                return False
            except PermissionError:
                self.log_event("firewall", "Permission denied. Run with sudo.", "error")
                return False
            except FileNotFoundError:
                pass
            except (OSError, subprocess.SubprocessError) as e:
                self.log_event("firewall", f"Failed to enable UFW: {e}", "error")
                return False
        
        if shutil.which("iptables"):
            try:
                result = subprocess.run(
                    ["sudo", "iptables", "-P", "INPUT", "DROP"],
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                subprocess.run(
                    ["sudo", "iptables", "-P", "FORWARD", "DROP"],
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                subprocess.run(
                    ["sudo", "iptables", "-A", "INPUT", "-i", "lo", "-j", "ACCEPT"],
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                subprocess.run(
                    ["sudo", "iptables", "-A", "INPUT", "-m", "state", "--state", "ESTABLISHED,RELATED", "-j", "ACCEPT"],
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                self.config["firewall_enabled"] = True
                try:
                    self.save_config()
                except (OSError, PermissionError):
                    pass
                self.log_event("firewall", "iptables firewall enabled (basic rules)", "info")
                return True
            except subprocess.TimeoutExpired:
                self.log_event("firewall", "iptables command timed out", "error")
                return False
            except (FileNotFoundError, PermissionError, OSError, subprocess.SubprocessError) as e:
                self.log_event("firewall", f"Failed to enable iptables: {e}", "error")
                return False
        
        self.log_event("firewall", "No firewall tool available (install ufw or iptables)", "error")
        return False
    
    def disable_firewall(self):
        """Disable the firewall with proper error handling"""
        if TIER_LIMIT == "freemium":
            self.log_event("firewall", "Firewall control requires full edition", "warning")
            return False
        
        ufw_available = shutil.which("ufw") is not None
        
        if ufw_available:
            try:
                result = subprocess.run(
                    ["sudo", "ufw", "disable"], 
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_MEDIUM
                )
                if result.returncode == 0:
                    self.config["firewall_enabled"] = False
                    try:
                        self.save_config()
                    except (OSError, PermissionError):
                        pass
                    self.log_event("firewall", "UFW firewall disabled", "warning")
                    return True
                else:
                    error_msg = result.stderr.strip() if result.stderr else "Unknown error"
                    self.log_event("firewall", f"UFW disable failed: {error_msg}", "error")
                    return False
            except subprocess.TimeoutExpired:
                self.log_event("firewall", "UFW disable command timed out", "error")
                return False
            except PermissionError:
                self.log_event("firewall", "Permission denied. Run with sudo.", "error")
                return False
            except FileNotFoundError:
                pass
            except (OSError, subprocess.SubprocessError) as e:
                self.log_event("firewall", f"Failed to disable UFW: {e}", "error")
                return False
        
        if shutil.which("iptables"):
            try:
                subprocess.run(
                    ["sudo", "iptables", "-P", "INPUT", "ACCEPT"],
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                subprocess.run(
                    ["sudo", "iptables", "-P", "FORWARD", "ACCEPT"],
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                subprocess.run(
                    ["sudo", "iptables", "-F"],
                    capture_output=True, text=True,
                    timeout=SUBPROCESS_TIMEOUT_SHORT
                )
                self.config["firewall_enabled"] = False
                try:
                    self.save_config()
                except (OSError, PermissionError):
                    pass
                self.log_event("firewall", "iptables firewall disabled (rules flushed)", "warning")
                return True
            except subprocess.TimeoutExpired:
                self.log_event("firewall", "iptables command timed out", "error")
                return False
            except (FileNotFoundError, PermissionError, OSError, subprocess.SubprocessError) as e:
                self.log_event("firewall", f"Failed to disable iptables: {e}", "error")
                return False
        
        self.log_event("firewall", "No firewall tool available (install ufw or iptables)", "error")
        return False
    
    def get_security_score(self):
        """Calculate overall security score"""
        score = 100
        issues = []
        
        av_status = self.check_clamav_status()
        if not av_status["installed"]:
            score -= 20
            issues.append("Antivirus not installed")
        elif not av_status["running"]:
            score -= 10
            issues.append("Antivirus not running")
        
        fw_status = self.check_firewall_status()
        if not fw_status["enabled"]:
            score -= 25
            issues.append("Firewall not enabled")
        
        if self.config.get("last_scan") is None:
            score -= 15
            issues.append("No antivirus scan performed yet")
        
        failed_logins = self.check_failed_logins()
        if len(failed_logins) > 5:
            score -= 10
            issues.append(f"Multiple failed login attempts detected ({len(failed_logins)})")
        
        return max(0, score), issues
    
    def get_full_status(self):
        """Get comprehensive security status"""
        status = {
            "antivirus": self.check_clamav_status(),
            "firewall": self.check_firewall_status(),
            "integrity": self.check_system_integrity(),
            "failed_logins": len(self.check_failed_logins()),
            "open_ports": len(self.check_open_ports()),
            "last_scan": self.config.get("last_scan"),
            "threats_found": self.config.get("threats_found", 0),
            "security_score": self.get_security_score()
        }
        status["ai_security"] = self.get_ai_security_status()
        return status
    
    def get_ai_security_status(self):
        """Get AI security tier and capabilities status"""
        if not AI_SECURITY_AVAILABLE:
            return {
                "available": False,
                "error": "AI Security module not loaded",
                "tier_name": "Unknown",
                "tier_level": 0,
                "capabilities": [],
                "capabilities_count": 0
            }
        
        try:
            tier = AISecurityTier(TIER_LIMIT)
            return {
                "available": True,
                "tier_name": tier.get_tier_name(),
                "tier_level": tier.get_tier_level(),
                "description": tier.get_tier_description(),
                "capabilities": tier.get_capabilities(),
                "capabilities_count": len(tier.get_capabilities()),
                "limits": tier.get_limits(),
                "realtime_protection": tier.get_limits().get("realtime_protection", False),
                "ai_analysis": tier.get_limits().get("ai_analysis", False)
            }
        except Exception as e:
            self.logger.error(f"Failed to get AI security status: {e}")
            return {
                "available": False,
                "error": str(e),
                "tier_name": "Error",
                "tier_level": 0,
                "capabilities": [],
                "capabilities_count": 0
            }
    
    def run_ai_heuristic_scan(self, path="/home"):
        """Run AI-powered heuristic scan"""
        if not AI_SECURITY_AVAILABLE:
            return {
                "status": "error",
                "error": "AI Security module not available"
            }
        
        try:
            analyzer = AISecurityAnalyzer(AISecurityTier(TIER_LIMIT))
            result = analyzer.heuristic_scan(path)
            self.log_event("ai_scan", f"AI heuristic scan of {path}: {result.get('status', 'unknown')}", "info")
            return result
        except Exception as e:
            self.logger.error(f"AI heuristic scan failed: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def run_ai_behavioral_analysis(self):
        """Run AI behavioral analysis"""
        if not AI_SECURITY_AVAILABLE:
            return {
                "status": "error",
                "error": "AI Security module not available"
            }
        
        try:
            analyzer = AISecurityAnalyzer(AISecurityTier(TIER_LIMIT))
            result = analyzer.behavioral_analysis()
            self.log_event("ai_behavioral", f"Behavioral analysis: {result.get('risk_level', 'unknown')}", "info")
            return result
        except Exception as e:
            self.logger.error(f"AI behavioral analysis failed: {e}")
            return {
                "status": "error",
                "error": str(e)
            }
    
    def get_ai_security_summary(self):
        """Get comprehensive AI security summary"""
        if not AI_SECURITY_AVAILABLE:
            return {
                "available": False,
                "error": "AI Security module not available"
            }
        
        try:
            analyzer = AISecurityAnalyzer(AISecurityTier(TIER_LIMIT))
            return analyzer.get_security_summary()
        except Exception as e:
            self.logger.error(f"Failed to get AI security summary: {e}")
            return {
                "available": False,
                "error": str(e)
            }


COLORS = {
    'bg_dark': '#0a0a0f',
    'bg_panel': '#12121a',
    'bg_card': '#1a1a2e',
    'accent_cyan': '#00d4ff',
    'accent_green': '#00ff88',
    'accent_purple': '#8b5cf6',
    'accent_orange': '#ff8c00',
    'text_primary': '#ffffff',
    'text_secondary': '#a0a0b0',
    'text_muted': '#606070',
    'border': '#2a2a3e',
    'success': '#00ff88',
    'warning': '#ffb800',
    'error': '#ff4757',
}

class SecurityCenterGUI:
    def __init__(self):
        self.security = AegisSecurityCenter()
        self.root = tk.Tk()
        self.setup_window()
        self.create_widgets()
        self.refresh_status()
        
    def setup_window(self):
        self.root.title("Aegis Security Center")
        self.root.geometry("1000x750")
        self.root.configure(bg=COLORS['bg_dark'])
        self.root.minsize(900, 650)
        
    def create_styled_button(self, parent, text, command, color=None):
        if color is None:
            color = COLORS['accent_cyan']
        btn = tk.Button(parent, text=text, command=command,
                       bg=COLORS['bg_panel'],
                       fg=COLORS['text_primary'],
                       activebackground=color,
                       activeforeground=COLORS['bg_dark'],
                       font=('Segoe UI', 10, 'bold'),
                       bd=0, padx=18, pady=10,
                       cursor='hand2',
                       highlightthickness=1,
                       highlightbackground=color)
        btn.bind('<Enter>', lambda e, b=btn, c=color: b.configure(bg=c, fg=COLORS['bg_dark']))
        btn.bind('<Leave>', lambda e, b=btn: b.configure(bg=COLORS['bg_panel'], fg=COLORS['text_primary']))
        return btn
        
    def create_card(self, parent, title=None, icon=None):
        card = tk.Frame(parent, bg=COLORS['bg_card'],
                       highlightbackground=COLORS['border'],
                       highlightthickness=1)
        
        if title:
            header = tk.Frame(card, bg=COLORS['bg_card'])
            header.pack(fill='x', padx=15, pady=(12, 0))
            
            title_text = f"{icon} {title}" if icon else title
            title_label = tk.Label(header, text=title_text,
                                  bg=COLORS['bg_card'],
                                  fg=COLORS['accent_green'],
                                  font=('Segoe UI', 13, 'bold'))
            title_label.pack(anchor='w')
            
            separator = tk.Frame(card, bg=COLORS['border'], height=1)
            separator.pack(fill='x', padx=15, pady=(8, 0))
        
        content = tk.Frame(card, bg=COLORS['bg_card'])
        content.pack(fill='both', expand=True, padx=15, pady=12)
        
        return card, content
        
    def create_widgets(self):
        main_container = tk.Frame(self.root, bg=COLORS['bg_dark'])
        main_container.pack(fill='both', expand=True, padx=20, pady=15)
        
        header = tk.Frame(main_container, bg=COLORS['bg_dark'])
        header.pack(fill='x', pady=(0, 15))
        
        title_frame = tk.Frame(header, bg=COLORS['bg_dark'])
        title_frame.pack(side='left')
        
        title = tk.Label(title_frame, text="üõ°Ô∏è Aegis Security Center",
                        bg=COLORS['bg_dark'],
                        fg=COLORS['accent_cyan'],
                        font=('Segoe UI', 24, 'bold'))
        title.pack(anchor='w')
        
        subtitle = tk.Label(title_frame, text="Gamer Edition ‚Ä¢ Real-time Protection Dashboard",
                           bg=COLORS['bg_dark'],
                           fg=COLORS['text_muted'],
                           font=('Segoe UI', 11))
        subtitle.pack(anchor='w')
        
        refresh_btn = self.create_styled_button(header, "üîÑ Refresh", self.refresh_status)
        refresh_btn.pack(side='right')
        
        main_frame = tk.Frame(main_container, bg=COLORS['bg_dark'])
        main_frame.pack(fill='both', expand=True)
        
        left_panel = tk.Frame(main_frame, bg=COLORS['bg_dark'])
        left_panel.pack(side='left', fill='both', expand=True)
        
        score_card, score_content = self.create_card(left_panel, "Security Score", "üìä")
        score_card.pack(fill='x', pady=(0, 10))
        
        score_display = tk.Frame(score_content, bg=COLORS['bg_card'])
        score_display.pack(fill='x')
        
        self.score_label = tk.Label(score_display, text="--",
                                   bg=COLORS['bg_card'],
                                   fg=COLORS['accent_green'],
                                   font=('Segoe UI', 52, 'bold'))
        self.score_label.pack(side='left')
        
        self.score_status = tk.Label(score_display, text="Calculating...",
                                    bg=COLORS['bg_card'],
                                    fg=COLORS['text_secondary'],
                                    font=('Segoe UI', 14))
        self.score_status.pack(side='left', padx=(15, 0), pady=(15, 0))
        
        av_card, av_content = self.create_card(left_panel, "Antivirus (ClamAV)", "ü¶†")
        av_card.pack(fill='x', pady=(0, 10))
        
        self.av_status = tk.Label(av_content, text="Checking...",
                                 bg=COLORS['bg_card'],
                                 fg=COLORS['text_primary'],
                                 font=('Segoe UI', 11))
        self.av_status.pack(anchor='w')
        
        self.av_version = tk.Label(av_content, text="",
                                  bg=COLORS['bg_card'],
                                  fg=COLORS['text_muted'],
                                  font=('Segoe UI', 10))
        self.av_version.pack(anchor='w', pady=(2, 0))
        
        self.av_db = tk.Label(av_content, text="",
                             bg=COLORS['bg_card'],
                             fg=COLORS['text_muted'],
                             font=('Segoe UI', 10))
        self.av_db.pack(anchor='w')
        
        av_buttons = tk.Frame(av_content, bg=COLORS['bg_card'])
        av_buttons.pack(fill='x', pady=(10, 0))
        
        self.create_styled_button(av_buttons, "Quick Scan", self.run_scan, COLORS['accent_cyan']).pack(side='left', padx=(0, 8))
        self.create_styled_button(av_buttons, "Full Scan", lambda: self.run_scan("/"), COLORS['accent_orange']).pack(side='left')
        
        fw_card, fw_content = self.create_card(left_panel, "Firewall", "üî•")
        fw_card.pack(fill='x', pady=(0, 10))
        
        self.fw_status = tk.Label(fw_content, text="Checking...",
                                 bg=COLORS['bg_card'],
                                 fg=COLORS['text_primary'],
                                 font=('Segoe UI', 11))
        self.fw_status.pack(anchor='w')
        
        self.fw_rules = tk.Label(fw_content, text="",
                                bg=COLORS['bg_card'],
                                fg=COLORS['text_muted'],
                                font=('Segoe UI', 10))
        self.fw_rules.pack(anchor='w', pady=(2, 0))
        
        fw_buttons = tk.Frame(fw_content, bg=COLORS['bg_card'])
        fw_buttons.pack(fill='x', pady=(10, 0))
        
        self.create_styled_button(fw_buttons, "Enable", self.enable_firewall, COLORS['success']).pack(side='left', padx=(0, 8))
        self.create_styled_button(fw_buttons, "Disable", self.disable_firewall, COLORS['error']).pack(side='left')
        
        ai_card, ai_content = self.create_card(left_panel, "AI Security", "ü§ñ")
        ai_card.pack(fill='x', pady=(0, 10))
        
        self.ai_tier_label = tk.Label(ai_content, text="Loading...",
                                     bg=COLORS['bg_card'],
                                     fg=COLORS['text_primary'],
                                     font=('Segoe UI', 11))
        self.ai_tier_label.pack(anchor='w')
        
        self.ai_level_label = tk.Label(ai_content, text="",
                                      bg=COLORS['bg_card'],
                                      fg=COLORS['accent_purple'],
                                      font=('Segoe UI', 10))
        self.ai_level_label.pack(anchor='w', pady=(2, 0))
        
        self.ai_caps_label = tk.Label(ai_content, text="",
                                     bg=COLORS['bg_card'],
                                     fg=COLORS['text_muted'],
                                     font=('Segoe UI', 10))
        self.ai_caps_label.pack(anchor='w')
        
        self.ai_realtime_label = tk.Label(ai_content, text="",
                                         bg=COLORS['bg_card'],
                                         fg=COLORS['text_muted'],
                                         font=('Segoe UI', 10))
        self.ai_realtime_label.pack(anchor='w')
        
        ai_buttons = tk.Frame(ai_content, bg=COLORS['bg_card'])
        ai_buttons.pack(fill='x', pady=(10, 0))
        
        self.create_styled_button(ai_buttons, "AI Scan", self.run_ai_scan, COLORS['accent_purple']).pack(side='left', padx=(0, 8))
        self.create_styled_button(ai_buttons, "Behavioral", self.run_behavioral, COLORS['accent_purple']).pack(side='left')
        
        right_panel = tk.Frame(main_frame, bg=COLORS['bg_dark'])
        right_panel.pack(side='right', fill='both', expand=True, padx=(15, 0))
        
        events_card, events_content = self.create_card(right_panel, "Recent Security Events", "üìã")
        events_card.pack(fill='both', expand=True, pady=(0, 10))
        
        self.events_text = scrolledtext.ScrolledText(events_content, height=12,
                                                     bg=COLORS['bg_panel'],
                                                     fg=COLORS['accent_green'],
                                                     font=('Consolas', 9),
                                                     bd=0,
                                                     insertbackground=COLORS['text_primary'],
                                                     selectbackground=COLORS['accent_cyan'])
        self.events_text.pack(fill='both', expand=True)
        
        ports_card, ports_content = self.create_card(right_panel, "Open Ports", "üåê")
        ports_card.pack(fill='x', pady=(0, 10))
        
        self.ports_text = tk.Text(ports_content, height=4,
                                 bg=COLORS['bg_panel'],
                                 fg=COLORS['text_primary'],
                                 font=('Consolas', 9),
                                 bd=0)
        self.ports_text.pack(fill='x')
        
        issues_card, issues_content = self.create_card(right_panel, "Security Issues", "‚ö†Ô∏è")
        issues_card.pack(fill='x')
        
        self.issues_text = tk.Text(issues_content, height=3,
                                  bg=COLORS['bg_panel'],
                                  fg=COLORS['warning'],
                                  font=('Segoe UI', 10),
                                  bd=0)
        self.issues_text.pack(fill='x')
        
    def refresh_status(self):
        """Refresh all security status information"""
        status = self.security.get_full_status()
        
        score, issues = status["security_score"]
        self.score_label.config(text=f"{score}%")
        
        if score >= 80:
            color = COLORS['success']
            text = "‚úì Good"
        elif score >= 60:
            color = COLORS['warning']
            text = "‚ö† Fair"
        else:
            color = COLORS['error']
            text = "‚úó Poor"
        
        self.score_label.config(fg=color)
        self.score_status.config(text=f"Status: {text}")
        
        av = status["antivirus"]
        if av["installed"]:
            av_text = f"‚úÖ Installed - {'Running' if av['running'] else '‚ö†Ô∏è Not Running'}"
        else:
            av_text = "‚ùå Not Installed"
        self.av_status.config(text=av_text)
        self.av_version.config(text=f"Version: {av['version']}")
        self.av_db.config(text=f"Database: {av['database_date']}")
        
        fw = status["firewall"]
        if fw["enabled"]:
            fw_text = f"‚úÖ Enabled ({fw['type'].upper()})"
        else:
            fw_text = "‚ùå Disabled"
        self.fw_status.config(text=fw_text)
        self.fw_rules.config(text=f"Rules: {fw['rules_count']} | In: {fw['incoming_policy']} | Out: {fw['outgoing_policy']}")
        
        events = self.security.load_events()[-20:]
        self.events_text.delete('1.0', tk.END)
        for event in reversed(events):
            self.events_text.insert(tk.END, 
                f"[{event['timestamp'][:19]}] [{event['severity'].upper()}] {event['message']}\n")
        
        ports = self.security.check_open_ports()
        self.ports_text.delete('1.0', tk.END)
        for port in ports[:10]:
            self.ports_text.insert(tk.END, f"{port['protocol']}: {port['address']}\n")
        
        self.issues_text.delete('1.0', tk.END)
        if issues:
            self.issues_text.config(fg=COLORS['warning'])
            for issue in issues:
                self.issues_text.insert(tk.END, f"‚Ä¢ {issue}\n")
        else:
            self.issues_text.config(fg=COLORS['success'])
            self.issues_text.insert(tk.END, "‚úÖ No security issues detected")
        
        ai = status.get("ai_security", {})
        if ai.get("available", False):
            tier_name = ai.get("tier_name", "Unknown")
            tier_level = ai.get("tier_level", 0)
            self.ai_tier_label.config(text=f"Tier: {tier_name}")
            
            level_bars = "‚ñà" * tier_level + "‚ñë" * (5 - tier_level)
            self.ai_level_label.config(text=f"Level: [{level_bars}] {tier_level}/5")
            
            caps_count = ai.get("capabilities_count", 0)
            self.ai_caps_label.config(text=f"Capabilities: {caps_count} active")
            
            realtime = "‚úÖ Enabled" if ai.get("realtime_protection") else "‚ùå Disabled"
            ai_analysis = "‚úÖ Enabled" if ai.get("ai_analysis") else "‚ùå Disabled"
            self.ai_realtime_label.config(text=f"RT: {realtime} | AI: {ai_analysis}")
        else:
            self.ai_tier_label.config(text="‚ùå AI Security unavailable")
            self.ai_level_label.config(text=ai.get("error", "Module not loaded"))
            self.ai_caps_label.config(text="")
            self.ai_realtime_label.config(text="")
        
    def run_scan(self, path="/home"):
        """Run antivirus scan with proper status handling"""
        self.av_status.config(text="üîÑ Scanning...")
        self.root.update()
        
        results = self.security.run_quick_scan(path)
        status = results.get("status", "unknown")
        
        if status in ("completed", "threats_detected"):
            if results.get("threats_found", 0) > 0:
                threats_list = "\n".join(results.get("threats", [])[:5])
                if len(results.get("threats", [])) > 5:
                    threats_list += f"\n... and {len(results['threats']) - 5} more"
                messagebox.showwarning("Scan Complete", 
                    f"‚ö†Ô∏è Found {results['threats_found']} threat(s)!\n\n{threats_list}")
            else:
                messagebox.showinfo("Scan Complete", 
                    f"‚úÖ Scan complete!\n\n"
                    f"Files scanned: {results.get('files_scanned', 0)}\n"
                    f"Threats found: 0\n"
                    f"Duration: {results.get('duration', 0)} seconds")
        elif status == "timeout":
            messagebox.showwarning("Scan Timeout", 
                f"‚è±Ô∏è {results.get('error', 'Scan timed out')}")
        elif status == "error":
            messagebox.showerror("Scan Error", 
                results.get("error", "Unknown error occurred during scan"))
        else:
            messagebox.showwarning("Scan Status", 
                f"Scan completed with status: {status}")
        
        self.refresh_status()
        
    def enable_firewall(self):
        """Enable firewall"""
        if self.security.enable_firewall():
            messagebox.showinfo("Firewall", "‚úÖ Firewall enabled successfully")
        else:
            messagebox.showerror("Firewall", "‚ùå Failed to enable firewall")
        self.refresh_status()
        
    def disable_firewall(self):
        """Disable firewall"""
        if messagebox.askyesno("Confirm", "Are you sure you want to disable the firewall?"):
            if self.security.disable_firewall():
                messagebox.showinfo("Firewall", "‚ö†Ô∏è Firewall disabled")
            else:
                messagebox.showerror("Firewall", "‚ùå Failed to disable firewall")
            self.refresh_status()
    
    def run_ai_scan(self):
        """Run AI-powered heuristic scan"""
        self.ai_tier_label.config(text="üîÑ Running AI scan...")
        self.root.update()
        
        result = self.security.run_ai_heuristic_scan("/home")
        status = result.get("status", "unknown")
        
        if status == "completed":
            threats = result.get("threats_found", [])
            risk = result.get("risk_score", 0)
            files = result.get("files_scanned", 0)
            remaining = result.get("scans_remaining", -1)
            
            if threats:
                threat_list = "\n".join([f"‚Ä¢ {t.get('pattern', 'Unknown')}: {t.get('file', 'Unknown')}" for t in threats[:5]])
                if len(threats) > 5:
                    threat_list += f"\n... and {len(threats) - 5} more"
                messagebox.showwarning("AI Scan Complete",
                    f"‚ö†Ô∏è Found {len(threats)} potential threat(s)!\n\n{threat_list}\n\nRisk Score: {risk}/10")
            else:
                msg = f"‚úÖ AI Scan Complete\n\nFiles scanned: {files}\nThreats found: 0\nRisk Score: {risk}/10"
                if remaining >= 0:
                    msg += f"\n\nScans remaining today: {remaining}"
                messagebox.showinfo("AI Scan Complete", msg)
        elif status == "rate_limited":
            messagebox.showwarning("Rate Limited", 
                f"‚ö†Ô∏è {result.get('error', 'Daily scan limit exceeded')}\n\nUpgrade to unlock unlimited scans.")
        elif status == "tier_restricted":
            messagebox.showinfo("Tier Restricted",
                f"‚ÑπÔ∏è {result.get('error', 'Feature not available')}\n\n{result.get('upgrade_hint', '')}")
        else:
            messagebox.showerror("AI Scan Error",
                f"‚ùå {result.get('error', 'Unknown error occurred')}")
        
        self.refresh_status()
    
    def run_behavioral(self):
        """Run behavioral analysis"""
        self.ai_tier_label.config(text="üîÑ Analyzing behavior...")
        self.root.update()
        
        result = self.security.run_ai_behavioral_analysis()
        status = result.get("status", "unknown")
        
        if status == "completed":
            risk_level = result.get("risk_level", "unknown")
            anomalies = result.get("anomalies", [])
            model_type = result.get("model_type", "basic")
            
            risk_emoji = {"low": "‚úÖ", "medium": "‚ö†Ô∏è", "high": "üî¥"}.get(risk_level, "‚ùì")
            
            if anomalies:
                anomaly_list = "\n".join([f"‚Ä¢ [{a.get('severity', 'N/A')}] {a.get('description', 'Unknown')}" for a in anomalies[:5]])
                messagebox.showwarning("Behavioral Analysis",
                    f"{risk_emoji} Risk Level: {risk_level.upper()}\n\nAnomalies detected:\n{anomaly_list}\n\nModel: {model_type}")
            else:
                messagebox.showinfo("Behavioral Analysis",
                    f"{risk_emoji} Risk Level: {risk_level.upper()}\n\nNo anomalies detected\nModel: {model_type}")
        elif status == "tier_restricted":
            messagebox.showinfo("Tier Restricted",
                f"‚ÑπÔ∏è {result.get('error', 'Feature not available')}\n\n{result.get('upgrade_hint', '')}")
        else:
            messagebox.showerror("Analysis Error",
                f"‚ùå {result.get('error', 'Unknown error occurred')}")
        
        self.refresh_status()
        
    def run(self):
        """Run the GUI"""
        self.root.mainloop()


def show_cli_status(security=None):
    """Display security status in CLI"""
    if security is None:
        security = AegisSecurityCenter()
    status = security.get_full_status()
    
    score, issues = status["security_score"]
    
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               üõ°Ô∏è  AEGIS SECURITY CENTER                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
""")
    
    print(f"  SECURITY SCORE: {score}%")
    if score >= 80:
        print("  Status: ‚úÖ GOOD")
    elif score >= 60:
        print("  Status: ‚ö†Ô∏è  FAIR")
    else:
        print("  Status: ‚ùå POOR")
    
    print("\n" + "‚îÄ" * 60)
    print("  ü¶† ANTIVIRUS (ClamAV)")
    av = status["antivirus"]
    print(f"     Installed: {'‚úÖ Yes' if av['installed'] else '‚ùå No'}")
    print(f"     Running: {'‚úÖ Yes' if av['running'] else '‚ùå No'}")
    print(f"     Version: {av['version']}")
    print(f"     Database: {av['database_date']}")
    
    print("\n" + "‚îÄ" * 60)
    print("  üî• FIREWALL")
    fw = status["firewall"]
    print(f"     Status: {'‚úÖ Enabled' if fw['enabled'] else '‚ùå Disabled'}")
    print(f"     Type: {fw['type'].upper()}")
    print(f"     Rules: {fw['rules_count']}")
    print(f"     Incoming: {fw['incoming_policy']} | Outgoing: {fw['outgoing_policy']}")
    
    print("\n" + "‚îÄ" * 60)
    print("  üìä SYSTEM STATUS")
    print(f"     Failed Login Attempts: {status['failed_logins']}")
    print(f"     Open Ports: {status['open_ports']}")
    print(f"     Last Scan: {status['last_scan'] or 'Never'}")
    print(f"     Threats Found: {status['threats_found']}")
    
    print("\n" + "‚îÄ" * 60)
    print("  ü§ñ AI SECURITY")
    ai = status.get("ai_security", {})
    if ai.get("available", False):
        tier_name = ai.get("tier_name", "Unknown")
        tier_level = ai.get("tier_level", 0)
        level_bars = "‚ñà" * tier_level + "‚ñë" * (5 - tier_level)
        print(f"     Tier: {tier_name}")
        print(f"     Level: [{level_bars}] {tier_level}/5")
        print(f"     Capabilities: {ai.get('capabilities_count', 0)} active")
        realtime = "‚úÖ Yes" if ai.get("realtime_protection") else "‚ùå No"
        ai_analysis = "‚úÖ Yes" if ai.get("ai_analysis") else "‚ùå No"
        print(f"     Realtime Protection: {realtime}")
        print(f"     AI Analysis: {ai_analysis}")
        
        caps = ai.get("capabilities", [])
        if caps:
            print("     Active Capabilities:")
            for cap in caps[:6]:
                print(f"       ‚Ä¢ {cap}")
            if len(caps) > 6:
                print(f"       ... and {len(caps) - 6} more")
    else:
        print(f"     Status: ‚ùå Unavailable")
        print(f"     Error: {ai.get('error', 'Module not loaded')}")
    
    if issues:
        print("\n" + "‚îÄ" * 60)
        print("  ‚ö†Ô∏è  SECURITY ISSUES:")
        for issue in issues:
            print(f"     ‚Ä¢ {issue}")
    
    print("\n" + "‚ïê" * 60)
    print("  Commands: aegis-security-center --scan | --ai-scan | --ai-status | --help")
    print("‚ïê" * 60 + "\n")


def print_scan_results(results):
    """Print scan results in a formatted way"""
    status = results.get("status", "unknown")
    
    if status == "error":
        print(f"‚ùå Scan failed: {results.get('error', 'Unknown error')}")
        return False
    elif status == "timeout":
        print(f"‚è±Ô∏è {results.get('error', 'Scan timed out')}")
        return False
    elif status in ("completed", "threats_detected"):
        files_scanned = results.get('files_scanned', 0)
        threats_found = results.get('threats_found', 0)
        duration = results.get('duration', 0)
        
        if threats_found > 0:
            print(f"‚ö†Ô∏è Scan complete: {files_scanned} files scanned, {threats_found} threat(s) found!")
            print("\n  Threats detected:")
            for threat in results.get('threats', [])[:10]:
                print(f"    ‚Ä¢ {threat}")
            if len(results.get('threats', [])) > 10:
                print(f"    ... and {len(results['threats']) - 10} more")
        else:
            print(f"‚úÖ Scan complete: {files_scanned} files scanned, no threats found")
        
        print(f"   Duration: {duration} seconds")
        return True
    else:
        print(f"‚ö†Ô∏è Scan completed with unknown status: {status}")
        return True


def print_ai_scan_results(results):
    """Print AI scan results in a formatted way"""
    status = results.get("status", "unknown")
    
    if status == "error":
        print(f"‚ùå AI Scan failed: {results.get('error', 'Unknown error')}")
        return False
    elif status == "rate_limited":
        print(f"‚ö†Ô∏è Rate Limited: {results.get('error', 'Daily limit exceeded')}")
        print("   Upgrade to unlock unlimited AI scans.")
        return False
    elif status == "tier_restricted":
        print(f"‚ÑπÔ∏è Feature Restricted: {results.get('error', 'Not available')}")
        if results.get('upgrade_hint'):
            print(f"   {results.get('upgrade_hint')}")
        return False
    elif status == "completed":
        threats = results.get('threats_found', [])
        risk = results.get('risk_score', 0)
        files = results.get('files_scanned', 0)
        remaining = results.get('scans_remaining', -1)
        
        if threats:
            print(f"‚ö†Ô∏è AI Scan complete: {files} files scanned, {len(threats)} threat(s) found!")
            print(f"   Risk Score: {risk}/10")
            print("\n  Threats detected:")
            for threat in threats[:10]:
                print(f"    ‚Ä¢ [{threat.get('severity', 'N/A')}] {threat.get('pattern', 'Unknown')}")
                print(f"      File: {threat.get('file', 'Unknown')}")
            if len(threats) > 10:
                print(f"    ... and {len(threats) - 10} more")
        else:
            print(f"‚úÖ AI Scan complete: {files} files scanned, no threats found")
            print(f"   Risk Score: {risk}/10")
        
        if remaining >= 0:
            print(f"\n   Scans remaining today: {remaining}")
        return True
    else:
        print(f"‚ö†Ô∏è AI Scan completed with unknown status: {status}")
        return True


def main():
    """Main entry point"""
    if len(sys.argv) > 1:
        if sys.argv[1] == "--help" or sys.argv[1] == "-h":
            print("""
Aegis Security Center - All-in-One Security Dashboard

Usage:
  aegis-security-center              Launch GUI (or CLI if no display)
  aegis-security-center --status     Show security status
  aegis-security-center --scan [PATH] Run quick antivirus scan (default: /home)
  aegis-security-center --scan-full  Run full system scan (scans /)
  aegis-security-center --enable-fw  Enable firewall
  aegis-security-center --disable-fw Disable firewall
  aegis-security-center --events     Show recent security events
  aegis-security-center --ai-status  Show AI security tier status
  aegis-security-center --ai-scan [PATH] Run AI heuristic scan (default: /home)
  aegis-security-center --ai-behavioral Run AI behavioral analysis
  aegis-security-center --help       Show this help

AI Security Tiers:
  Freemium (Level 1): Basic heuristics, simple firewall
  Basic (Level 2):    + Realtime scanning, threat signatures, behavioral baseline
  Gamer (Level 3):    + Behavioral AI, gaming integrity monitor
  Workplace (Level 3): + Behavioral AI, endpoint protection, DLP
  AI-Dev (Level 4):   + ML threat detection, model integrity, adversarial protection
  Server (Level 5):   + Full XDR, eBPF detection, zero trust, SIEM, RASP

Examples:
  aegis-security-center --scan /tmp     Scan the /tmp directory
  aegis-security-center --ai-scan       AI scan /home directory
  aegis-security-center --ai-status     Show AI security capabilities
            """)
            return
        
        security = AegisSecurityCenter()
        
        if sys.argv[1] == "--status":
            show_cli_status(security)
        elif sys.argv[1] == "--scan":
            scan_path = sys.argv[2] if len(sys.argv) > 2 else "/home"
            print(f"üîÑ Running quick scan of {scan_path}...")
            print("   (This may take a few minutes depending on the size)")
            results = security.run_quick_scan(scan_path)
            print_scan_results(results)
        elif sys.argv[1] == "--scan-full":
            print("üîÑ Running full system scan...")
            print("   ‚ö†Ô∏è This may take a long time (up to 1 hour)")
            results = security.run_quick_scan("/", timeout=SCAN_TIMEOUT_FULL)
            print_scan_results(results)
        elif sys.argv[1] == "--enable-fw":
            print("üîÑ Enabling firewall...")
            if security.enable_firewall():
                print("‚úÖ Firewall enabled successfully")
            else:
                print("‚ùå Failed to enable firewall")
                print("   Tip: Make sure ufw or iptables is installed and you have sudo permissions")
                sys.exit(1)
        elif sys.argv[1] == "--disable-fw":
            print("üîÑ Disabling firewall...")
            if security.disable_firewall():
                print("‚ö†Ô∏è Firewall disabled")
            else:
                print("‚ùå Failed to disable firewall")
                print("   Tip: Make sure ufw or iptables is installed and you have sudo permissions")
                sys.exit(1)
        elif sys.argv[1] == "--events":
            events = security.load_events()[-20:]
            if events:
                print("\nüìã Recent Security Events:\n")
                for event in events:
                    timestamp = event.get('timestamp', 'Unknown')[:19]
                    severity = event.get('severity', 'info').upper()
                    message = event.get('message', 'No message')
                    print(f"[{timestamp}] [{severity}] {message}")
            else:
                print("\nüìã No security events recorded yet.\n")
        elif sys.argv[1] == "--ai-status":
            summary = security.get_ai_security_summary()
            if summary.get("available", False) or "tier" in summary:
                tier = summary.get("tier", summary)
                print("\nü§ñ AI Security Status")
                print("=" * 50)
                print(f"  Tier: {tier.get('tier_name', 'Unknown')}")
                level = tier.get('tier_level', 0)
                level_bars = "‚ñà" * level + "‚ñë" * (5 - level)
                print(f"  Level: [{level_bars}] {level}/5")
                print(f"  Description: {tier.get('description', 'N/A')}")
                print(f"\n  Capabilities ({tier.get('capabilities_count', len(tier.get('capabilities', [])))} active):")
                for cap in tier.get('capabilities', []):
                    print(f"    ‚úì {cap}")
                limits = tier.get('limits', {})
                print(f"\n  Limits:")
                print(f"    Scans per day: {limits.get('max_scans_per_day', 'Unlimited') if limits.get('max_scans_per_day', -1) != -1 else 'Unlimited'}")
                print(f"    Realtime Protection: {'‚úÖ Yes' if limits.get('realtime_protection') else '‚ùå No'}")
                print(f"    AI Analysis: {'‚úÖ Yes' if limits.get('ai_analysis') else '‚ùå No'}")
                
                available = summary.get('available_analyses', [])
                restricted = summary.get('restricted_analyses', [])
                if available:
                    print(f"\n  Available Analyses:")
                    for a in available:
                        print(f"    ‚úì {a}")
                if restricted:
                    print(f"\n  Upgrade to unlock:")
                    for a in restricted:
                        print(f"    ‚úó {a}")
                print()
            else:
                print(f"\n‚ùå AI Security unavailable: {summary.get('error', 'Module not loaded')}\n")
        elif sys.argv[1] == "--ai-scan":
            scan_path = sys.argv[2] if len(sys.argv) > 2 else "/home"
            print(f"ü§ñ Running AI heuristic scan of {scan_path}...")
            results = security.run_ai_heuristic_scan(scan_path)
            print_ai_scan_results(results)
        elif sys.argv[1] == "--ai-behavioral":
            print("ü§ñ Running AI behavioral analysis...")
            result = security.run_ai_behavioral_analysis()
            status = result.get("status", "unknown")
            if status == "completed":
                risk_level = result.get("risk_level", "unknown")
                anomalies = result.get("anomalies", [])
                risk_emoji = {"low": "‚úÖ", "medium": "‚ö†Ô∏è", "high": "üî¥"}.get(risk_level, "‚ùì")
                print(f"\n{risk_emoji} Behavioral Analysis Complete")
                print(f"   Risk Level: {risk_level.upper()}")
                print(f"   Model Type: {result.get('model_type', 'basic')}")
                if anomalies:
                    print(f"\n   Anomalies detected ({len(anomalies)}):")
                    for a in anomalies:
                        print(f"     ‚Ä¢ [{a.get('severity', 'N/A')}] {a.get('description', 'Unknown')}")
                else:
                    print("\n   No anomalies detected")
                print()
            elif status == "tier_restricted":
                print(f"\n‚ÑπÔ∏è {result.get('error', 'Feature not available')}")
                if result.get('upgrade_hint'):
                    print(f"   {result.get('upgrade_hint')}\n")
            else:
                print(f"\n‚ùå Analysis failed: {result.get('error', 'Unknown error')}\n")
        else:
            print(f"Unknown option: {sys.argv[1]}")
            print("Use --help for usage information")
            sys.exit(1)
    else:
        if TKINTER_AVAILABLE and os.environ.get('DISPLAY'):
            try:
                app = SecurityCenterGUI()
                app.run()
            except tk.TclError as e:
                print(f"GUI failed (display error): {e}")
                show_cli_status()
            except Exception as e:
                print(f"GUI failed: {e}")
                show_cli_status()
        else:
            show_cli_status()


if __name__ == "__main__":
    main()
